// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
)

// A generic payload return from entity archive or deletion mutations.
type ArchivePayload interface {
	IsArchivePayload()
	// The identifier of the last sync operation.
	GetLastSyncID() float64
	// Whether the operation was successful.
	GetSuccess() bool
}

// A basic entity.
type Entity interface {
	IsNode()
	IsEntity()
	// The unique identifier of the entity.
	GetID() string
	// The time at which the entity was created.
	GetCreatedAt() string
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	GetUpdatedAt() string
	// The time at which the entity was archived. Null if the entity has not been archived.
	GetArchivedAt() *string
}

type Node interface {
	IsNode()
	// The unique identifier of the entity.
	GetID() string
}

// A notification sent to a user.
type Notification interface {
	IsEntity()
	IsNode()
	IsNotification()
	// The unique identifier of the entity.
	GetID() string
	// The time at which the entity was created.
	GetCreatedAt() string
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	GetUpdatedAt() string
	// The time at which the entity was archived. Null if the entity has not been archived.
	GetArchivedAt() *string
	// Notification type.
	GetType() string
	// The user that caused the notification.
	GetActor() *User
	// The external user that caused the notification.
	GetExternalUserActor() *ExternalUser
	// The user that received the notification.
	GetUser() *User
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	GetReadAt() *string
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	GetEmailedAt() *string
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	GetSnoozedUntilAt() *string
	// The time at which a notification was unsnoozed..
	GetUnsnoozedAt() *string
	// [Internal] URL to the target of the notification.
	GetURL() string
	// [Internal] Inbox URL for the notification.
	GetInboxURL() string
	// [Internal] Notification title.
	GetTitle() string
	// [Internal] Notification subtitle.
	GetSubtitle() string
	// [Internal] If notification actor was Linear.
	GetIsLinearActor() bool
	// [Internal] Notification avatar URL.
	GetActorAvatarURL() *string
	// [Internal] Notification actor initials if avatar is not available.
	GetActorInitials() *string
	// [Internal] Notification actor initials if avatar is not available.
	GetActorAvatarColor() *string
	// [Internal] Issue's status type for issue notifications.
	GetIssueStatusType() *string
	// [Internal] Project update health for new updates.
	GetProjectUpdateHealth() *string
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GetGroupingKey() string
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GetGroupingPriority() float64
	// The bot that caused the notification.
	GetBotActor() *ActorBot
}

// Notification subscriptions for models.
type NotificationSubscription interface {
	IsEntity()
	IsNode()
	IsNotificationSubscription()
	// The unique identifier of the entity.
	GetID() string
	// The time at which the entity was created.
	GetCreatedAt() string
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	GetUpdatedAt() string
	// The time at which the entity was archived. Null if the entity has not been archived.
	GetArchivedAt() *string
	// The user that subscribed to receive notifications.
	GetSubscriber() *User
	// The contextual custom view associated with the notification subscription.
	GetCustomView() *CustomView
	// The contextual cycle view associated with the notification subscription.
	GetCycle() *Cycle
	// The contextual label view associated with the notification subscription.
	GetLabel() *IssueLabel
	// The contextual project view associated with the notification subscription.
	GetProject() *Project
	// The contextual initiative view associated with the notification subscription.
	GetInitiative() *Initiative
	// The team associated with the notification subscription.
	GetTeam() *Team
	// The user view associated with the notification subscription.
	GetUser() *User
	// The type of view to which the notification subscription context is associated with.
	GetContextViewType() *ContextViewType
	// The type of user view to which the notification subscription context is associated with.
	GetUserContextViewType() *UserContextViewType
	// Whether the subscription is active or not.
	GetActive() bool
}

type OrganizationInviteDetailsPayload interface {
	IsOrganizationInviteDetailsPayload()
}

// A bot actor is an actor that is not a user, but an application or integration.
type ActorBot struct {
	ID *string `json:"id,omitempty"`
	// The type of bot.
	Type string `json:"type"`
	// The sub type of the bot.
	SubType *string `json:"subType,omitempty"`
	// The display name of the bot.
	Name *string `json:"name,omitempty"`
	// The display name of the external user on behalf of which the bot acted.
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// A url pointing to the avatar representing this bot.
	AvatarURL *string `json:"avatarUrl,omitempty"`
}

type AirbyteConfigurationInput struct {
	// Linear export API key.
	APIKey string `json:"apiKey"`
}

// An API key. Grants access to the user's resources.
type APIKey struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The label of the API key.
	Label string `json:"label"`
}

func (APIKey) IsNode() {}

// The unique identifier of the entity.
func (this APIKey) GetID() string { return this.ID }

type APIKeyConnection struct {
	Edges    []*APIKeyEdge `json:"edges"`
	Nodes    []*APIKey     `json:"nodes"`
	PageInfo *PageInfo     `json:"pageInfo"`
}

type APIKeyCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The label for the API key.
	Label string `json:"label"`
	// The API key value.
	Key string `json:"key"`
}

type APIKeyEdge struct {
	Node *APIKey `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type APIKeyPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The API key that was created.
	APIKey *APIKey `json:"apiKey"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Public information of the OAuth application.
type Application struct {
	// OAuth application's ID.
	ID string `json:"id"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// Application name.
	Name string `json:"name"`
	// Information about the application.
	Description *string `json:"description,omitempty"`
	// Name of the developer.
	Developer string `json:"developer"`
	// Url of the developer (homepage or docs).
	DeveloperURL string `json:"developerUrl"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
}

// Contains requested archived model objects.
type ArchiveResponse struct {
	// A JSON serialized collection of model objects loaded from the archive
	Archive string `json:"archive"`
	// The total number of entities in the archive.
	TotalCount float64 `json:"totalCount"`
	// The version of the remote database. Incremented by 1 for each migration run on the database.
	DatabaseVersion float64 `json:"databaseVersion"`
	// Whether the dependencies for the model objects are included in the archive.
	IncludesDependencies bool `json:"includesDependencies"`
}

type AsksChannelConnectPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The new Asks Slack channel mapping for the connected channel.
	Mapping *SlackChannelNameMapping `json:"mapping"`
	// Whether the bot needs to be manually added to the channel.
	AddBot bool `json:"addBot"`
}

// Issue assignee sorting options.
type AssigneeSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// Issue attachment (e.g. support ticket, pull request).
type Attachment struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Content for the title line in the Linear attachment widget.
	Title string `json:"title"`
	// Content for the subtitle line in the Linear attachment widget.
	Subtitle *string `json:"subtitle,omitempty"`
	// Location of the attachment which is also used as an identifier.
	URL string `json:"url"`
	// The creator of the attachment.
	Creator *User `json:"creator,omitempty"`
	// The non-Linear user who created the attachment.
	ExternalUserCreator *ExternalUser `json:"externalUserCreator,omitempty"`
	// Custom metadata related to the attachment.
	Metadata string `json:"metadata"`
	// Information about the source which created the attachment.
	Source *string `json:"source,omitempty"`
	// An accessor helper to source.type, defines the source type of the attachment.
	SourceType *string `json:"sourceType,omitempty"`
	// Indicates if attachments for the same source application should be grouped in the Linear UI.
	GroupBySource bool `json:"groupBySource"`
	// The issue this attachment belongs to.
	Issue *Issue `json:"issue"`
}

func (Attachment) IsNode() {}

// The unique identifier of the entity.
func (this Attachment) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type AttachmentArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Attachment `json:"entity,omitempty"`
}

func (AttachmentArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this AttachmentArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this AttachmentArchivePayload) GetSuccess() bool { return this.Success }

// Attachment collection filtering options.
type AttachmentCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the subtitle.
	Subtitle *NullableStringComparator `json:"subtitle,omitempty"`
	// Comparator for the url.
	URL *StringComparator `json:"url,omitempty"`
	// Filters that the attachments creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Comparator for the source type.
	SourceType *SourceTypeComparator `json:"sourceType,omitempty"`
	// Compound filters, all of which need to be matched by the attachment.
	And []*AttachmentCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the attachment.
	Or []*AttachmentCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some attachments.
	Some *AttachmentFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all attachments.
	Every *AttachmentFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type AttachmentConnection struct {
	Edges    []*AttachmentEdge `json:"edges"`
	Nodes    []*Attachment     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type AttachmentCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The attachment title.
	Title string `json:"title"`
	// The attachment subtitle.
	Subtitle *string `json:"subtitle,omitempty"`
	// Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead.
	URL string `json:"url"`
	// The issue to associate the attachment with.
	IssueID string `json:"issueId"`
	// An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
	IconURL *string `json:"iconUrl,omitempty"`
	// Attachment metadata object with string and number values.
	Metadata *string `json:"metadata,omitempty"`
	// Indicates if attachments for the same source application should be grouped in the Linear UI.
	GroupBySource *bool `json:"groupBySource,omitempty"`
	// Create a linked comment with markdown body.
	CommentBody *string `json:"commentBody,omitempty"`
	// [Internal] Create a linked comment with Prosemirror body. Please use `commentBody` instead.
	CommentBodyData *string `json:"commentBodyData,omitempty"`
	// Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
	CreateAsUser *string `json:"createAsUser,omitempty"`
}

type AttachmentEdge struct {
	Node *Attachment `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Attachment filtering options.
type AttachmentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the subtitle.
	Subtitle *NullableStringComparator `json:"subtitle,omitempty"`
	// Comparator for the url.
	URL *StringComparator `json:"url,omitempty"`
	// Filters that the attachments creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Comparator for the source type.
	SourceType *SourceTypeComparator `json:"sourceType,omitempty"`
	// Compound filters, all of which need to be matched by the attachment.
	And []*AttachmentFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the attachment.
	Or []*AttachmentFilter `json:"or,omitempty"`
}

type AttachmentPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The issue attachment that was created.
	Attachment *Attachment `json:"attachment"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type AttachmentSourcesPayload struct {
	// A unique list of all source types used in this workspace.
	Sources string `json:"sources"`
}

type AttachmentUpdateInput struct {
	// The attachment title.
	Title string `json:"title"`
	// The attachment subtitle.
	Subtitle *string `json:"subtitle,omitempty"`
	// Attachment metadata object with string and number values.
	Metadata *string `json:"metadata,omitempty"`
	// An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
	IconURL *string `json:"iconUrl,omitempty"`
}

// Workspace audit log entry object.
type AuditEntry struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	Type       string  `json:"type"`
	// The organization the audit log belongs to.
	Organization *Organization `json:"organization,omitempty"`
	// The user that caused the audit entry to be created.
	Actor *User `json:"actor,omitempty"`
	// The ID of the user that caused the audit entry to be created.
	ActorID *string `json:"actorId,omitempty"`
	// IP from actor when entry was recorded.
	IP *string `json:"ip,omitempty"`
	// Country code of request resulting to audit entry.
	CountryCode *string `json:"countryCode,omitempty"`
	// Additional metadata related to the audit entry.
	Metadata *string `json:"metadata,omitempty"`
	// Additional information related to the request which performed the action.
	RequestInformation *string `json:"requestInformation,omitempty"`
}

func (AuditEntry) IsNode() {}

// The unique identifier of the entity.
func (this AuditEntry) GetID() string { return this.ID }

type AuditEntryConnection struct {
	Edges    []*AuditEntryEdge `json:"edges"`
	Nodes    []*AuditEntry     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type AuditEntryEdge struct {
	Node *AuditEntry `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Audit entry filtering options.
type AuditEntryFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the type.
	Type *StringComparator `json:"type,omitempty"`
	// Comparator for the IP address.
	IP *StringComparator `json:"ip,omitempty"`
	// Comparator for the country code.
	CountryCode *StringComparator `json:"countryCode,omitempty"`
	// Filters that the audit entry actor must satisfy.
	Actor *NullableUserFilter `json:"actor,omitempty"`
}

type AuditEntryType struct {
	// The audit entry type.
	Type string `json:"type"`
	// Description of the audit entry type.
	Description string `json:"description"`
}

type AuthAPIKey struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
}

type AuthAPIKeyCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The label for the API key.
	Label string `json:"label"`
	// The API key value.
	Key string `json:"key"`
}

type AuthAPIKeyPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The auth API key that was created.
	AuthAPIKey *AuthAPIKey `json:"authApiKey"`
}

// An email address that can be used for submitting issues.
type AuthEmailIntakeAddress struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// Unique email address user name (before @) used for incoming email.
	Address string `json:"address"`
	// Whether the email address is enabled.
	Enabled bool `json:"enabled"`
	// The auth organization that the email address is associated with.
	Organization *AuthOrganization `json:"organization"`
	// The auth user who created the email intake address.
	Creator *AuthUser `json:"creator,omitempty"`
}

type AuthIntegration struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
}

// [INTERNAL] An OAuth userId/createdDate tuple
type AuthMembership struct {
	// The authorizing userId
	UserID string `json:"userId"`
	// The date of the authorization
	CreatedAt string `json:"createdAt"`
}

type AuthOauthClient struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// OAuth application's client name.
	Name string `json:"name"`
	// Information about the application.
	Description *string `json:"description,omitempty"`
	// Name of the developer.
	Developer string `json:"developer"`
	// Url of the developer.
	DeveloperURL string `json:"developerUrl"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// OAuth application's client secret.
	ClientSecret string `json:"clientSecret"`
	// List of allowed redirect URIs for the application.
	RedirectUris []string `json:"redirectUris"`
	// Whether the OAuth application can be installed in other organizations.
	PublicEnabled bool `json:"publicEnabled"`
	// The ID of the user who created the OAuth application.
	CreatorID string `json:"creatorId"`
	// The ID of the workspace the OAuth application belongs to.
	OrganizationID string `json:"organizationId"`
	// The resource types to request when creating new webhooks.
	WebhookResourceTypes []string `json:"webhookResourceTypes"`
	// Webhook URL
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Webhook secret
	WebhookSecret *string `json:"webhookSecret,omitempty"`
	ArchivedAt    *string `json:"archivedAt,omitempty"`
}

// AuthOauthClient with token creator IDs and counts (memberships), for use in the GraphQL API.
type AuthOauthClientWithMemberships struct {
	// Application name.
	Name string `json:"name"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Scopes that are authorized for this application for a given user.
	Scope []string `json:"scope"`
	// OAuth application's ID.
	AppID string `json:"appId"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// The application's webhook URL.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Total number of members that authorized the application.
	TotalMembers float64 `json:"totalMembers"`
	// User IDs and membership dates of everyone who has authorized the application with the set of scopes.
	Memberships []*AuthMembership `json:"memberships"`
}

// AuthOauthClient with scope from OauthToken, for use in the GraphQL API.
type AuthOauthClientWithScope struct {
	// Application name.
	Name string `json:"name"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Scopes that are authorized for this application for a given user.
	Scope []string `json:"scope"`
	// OAuth application's ID.
	AppID string `json:"appId"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// The application's webhook URL.
	WebhookURL *string `json:"webhookUrl,omitempty"`
}

type AuthOauthClientWithTokens struct {
	// The auth OAuth client.
	Client *AuthOauthClient `json:"client"`
	// The token matching the app, scope, and actor.
	Tokens []*OauthToken `json:"tokens"`
}

// An organization. Organizations are root-level objects that contain users and teams.
type AuthOrganization struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The organization's name.
	Name string `json:"name"`
	// Whether the organization is enabled. Used as a superuser tool to lock down the org.
	Enabled bool `json:"enabled"`
	// The organization's unique URL key.
	URLKey string `json:"urlKey"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousURLKeys []string `json:"previousUrlKeys"`
	// The organization's logo URL.
	LogoURL *string `json:"logoUrl,omitempty"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *string `json:"deletionRequestedAt,omitempty"`
	// The feature release channel the organization belongs to.
	ReleaseChannel ReleaseChannel `json:"releaseChannel"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled bool `json:"samlEnabled"`
	// [INTERNAL] SAML settings
	SamlSettings *string `json:"samlSettings,omitempty"`
	// Allowed authentication providers, empty array means all are allowed
	AllowedAuthServices []string `json:"allowedAuthServices"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled bool `json:"scimEnabled"`
	// The email domain or URL key for the organization.
	ServiceID string `json:"serviceId"`
	// The region the organization is hosted in.
	Region    string  `json:"region"`
	UserCount float64 `json:"userCount"`
}

type AuthOrganizationBucketNamePayload struct {
	// The region for the organization.
	Region string `json:"region"`
	// The imports bucket name for the organization.
	ImportsBucketName string `json:"importsBucketName"`
	// The uploads bucket name for the organization.
	UploadsBucketName string `json:"uploadsBucketName"`
}

type AuthOrganizationDomain struct {
	// The unique identifier of the entity.
	ID             string `json:"id"`
	OrganizationID string `json:"organizationId"`
	Name           string `json:"name"`
	Verified       bool   `json:"verified"`
	Claimed        *bool  `json:"claimed,omitempty"`
	// Prevent users with this domain to create new workspaces.
	DisableOrganizationCreation *bool                      `json:"disableOrganizationCreation,omitempty"`
	AuthType                    OrganizationDomainAuthType `json:"authType"`
}

type AuthOrganizationExistsPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// Whether the organization exists.
	Exists bool `json:"exists"`
}

// An invitation to the organization that has been sent via email.
type AuthOrganizationInvite struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the invite will be expiring. Null, if the invite shouldn't expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

type AuthOrganizationPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The auth organization that was updated.
	AuthOrganization *AuthOrganization `json:"authOrganization"`
}

type AuthOrganizationUpdateInput struct {
	// The organization's unique URL key.
	URLKey *string `json:"urlKey,omitempty"`
	// The organization's unique invite hash.
	InviteHash *string `json:"inviteHash,omitempty"`
}

type AuthResolverResponse struct {
	// User account ID.
	ID string `json:"id"`
	// Email for the authenticated account.
	Email string `json:"email"`
	// Should the signup flow allow access for the domain.
	AllowDomainAccess *bool `json:"allowDomainAccess,omitempty"`
	// List of active users that belong to the user account.
	Users []*AuthUser `json:"users"`
	// List of locked users that are locked by login restrictions
	LockedUsers []*AuthUser `json:"lockedUsers"`
	// List of organizations allowing this user account to join automatically.
	AvailableOrganizations []*AuthOrganization `json:"availableOrganizations,omitempty"`
	// List of organization available to this user account but locked due to the current auth method.
	LockedOrganizations []*AuthOrganization `json:"lockedOrganizations,omitempty"`
	// ID of the organization last accessed by the user.
	LastUsedOrganizationID *string `json:"lastUsedOrganizationId,omitempty"`
	// Application token.
	Token *string `json:"token,omitempty"`
}

type AuthSuccessPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// A user that has access to the the resources of an organization.
type AuthUser struct {
	ID string `json:"id"`
	// The user's full name.
	Name string `json:"name"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName string `json:"displayName"`
	// The user's email address.
	Email string `json:"email"`
	// An URL to the user's avatar image.
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Whether the user is an organization admin or guest on a database level.
	Role UserRoleType `json:"role"`
	// Whether the user is active.
	Active bool `json:"active"`
	// User account ID the user belongs to.
	UserAccountID string `json:"userAccountId"`
	// Organization the user belongs to.
	Organization *AuthOrganization `json:"organization"`
}

// User authentication session.
type AuthenticationSession struct {
	ID string `json:"id"`
	// Type of application used to authenticate.
	Type AuthenticationSessionType `json:"type"`
	// IP address.
	IP *string `json:"ip,omitempty"`
	// Location country name.
	LocationCountry *string `json:"locationCountry,omitempty"`
	// Location country code.
	LocationCountryCode *string `json:"locationCountryCode,omitempty"`
	// Country codes of all seen locations.
	CountryCodes []string `json:"countryCodes"`
	// Location region code.
	LocationRegionCode *string `json:"locationRegionCode,omitempty"`
	// Location city name.
	LocationCity *string `json:"locationCity,omitempty"`
	// Session's user-agent.
	UserAgent *string `json:"userAgent,omitempty"`
	// Used web browser.
	BrowserType *string `json:"browserType,omitempty"`
	// When was the session last seen
	LastActiveAt *string `json:"lastActiveAt,omitempty"`
	// Date when the session was created.
	CreatedAt string `json:"createdAt"`
	// Date when the session was last updated.
	UpdatedAt string `json:"updatedAt"`
	// Human readable location
	Location *string `json:"location,omitempty"`
	// Operating system used for the session
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// Client used for the session
	Client *string `json:"client,omitempty"`
	// Name of the session, derived from the client and operating system
	Name string `json:"name"`
}

// Authentication session information.
type AuthenticationSessionResponse struct {
	ID string `json:"id"`
	// Type of application used to authenticate.
	Type AuthenticationSessionType `json:"type"`
	// IP address.
	IP *string `json:"ip,omitempty"`
	// Location country name.
	LocationCountry *string `json:"locationCountry,omitempty"`
	// Location country code.
	LocationCountryCode *string `json:"locationCountryCode,omitempty"`
	// Country codes of all seen locations.
	CountryCodes []string `json:"countryCodes"`
	// Location region code.
	LocationRegionCode *string `json:"locationRegionCode,omitempty"`
	// Location city name.
	LocationCity *string `json:"locationCity,omitempty"`
	// Session's user-agent.
	UserAgent *string `json:"userAgent,omitempty"`
	// Used web browser.
	BrowserType *string `json:"browserType,omitempty"`
	// When was the session last seen
	LastActiveAt *string `json:"lastActiveAt,omitempty"`
	// Date when the session was created.
	CreatedAt string `json:"createdAt"`
	// Date when the session was last updated.
	UpdatedAt string `json:"updatedAt"`
	// Human readable location
	Location *string `json:"location,omitempty"`
	// Operating system used for the session
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// Client used for the session
	Client *string `json:"client,omitempty"`
	// Name of the session, derived from the client and operating system
	Name string `json:"name"`
	// Identifies the session used to make the request.
	IsCurrentSession bool `json:"isCurrentSession"`
}

// [INTERNAL] Public information of the OAuth application, plus the authorized scopes for a given user.
type AuthorizedApplication struct {
	// Application name.
	Name string `json:"name"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Scopes that are authorized for this application for a given user.
	Scope []string `json:"scope"`
	// OAuth application's ID.
	AppID string `json:"appId"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// Whether or not webhooks are enabled for the application.
	WebhooksEnabled bool `json:"webhooksEnabled"`
}

type AuthorizedApplicationBase struct {
	// Application name.
	Name string `json:"name"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Scopes that are authorized for this application for a given user.
	Scope []string `json:"scope"`
	// OAuth application's ID.
	AppID string `json:"appId"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
}

// Comparator for booleans.
type BooleanComparator struct {
	// Equals constraint.
	Eq *bool `json:"eq,omitempty"`
	// Not equals constraint.
	Neq *bool `json:"neq,omitempty"`
}

// A comment associated with an issue.
type Comment struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The comment content in markdown format.
	Body string `json:"body"`
	// The issue that the comment is associated with.
	Issue *Issue `json:"issue,omitempty"`
	// The document content that the comment is associated with.
	DocumentContent *DocumentContent `json:"documentContent,omitempty"`
	// The project update that the comment is associated with.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate,omitempty"`
	// The parent comment under which the current comment is nested.
	Parent *Comment `json:"parent,omitempty"`
	// The user that resolved the thread.
	ResolvingUser *User `json:"resolvingUser,omitempty"`
	// The time the resolvingUser resolved the thread.
	ResolvedAt *string `json:"resolvedAt,omitempty"`
	// The comment that resolved the thread.
	ResolvingComment *Comment `json:"resolvingComment,omitempty"`
	// The user who wrote the comment.
	User *User `json:"user,omitempty"`
	// The external user who wrote the comment.
	ExternalUser *ExternalUser `json:"externalUser,omitempty"`
	// The time user edited the comment.
	EditedAt *string `json:"editedAt,omitempty"`
	// [Internal] The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The text that this comment references. Only defined for inline comments.
	QuotedText *string `json:"quotedText,omitempty"`
	// [Internal] Summary for comment thread.
	SummaryText *string `json:"summaryText,omitempty"`
	// Emoji reaction summary, grouped by emoji type.
	ReactionData string `json:"reactionData"`
	// Comment's URL.
	URL string `json:"url"`
	// The children of the comment.
	Children *CommentConnection `json:"children"`
	// The bot that created the comment.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Reactions associated with the comment.
	Reactions []*Reaction `json:"reactions"`
}

func (Comment) IsNode() {}

// The unique identifier of the entity.
func (this Comment) GetID() string { return this.ID }

// Comment filtering options.
type CommentCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the comments body.
	Body *StringComparator `json:"body,omitempty"`
	// Filters that the comments creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
	// Filters that the comments issue must satisfy.
	Issue *NullableIssueFilter `json:"issue,omitempty"`
	// Filters that the comments project update must satisfy.
	ProjectUpdate *ProjectUpdateFilter `json:"projectUpdate,omitempty"`
	// Filters that the comment parent must satisfy.
	Parent *NullableCommentFilter `json:"parent,omitempty"`
	// Filters that the comments document content must satisfy.
	DocumentContent *DocumentContentFilter `json:"documentContent,omitempty"`
	// Filters that the comments reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the comment's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the comment.
	And []*CommentCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the comment.
	Or []*CommentCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some comments.
	Some *CommentFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all comments.
	Every *CommentFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type CommentConnection struct {
	Edges    []*CommentEdge `json:"edges"`
	Nodes    []*Comment     `json:"nodes"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

type CommentCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The comment content in markdown format.
	Body *string `json:"body,omitempty"`
	// [Internal] The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The issue to associate the comment with.
	IssueID *string `json:"issueId,omitempty"`
	// The project update to associate the comment with.
	ProjectUpdateID *string `json:"projectUpdateId,omitempty"`
	// The document content to associate the comment with.
	DocumentContentID *string `json:"documentContentId,omitempty"`
	// The parent comment under which to nest a current comment.
	ParentID *string `json:"parentId,omitempty"`
	// Create comment as a user with the provided name. This option is only available to OAuth applications creating comments in `actor=application` mode.
	CreateAsUser *string `json:"createAsUser,omitempty"`
	// Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
	DisplayIconURL *string `json:"displayIconUrl,omitempty"`
	// The date when the comment was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now.
	CreatedAt *string `json:"createdAt,omitempty"`
	// Flag to prevent auto subscription to the issue the comment is created on.
	DoNotSubscribeToIssue *bool `json:"doNotSubscribeToIssue,omitempty"`
	// Flag to indicate this comment should be created on the issue's synced Slack comment thread. If no synced Slack comment thread exists, the mutation will fail.
	CreateOnSyncedSlackThread *bool `json:"createOnSyncedSlackThread,omitempty"`
	// The text that this comment references. Only defined for inline comments.
	QuotedText *string `json:"quotedText,omitempty"`
	// [INTERNAL] The identifiers of the users subscribing to this comment thread.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
}

type CommentEdge struct {
	Node *Comment `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Comment filtering options.
type CommentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the comments body.
	Body *StringComparator `json:"body,omitempty"`
	// Filters that the comments creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
	// Filters that the comments issue must satisfy.
	Issue *NullableIssueFilter `json:"issue,omitempty"`
	// Filters that the comments project update must satisfy.
	ProjectUpdate *ProjectUpdateFilter `json:"projectUpdate,omitempty"`
	// Filters that the comment parent must satisfy.
	Parent *NullableCommentFilter `json:"parent,omitempty"`
	// Filters that the comments document content must satisfy.
	DocumentContent *DocumentContentFilter `json:"documentContent,omitempty"`
	// Filters that the comments reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the comment's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the comment.
	And []*CommentFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the comment.
	Or []*CommentFilter `json:"or,omitempty"`
}

// A comment related notification.
type CommentNotification struct {
	// Related comment ID. Null if the notification is not related to a comment.
	CommentID *string `json:"commentId,omitempty"`
	// Related parent comment ID. Null if the notification is not related to a comment.
	ParentCommentID *string `json:"parentCommentId,omitempty"`
	// Name of the reaction emoji related to the notification.
	ReactionEmoji *string `json:"reactionEmoji,omitempty"`
}

type CommentPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The comment that was created or updated.
	Comment *Comment `json:"comment"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type CommentUpdateInput struct {
	// The comment content.
	Body *string `json:"body,omitempty"`
	// The comment content as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// [INTERNAL] The user who resolved this thread.
	ResolvingUserID *string `json:"resolvingUserId,omitempty"`
	// [INTERNAL] The child comment that resolves this thread.
	ResolvingCommentID *string `json:"resolvingCommentId,omitempty"`
	// The text that this comment references. Only defined for inline comments.
	QuotedText *string `json:"quotedText,omitempty"`
	// [INTERNAL] The identifiers of the users subscribing to this comment.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
	// [INTERNAL] Flag to prevent auto subscription to the issue the comment is updated on.
	DoNotSubscribeToIssue *bool `json:"doNotSubscribeToIssue,omitempty"`
}

// Issue completion date sorting options.
type CompletedAtSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type ContactCreateInput struct {
	// The type of support contact.
	Type string `json:"type"`
	// The message the user sent.
	Message string `json:"message"`
	// User's operating system.
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// User's browser information.
	Browser *string `json:"browser,omitempty"`
	// User's device information.
	Device *string `json:"device,omitempty"`
	// User's Linear client information.
	ClientVersion *string `json:"clientVersion,omitempty"`
	// How disappointed the user would be if they could no longer use Linear.
	DisappointmentRating *int64 `json:"disappointmentRating,omitempty"`
}

type ContactPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// [INTERNAL] Input for sending a message to the Linear Sales team.
type ContactSalesCreateInput struct {
	// Name of the person requesting information.
	Name string `json:"name"`
	// Work email of the person requesting information.
	Email string `json:"email"`
	// Size of the company.
	CompanySize *string `json:"companySize,omitempty"`
	// The message the user sent.
	Message *string `json:"message,omitempty"`
}

// [Internal] Comparator for content.
type ContentComparator struct {
	// [Internal] Contains constraint.
	Contains *string `json:"contains,omitempty"`
	// [Internal] Not-contains constraint.
	NotContains *string `json:"notContains,omitempty"`
}

type CreateCSVExportReportPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type CreateOrJoinOrganizationResponse struct {
	Organization *AuthOrganization `json:"organization"`
	User         *AuthUser         `json:"user"`
}

type CreateOrganizationInput struct {
	// The name of the organization.
	Name string `json:"name"`
	// The URL key of the organization.
	URLKey string `json:"urlKey"`
	// Whether the organization should allow email domain access.
	DomainAccess *bool `json:"domainAccess,omitempty"`
	// The timezone of the organization, passed in by client.
	Timezone *string `json:"timezone,omitempty"`
	// JSON serialized UTM parameters associated with the creation of the workspace.
	Utm *string `json:"utm,omitempty"`
}

// Issue creation date sorting options.
type CreatedAtSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// [ALPHA] A custom attribute on a Customer entity.
type CustomAttribute struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The customer that this custom attribute is attached to.
	Customer *Customer `json:"customer"`
	// The field that is defining this custom attribute.
	Field *CustomerSchemaField `json:"field"`
	// The type of the value stored by the attribute.
	Type SchemaFieldType `json:"type"`
	// The value of the custom attribute.
	Value string `json:"value"`
}

func (CustomAttribute) IsNode() {}

// The unique identifier of the entity.
func (this CustomAttribute) GetID() string { return this.ID }

type CustomAttributeConnection struct {
	Edges    []*CustomAttributeEdge `json:"edges"`
	Nodes    []*CustomAttribute     `json:"nodes"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type CustomAttributeEdge struct {
	Node *CustomAttribute `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// A custom view that has been saved by a user.
type CustomView struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the custom view.
	Name string `json:"name"`
	// The description of the custom view.
	Description *string `json:"description,omitempty"`
	// The icon of the custom view.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon of the custom view.
	Color *string `json:"color,omitempty"`
	// The organization of the custom view.
	Organization *Organization `json:"organization"`
	// The user who created the custom view.
	Creator *User `json:"creator"`
	// The user who owns the custom view.
	Owner *User `json:"owner"`
	// The user who last updated the custom view.
	UpdatedBy *User `json:"updatedBy"`
	// The filters applied to issues in the custom view.
	Filters string `json:"filters"`
	// The filter applied to issues in the custom view.
	FilterData string `json:"filterData"`
	// The filter applied to projects in the custom view.
	ProjectFilterData *string `json:"projectFilterData,omitempty"`
	// Whether the custom view is shared with everyone in the organization.
	Shared bool `json:"shared"`
	// The custom view's unique URL slug.
	SlugID *string `json:"slugId,omitempty"`
	// The model name of the custom view.
	ModelName string `json:"modelName"`
	// The team associated with the custom view.
	Team *Team `json:"team,omitempty"`
	// Projects associated with the custom view.
	Projects *ProjectConnection `json:"projects"`
	// Issues associated with the custom view.
	Issues *IssueConnection `json:"issues"`
	// The current users view preferences for this custom view.
	UserViewPreferences *ViewPreferences `json:"userViewPreferences,omitempty"`
	// The organizations default view preferences for this custom view.
	OrganizationViewPreferences *ViewPreferences `json:"organizationViewPreferences,omitempty"`
	// The calculated view preferences values for this custom view.
	ViewPreferencesValues *ViewPreferencesValues `json:"viewPreferencesValues,omitempty"`
}

func (CustomView) IsNode() {}

// The unique identifier of the entity.
func (this CustomView) GetID() string { return this.ID }

type CustomViewConnection struct {
	Edges    []*CustomViewEdge `json:"edges"`
	Nodes    []*CustomView     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type CustomViewCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the custom view.
	Name string `json:"name"`
	// The description of the custom view.
	Description *string `json:"description,omitempty"`
	// The icon of the custom view.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon of the custom view.
	Color *string `json:"color,omitempty"`
	// The id of the team associated with the custom view.
	TeamID *string `json:"teamId,omitempty"`
	// The id of the project associated with the custom view.
	ProjectID *string `json:"projectId,omitempty"`
	// The id of the initiative associated with the custom view.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The owner of the custom view.
	OwnerID *string `json:"ownerId,omitempty"`
	// The filters applied to issues in the custom view.
	Filters *string `json:"filters,omitempty"`
	// The filter applied to issues in the custom view.
	FilterData *IssueFilter `json:"filterData,omitempty"`
	// The project filter applied to issues in the custom view.
	ProjectFilterData *ProjectFilter `json:"projectFilterData,omitempty"`
	// Whether the custom view is shared with everyone in the organization.
	Shared *bool `json:"shared,omitempty"`
}

type CustomViewEdge struct {
	Node *CustomView `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type CustomViewHasSubscribersPayload struct {
	// Whether the custom view has subscribers.
	HasSubscribers bool `json:"hasSubscribers"`
}

// A custom view notification subscription.
type CustomViewNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The custom view subscribed to.
	CustomView *CustomView `json:"customView"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (CustomViewNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this CustomViewNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this CustomViewNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this CustomViewNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this CustomViewNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (CustomViewNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (CustomViewNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this CustomViewNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this CustomViewNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this CustomViewNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this CustomViewNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this CustomViewNotificationSubscription) GetActive() bool { return this.Active }

type CustomViewPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The custom view that was created or updated.
	CustomView *CustomView `json:"customView"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type CustomViewSuggestionPayload struct {
	// The suggested view name.
	Name *string `json:"name,omitempty"`
	// The suggested view description.
	Description *string `json:"description,omitempty"`
	// The suggested view icon.
	Icon *string `json:"icon,omitempty"`
}

type CustomViewUpdateInput struct {
	// The name of the custom view.
	Name *string `json:"name,omitempty"`
	// The description of the custom view.
	Description *string `json:"description,omitempty"`
	// The icon of the custom view.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon of the custom view.
	Color *string `json:"color,omitempty"`
	// The id of the team associated with the custom view.
	TeamID *string `json:"teamId,omitempty"`
	// [Internal] The id of the project associated with the custom view.
	ProjectID *string `json:"projectId,omitempty"`
	// [Internal] The id of the initiative associated with the custom view.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The owner of the custom view.
	OwnerID *string `json:"ownerId,omitempty"`
	// The filters applied to issues in the custom view.
	Filters *string `json:"filters,omitempty"`
	// The filter applied to issues in the custom view.
	FilterData *IssueFilter `json:"filterData,omitempty"`
	// The project filter applied to issues in the custom view.
	ProjectFilterData *ProjectFilter `json:"projectFilterData,omitempty"`
	// Whether the custom view is shared with everyone in the organization.
	Shared *bool `json:"shared,omitempty"`
}

// [ALPHA] A customer whose needs will be tied to issues or projects.
type Customer struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The customer's name.
	Name string `json:"name"`
	// The customer's logo URL.
	LogoURL *string `json:"logoUrl,omitempty"`
	// The domains associated with this customer.
	Domains []string `json:"domains"`
	// The ids of the customers in external systems.
	ExternalIds []string `json:"externalIds"`
	// The ID of the Slack channel used to interact with the customer.
	SlackChannelID *string `json:"slackChannelId,omitempty"`
	// The user who owns the customer.
	Owner *User `json:"owner,omitempty"`
	// The current status of the customer.
	Status *CustomerStatus `json:"status"`
	// The revenue generated by the customer.
	Revenue *float64 `json:"revenue,omitempty"`
	// The size of the customer.
	Size *float64 `json:"size,omitempty"`
	// The tier of the customer.
	Tier *CustomerTier `json:"tier,omitempty"`
}

func (Customer) IsNode() {}

// The unique identifier of the entity.
func (this Customer) GetID() string { return this.ID }

// Customer filtering options.
type CustomerCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the customer slack channel ID.
	SlackChannelID *StringComparator `json:"slackChannelId,omitempty"`
	// Comparator for the customer's domains.
	Domains *StringArrayComparator `json:"domains,omitempty"`
	// Comparator for the customer's external IDs.
	ExternalIds *StringArrayComparator `json:"externalIds,omitempty"`
	// Filters that the customer owner must satisfy.
	Owner *UserFilter `json:"owner,omitempty"`
	// Filters that the customer's needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Comparator for the customer generated revenue.
	Revenue *NumberComparator `json:"revenue,omitempty"`
	// Comparator for the customer size.
	Size *NumberComparator `json:"size,omitempty"`
	// Filters that the customer's status must satisfy.
	Status *CustomerStatusFilter `json:"status,omitempty"`
	// Filters that the customer's tier must satisfy.
	Tier *CustomerTierFilter `json:"tier,omitempty"`
	// Compound filters, all of which need to be matched by the customer.
	And []*CustomerCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the customer.
	Or []*CustomerCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some customers.
	Some *CustomerFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all customers.
	Every *CustomerFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type CustomerConnection struct {
	Edges    []*CustomerEdge `json:"edges"`
	Nodes    []*Customer     `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type CustomerCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the customer.
	Name string `json:"name"`
	// The domains associated with this customer.
	Domains []string `json:"domains,omitempty"`
	// The ids of the customers in external systems.
	ExternalIds []string `json:"externalIds,omitempty"`
	// The ID of the Slack channel used to interact with the customer.
	SlackChannelID *string `json:"slackChannelId,omitempty"`
	// The user who owns the customer.
	OwnerID *string `json:"ownerId,omitempty"`
	// The status of the customer.
	StatusID *string `json:"statusId,omitempty"`
	// The revenue generated by the customer.
	Revenue *string `json:"revenue,omitempty"`
	// The size of the customer.
	Size *string `json:"size,omitempty"`
	// The tier of the customer customer.
	TierID *string `json:"tierId,omitempty"`
}

// Customer creation date sorting options.
type CustomerCreatedAtSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type CustomerEdge struct {
	Node *Customer `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Customer filtering options.
type CustomerFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the customer slack channel ID.
	SlackChannelID *StringComparator `json:"slackChannelId,omitempty"`
	// Comparator for the customer's domains.
	Domains *StringArrayComparator `json:"domains,omitempty"`
	// Comparator for the customer's external IDs.
	ExternalIds *StringArrayComparator `json:"externalIds,omitempty"`
	// Filters that the customer owner must satisfy.
	Owner *UserFilter `json:"owner,omitempty"`
	// Filters that the customer's needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Comparator for the customer generated revenue.
	Revenue *NumberComparator `json:"revenue,omitempty"`
	// Comparator for the customer size.
	Size *NumberComparator `json:"size,omitempty"`
	// Filters that the customer's status must satisfy.
	Status *CustomerStatusFilter `json:"status,omitempty"`
	// Filters that the customer's tier must satisfy.
	Tier *CustomerTierFilter `json:"tier,omitempty"`
	// Compound filters, all of which need to be matched by the customer.
	And []*CustomerFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the customer.
	Or []*CustomerFilter `json:"or,omitempty"`
}

// [ALPHA] A customer need, expressed through a reference to an issue, project, or comment.
type CustomerNeed struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The customer that this need is attached to.
	Customer *Customer `json:"customer"`
	// The issue this need is referencing.
	Issue *Issue `json:"issue,omitempty"`
	// The project this need is referencing.
	Project *Project `json:"project,omitempty"`
	// The comment this need is referencing.
	Comment *Comment `json:"comment,omitempty"`
	// The attachment this need is referencing.
	Attachment *Attachment `json:"attachment,omitempty"`
	// The priority of the customer need. 0 = No priority, 1 = Critical, 2 = Important, 3 = Nice to have.
	Priority float64 `json:"priority"`
	// The need content in markdown format.
	Body *string `json:"body,omitempty"`
	// [Internal] The content of the need as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The creator of the customer need.
	Creator *User `json:"creator,omitempty"`
}

func (CustomerNeed) IsNode() {}

// The unique identifier of the entity.
func (this CustomerNeed) GetID() string { return this.ID }

// Customer needs filtering options.
type CustomerNeedCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer need priority.
	Priority *NumberComparator `json:"priority,omitempty"`
	// Filters that the need's project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the need's issue must satisfy.
	Issue *NullableIssueFilter `json:"issue,omitempty"`
	// Filters that the need's comment must satisfy.
	Comment *NullableCommentFilter `json:"comment,omitempty"`
	// Filters that the need's customer must satisfy.
	Customer *CustomerFilter `json:"customer,omitempty"`
	// Compound filters, all of which need to be matched by the customer needs.
	And []*CustomerNeedCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the customer needs.
	Or []*CustomerNeedCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some customer needs.
	Some *CustomerNeedFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all customer needs.
	Every *CustomerNeedFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type CustomerNeedConnection struct {
	Edges    []*CustomerNeedEdge `json:"edges"`
	Nodes    []*CustomerNeed     `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

type CustomerNeedCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The uuid of the customer the need belongs to.
	CustomerID string `json:"customerId"`
	// The issue this need is referencing.
	IssueID *string `json:"issueId,omitempty"`
	// The project this need is referencing.
	ProjectID *string `json:"projectId,omitempty"`
	// The comment this need is referencing.
	CommentID *string `json:"commentId,omitempty"`
	// The attachment this need is referencing.
	AttachmentID *string `json:"attachmentId,omitempty"`
	// The priority of the customer need. 0 = No priority, 1 = Critical, 2 = Important, 3 = Nice to have.
	Priority *float64 `json:"priority,omitempty"`
	// The content of the need in markdown format.
	Body *string `json:"body,omitempty"`
	// [Internal] The content of the need as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
}

type CustomerNeedEdge struct {
	Node *CustomerNeed `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Customer filtering options.
type CustomerNeedFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer need priority.
	Priority *NumberComparator `json:"priority,omitempty"`
	// Filters that the need's project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the need's issue must satisfy.
	Issue *NullableIssueFilter `json:"issue,omitempty"`
	// Filters that the need's comment must satisfy.
	Comment *NullableCommentFilter `json:"comment,omitempty"`
	// Filters that the need's customer must satisfy.
	Customer *CustomerFilter `json:"customer,omitempty"`
	// Compound filters, all of which need to be matched by the customer need.
	And []*CustomerNeedFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the customer need.
	Or []*CustomerNeedFilter `json:"or,omitempty"`
}

type CustomerNeedPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The customer need that was created or updated.
	Need *CustomerNeed `json:"need"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type CustomerNeedUpdateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The uuid of the customer the need belongs to.
	CustomerID *string `json:"customerId,omitempty"`
	// The priority of the customer need. 0 = No priority, 1 = Critical, 2 = Important, 3 = Nice to have.
	Priority *float64 `json:"priority,omitempty"`
	// The content of the need in markdown format.
	Body *string `json:"body,omitempty"`
	// [Internal] The content of the need as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
}

type CustomerPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The customer that was created or updated.
	Customer *Customer `json:"customer"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// [ALPHA] A customer schema.
type CustomerSchema struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The schema display name.
	DisplayName string `json:"displayName"`
}

func (CustomerSchema) IsNode() {}

// The unique identifier of the entity.
func (this CustomerSchema) GetID() string { return this.ID }

type CustomerSchemaConnection struct {
	Edges    []*CustomerSchemaEdge `json:"edges"`
	Nodes    []*CustomerSchema     `json:"nodes"`
	PageInfo *PageInfo             `json:"pageInfo"`
}

type CustomerSchemaEdge struct {
	Node *CustomerSchema `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// [ALPHA] A customer schema field.
type CustomerSchemaField struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the field in the schema.
	Name string `json:"name"`
	// The type of the field in the schema.
	Type SchemaFieldType `json:"type"`
	// Whether this field is enabled to be used as a custom attribute.
	Enabled bool `json:"enabled"`
}

func (CustomerSchemaField) IsNode() {}

// The unique identifier of the entity.
func (this CustomerSchemaField) GetID() string { return this.ID }

type CustomerSchemaFieldConnection struct {
	Edges    []*CustomerSchemaFieldEdge `json:"edges"`
	Nodes    []*CustomerSchemaField     `json:"nodes"`
	PageInfo *PageInfo                  `json:"pageInfo"`
}

type CustomerSchemaFieldEdge struct {
	Node *CustomerSchemaField `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Customer sorting options.
type CustomerSortInput struct {
	// Sort by name
	Name *NameSort `json:"name,omitempty"`
	// Sort by customer creation date
	CreatedAt *CustomerCreatedAtSort `json:"createdAt,omitempty"`
	// Sort by owner name
	Owner *OwnerSort `json:"owner,omitempty"`
	// Sort by customer status
	Status *CustomerStatusSort `json:"status,omitempty"`
	// Sort by customer generated revenue
	Revenue *RevenueSort `json:"revenue,omitempty"`
	// Sort by customer size
	Size *SizeSort `json:"size,omitempty"`
	// Sort by customer tier
	Tier *TierSort `json:"tier,omitempty"`
}

// [ALPHA] A customer status.
type CustomerStatus struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the status.
	Name string `json:"name"`
	// The UI color of the status as a HEX string.
	Color string `json:"color"`
	// The type of the customer status.
	Type CustomerStatusType `json:"type"`
	// Description of the status.
	Description *string `json:"description,omitempty"`
	// The position of the status in the workspace's customers flow.
	Position float64 `json:"position"`
}

func (CustomerStatus) IsNode() {}

// The unique identifier of the entity.
func (this CustomerStatus) GetID() string { return this.ID }

type CustomerStatusConnection struct {
	Edges    []*CustomerStatusEdge `json:"edges"`
	Nodes    []*CustomerStatus     `json:"nodes"`
	PageInfo *PageInfo             `json:"pageInfo"`
}

type CustomerStatusCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the status.
	Name string `json:"name"`
	// The UI color of the status as a HEX string.
	Color string `json:"color"`
	// Description of the status.
	Description *string `json:"description,omitempty"`
	// The position of the status in the workspace's customer flow.
	Position *float64 `json:"position,omitempty"`
	// The type of the customer status.
	Type CustomerStatusType `json:"type"`
}

type CustomerStatusEdge struct {
	Node *CustomerStatus `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Customer status filtering options.
type CustomerStatusFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer status name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the customer status description.
	Description *StringComparator `json:"description,omitempty"`
	// Comparator for the customer status position.
	Position *NumberComparator `json:"position,omitempty"`
	// Comparator for the customer status type.
	Type *StringComparator `json:"type,omitempty"`
	// Comparator for the customer status color.
	Color *StringComparator `json:"color,omitempty"`
	// Compound filters, all of which need to be matched by the customer status.
	And []*CustomerStatusFilter `json:"and,omitempty"`
	// Compound filters, one of which needs to be matched by the customer status.
	Or []*CustomerStatusFilter `json:"or,omitempty"`
}

type CustomerStatusPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The customer status that was created or updated.
	Status *CustomerStatus `json:"status"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Customer status sorting options.
type CustomerStatusSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type CustomerStatusUpdateInput struct {
	// The name of the status.
	Name *string `json:"name,omitempty"`
	// The UI color of the status as a HEX string.
	Color *string `json:"color,omitempty"`
	// Description of the status.
	Description *string `json:"description,omitempty"`
	// The position of the status in the workspace's customer flow.
	Position *float64 `json:"position,omitempty"`
	// The type of the customer status.
	Type *CustomerStatusType `json:"type,omitempty"`
}

// [ALPHA] A customer tier.
type CustomerTier struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the tier.
	Name string `json:"name"`
	// The UI color of the tier as a HEX string.
	Color string `json:"color"`
	// Description of the tier.
	Description *string `json:"description,omitempty"`
	// The position of the tier in the workspace's customers flow.
	Position float64 `json:"position"`
}

func (CustomerTier) IsNode() {}

// The unique identifier of the entity.
func (this CustomerTier) GetID() string { return this.ID }

type CustomerTierConnection struct {
	Edges    []*CustomerTierEdge `json:"edges"`
	Nodes    []*CustomerTier     `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

type CustomerTierCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the tier.
	Name string `json:"name"`
	// The UI color of the tier as a HEX string.
	Color string `json:"color"`
	// Description of the tier.
	Description *string `json:"description,omitempty"`
	// The position of the tier in the workspace's customer flow.
	Position *float64 `json:"position,omitempty"`
}

type CustomerTierEdge struct {
	Node *CustomerTier `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Customer tier filtering options.
type CustomerTierFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the customer tier name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the customer tier description.
	Description *StringComparator `json:"description,omitempty"`
	// Comparator for the customer tier position.
	Position *NumberComparator `json:"position,omitempty"`
	// Comparator for the customer tier color.
	Color *StringComparator `json:"color,omitempty"`
	// Compound filters, all of which need to be matched by the customer tier.
	And []*CustomerTierFilter `json:"and,omitempty"`
	// Compound filters, one of which needs to be matched by the customer tier.
	Or []*CustomerTierFilter `json:"or,omitempty"`
}

type CustomerTierPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The customer tier that was created or updated.
	Tier *CustomerTier `json:"tier"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type CustomerTierUpdateInput struct {
	// The name of the tier.
	Name *string `json:"name,omitempty"`
	// The UI color of the tier as a HEX string.
	Color *string `json:"color,omitempty"`
	// Description of the tier.
	Description *string `json:"description,omitempty"`
	// The position of the tier in the workspace's customer flow.
	Position *float64 `json:"position,omitempty"`
}

type CustomerUpdateInput struct {
	// The name of the customer.
	Name *string `json:"name,omitempty"`
	// The domains associated with this customer.
	Domains []string `json:"domains,omitempty"`
	// The ids of the customers in external systems.
	ExternalIds []string `json:"externalIds,omitempty"`
	// The ID of the Slack channel used to interact with the customer.
	SlackChannelID *string `json:"slackChannelId,omitempty"`
	// The user who owns the customer.
	OwnerID *string `json:"ownerId,omitempty"`
	// The status of the customer.
	StatusID *string `json:"statusId,omitempty"`
	// The revenue generated by the customer.
	Revenue *int64 `json:"revenue,omitempty"`
	// The size of the customer.
	Size *int64 `json:"size,omitempty"`
	// The tier of the customer customer.
	TierID *string `json:"tierId,omitempty"`
}

// A set of issues to be resolved in a specified amount of time.
type Cycle struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The number of the cycle.
	Number float64 `json:"number"`
	// The custom name of the cycle.
	Name *string `json:"name,omitempty"`
	// The cycle's description.
	Description *string `json:"description,omitempty"`
	// The start time of the cycle.
	StartsAt string `json:"startsAt"`
	// The end time of the cycle.
	EndsAt string `json:"endsAt"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The time at which the cycle was automatically archived by the auto pruning process.
	AutoArchivedAt *string `json:"autoArchivedAt,omitempty"`
	// The total number of issues in the cycle after each day.
	IssueCountHistory []float64 `json:"issueCountHistory"`
	// The number of completed issues in the cycle after each day.
	CompletedIssueCountHistory []float64 `json:"completedIssueCountHistory"`
	// The total number of estimation points after each day.
	ScopeHistory []float64 `json:"scopeHistory"`
	// The number of completed estimation points after each day.
	CompletedScopeHistory []float64 `json:"completedScopeHistory"`
	// The number of in progress estimation points after each day.
	InProgressScopeHistory []float64 `json:"inProgressScopeHistory"`
	// The team that the cycle is associated with.
	Team *Team `json:"team"`
	// [Internal] The progress history of the cycle.
	ProgressHistory string `json:"progressHistory"`
	// [Internal] The current progress of the cycle.
	CurrentProgress string `json:"currentProgress"`
	// Issues associated with the cycle.
	Issues *IssueConnection `json:"issues"`
	// Issues that weren't completed when the cycle was closed.
	UncompletedIssuesUponClose *IssueConnection `json:"uncompletedIssuesUponClose"`
	// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress float64 `json:"progress"`
}

func (Cycle) IsNode() {}

// The unique identifier of the entity.
func (this Cycle) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type CycleArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Cycle `json:"entity,omitempty"`
}

func (CycleArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this CycleArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this CycleArchivePayload) GetSuccess() bool { return this.Success }

type CycleConnection struct {
	Edges    []*CycleEdge `json:"edges"`
	Nodes    []*Cycle     `json:"nodes"`
	PageInfo *PageInfo    `json:"pageInfo"`
}

type CycleCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The custom name of the cycle.
	Name *string `json:"name,omitempty"`
	// The description of the cycle.
	Description *string `json:"description,omitempty"`
	// The team to associate the cycle with.
	TeamID string `json:"teamId"`
	// The start date of the cycle.
	StartsAt string `json:"startsAt"`
	// The end date of the cycle.
	EndsAt string `json:"endsAt"`
	// The completion time of the cycle. If null, the cycle hasn't been completed.
	CompletedAt *string `json:"completedAt,omitempty"`
}

type CycleEdge struct {
	Node *Cycle `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Cycle filtering options.
type CycleFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the cycle number.
	Number *NumberComparator `json:"number,omitempty"`
	// Comparator for the cycle name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the cycle start date.
	StartsAt *DateComparator `json:"startsAt,omitempty"`
	// Comparator for the cycle ends at date.
	EndsAt *DateComparator `json:"endsAt,omitempty"`
	// Comparator for the cycle completed at date.
	CompletedAt *DateComparator `json:"completedAt,omitempty"`
	// Comparator for the filtering active cycle.
	IsActive *BooleanComparator `json:"isActive,omitempty"`
	// Comparator for filtering for whether the cycle is currently in cooldown.
	IsInCooldown *BooleanComparator `json:"isInCooldown,omitempty"`
	// Comparator for the filtering next cycle.
	IsNext *BooleanComparator `json:"isNext,omitempty"`
	// Comparator for the filtering previous cycle.
	IsPrevious *BooleanComparator `json:"isPrevious,omitempty"`
	// Comparator for the filtering future cycles.
	IsFuture *BooleanComparator `json:"isFuture,omitempty"`
	// Comparator for the filtering past cycles.
	IsPast *BooleanComparator `json:"isPast,omitempty"`
	// Filters that the cycles team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the cycles issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Compound filters, all of which need to be matched by the cycle.
	And []*CycleFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the cycle.
	Or []*CycleFilter `json:"or,omitempty"`
}

// A cycle notification subscription.
type CycleNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The cycle subscribed to.
	Cycle *Cycle `json:"cycle"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (CycleNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this CycleNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this CycleNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this CycleNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this CycleNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (CycleNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (CycleNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this CycleNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this CycleNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this CycleNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this CycleNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this CycleNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this CycleNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this CycleNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this CycleNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this CycleNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this CycleNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this CycleNotificationSubscription) GetActive() bool { return this.Active }

type CyclePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The Cycle that was created or updated.
	Cycle *Cycle `json:"cycle,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Input for shifting all cycles from a certain cycle onwards by a certain number of days
type CycleShiftAllInput struct {
	// The cycle ID at which to start the shift.
	ID string `json:"id"`
	// The number of days to shift the cycles by.
	DaysToShift float64 `json:"daysToShift"`
}

// Issue cycle sorting options.
type CycleSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
	// When set to true, cycles wil be ordered with a custom order. Current cycle comes first, followed by upcoming cycles in ASC order, followed by previous cycles in DESC order.
	CurrentCycleFirst *bool `json:"currentCycleFirst,omitempty"`
}

type CycleUpdateInput struct {
	// The custom name of the cycle.
	Name *string `json:"name,omitempty"`
	// The description of the cycle.
	Description *string `json:"description,omitempty"`
	// The start date of the cycle.
	StartsAt *string `json:"startsAt,omitempty"`
	// The end date of the cycle.
	EndsAt *string `json:"endsAt,omitempty"`
	// The end date of the cycle.
	CompletedAt *string `json:"completedAt,omitempty"`
}

// Comparator for dates.
type DateComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *string `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *string `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *string `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *string `json:"gte,omitempty"`
}

type DeleteOrganizationInput struct {
	// The deletion code to confirm operation.
	DeletionCode string `json:"deletionCode"`
}

// A generic payload return from entity deletion mutations.
type DeletePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The identifier of the deleted entity.
	EntityID string `json:"entityId"`
}

func (DeletePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this DeletePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this DeletePayload) GetSuccess() bool { return this.Success }

// A diary entry
type DiaryEntry struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// [Internal] The entry content as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The user who the diary belongs to.
	User *User `json:"user"`
	// The date for which the entry is created
	Date string `json:"date"`
	// The canonical url for the DiaryEntry.
	URL string `json:"url"`
}

func (DiaryEntry) IsNode() {}

// The unique identifier of the entity.
func (this DiaryEntry) GetID() string { return this.ID }

type DiaryEntryConnection struct {
	Edges    []*DiaryEntryEdge `json:"edges"`
	Nodes    []*DiaryEntry     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type DiaryEntryCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The date for which the entry is created.
	Date string `json:"date"`
	// [Internal] The comment content as a Prosemirror diaryEntry.
	BodyData *string `json:"bodyData,omitempty"`
}

type DiaryEntryEdge struct {
	Node *DiaryEntry `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type DiaryEntryPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The diary entry that was created or updated.
	DiaryEntry *DiaryEntry `json:"diaryEntry"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type DiaryEntryUpdateInput struct {
	// [Internal] The comment content as a Prosemirror diaryEntry.
	BodyData *string `json:"bodyData,omitempty"`
	// The date for which the entry is created.
	Date *string `json:"date,omitempty"`
}

// A document that can be attached to different entities.
type Document struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The document title.
	Title string `json:"title"`
	// The icon of the document.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon.
	Color *string `json:"color,omitempty"`
	// The user who created the document.
	Creator *User `json:"creator"`
	// The user who last updated the document.
	UpdatedBy *User `json:"updatedBy"`
	// The project that the document is associated with.
	Project *Project `json:"project,omitempty"`
	// [Internal] The initiative that the document is associated with.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The document's unique URL slug.
	SlugID string `json:"slugId"`
	// The last template that was applied to this document.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// The time at which the document was hidden. Null if the entity has not been hidden.
	HiddenAt *string `json:"hiddenAt,omitempty"`
	// A flag that indicates whether the document is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The order of the item in the resources list.
	SortOrder float64 `json:"sortOrder"`
	// Comments associated with the document.
	Comments *CommentConnection `json:"comments"`
	// The documents content in markdown format.
	Content *string `json:"content,omitempty"`
	// [Internal] The documents content as YJS state.
	ContentState *string `json:"contentState,omitempty"`
	// The ID of the document content associated with the document.
	DocumentContentID *string `json:"documentContentId,omitempty"`
	// The canonical url for the document.
	URL string `json:"url"`
	// [Internal] The documents content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
}

func (Document) IsNode() {}

// The unique identifier of the entity.
func (this Document) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type DocumentArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Document `json:"entity,omitempty"`
}

func (DocumentArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this DocumentArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this DocumentArchivePayload) GetSuccess() bool { return this.Success }

// Document filtering options.
type DocumentCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the document title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the document slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Filters that the document's creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the document's project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the document's initiative must satisfy.
	Initiative *InitiativeFilter `json:"initiative,omitempty"`
	// Compound filters, all of which need to be matched by the document.
	And []*DocumentCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the document.
	Or []*DocumentCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some documents.
	Some *DocumentFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all documents.
	Every *DocumentFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type DocumentConnection struct {
	Edges    []*DocumentEdge `json:"edges"`
	Nodes    []*Document     `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

// A document content for a project.
type DocumentContent struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The document content in markdown format.
	Content *string `json:"content,omitempty"`
	// [Internal] The document content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// The document content state as a base64 encoded string.
	ContentState *string `json:"contentState,omitempty"`
	// The issue that the content is associated with.
	Issue *Issue `json:"issue,omitempty"`
	// The project that the content is associated with.
	Project *Project `json:"project,omitempty"`
	// The initiative that the content is associated with.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The project milestone that the content is associated with.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone,omitempty"`
	// The document that the content is associated with.
	Document *Document `json:"document,omitempty"`
	// The time at which the document content was restored from a previous version.
	RestoredAt *string `json:"restoredAt,omitempty"`
}

func (DocumentContent) IsNode() {}

// The unique identifier of the entity.
func (this DocumentContent) GetID() string { return this.ID }

// Document content filtering options.
type DocumentContentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Filters that the document content project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the document content document must satisfy.
	Document *DocumentFilter `json:"document,omitempty"`
}

// A document content history for a document.
type DocumentContentHistory struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The document content that this history item is associated with.
	DocumentContent *DocumentContent `json:"documentContent"`
	// [Internal] The document content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// IDs of actors whose edits went into this history item.
	ActorIds []string `json:"actorIds"`
	// The timestamp associated with the DocumentContent when it was originally saved.
	ContentDataSnapshotAt string `json:"contentDataSnapshotAt"`
}

func (DocumentContentHistory) IsNode() {}

// The unique identifier of the entity.
func (this DocumentContentHistory) GetID() string { return this.ID }

type DocumentContentHistoryPayload struct {
	// The document content history entries.
	History []*DocumentContentHistoryType `json:"history"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type DocumentContentHistoryType struct {
	// The UUID of the document content history entry.
	ID string `json:"id"`
	// The date when the document content history entry was created.
	CreatedAt string `json:"createdAt"`
	// The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same.
	ContentDataSnapshotAt string `json:"contentDataSnapshotAt"`
	// [Internal] The document content as Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// The ID of the author of the change.
	ActorIds []string `json:"actorIds,omitempty"`
}

type DocumentCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The title of the document.
	Title string `json:"title"`
	// The icon of the document.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon.
	Color *string `json:"color,omitempty"`
	// [Internal] The document content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// The document content as markdown.
	Content *string `json:"content,omitempty"`
	// Related project for the document.
	ProjectID *string `json:"projectId,omitempty"`
	// [Internal] Related initiative for the document.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The ID of the last template applied to the document.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The order of the item in the resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// [INTERNAL] The identifiers of the users subscribing to this document.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
}

type DocumentEdge struct {
	Node *Document `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Document filtering options.
type DocumentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the document title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the document slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Filters that the document's creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the document's project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the document's initiative must satisfy.
	Initiative *InitiativeFilter `json:"initiative,omitempty"`
	// Compound filters, all of which need to be matched by the document.
	And []*DocumentFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the document.
	Or []*DocumentFilter `json:"or,omitempty"`
}

// A document related notification.
type DocumentNotification struct {
	// Related comment ID. Null if the notification is not related to a comment.
	CommentID *string `json:"commentId,omitempty"`
	// Related parent comment ID. Null if the notification is not related to a comment.
	ParentCommentID *string `json:"parentCommentId,omitempty"`
	// Name of the reaction emoji related to the notification.
	ReactionEmoji *string `json:"reactionEmoji,omitempty"`
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Notification type.
	Type string `json:"type"`
	// The user that caused the notification.
	Actor *User `json:"actor,omitempty"`
	// The external user that caused the notification.
	ExternalUserActor *ExternalUser `json:"externalUserActor,omitempty"`
	// The user that received the notification.
	User *User `json:"user"`
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	ReadAt *string `json:"readAt,omitempty"`
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	EmailedAt *string `json:"emailedAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The time at which a notification was unsnoozed..
	UnsnoozedAt *string `json:"unsnoozedAt,omitempty"`
	// [Internal] URL to the target of the notification.
	URL string `json:"url"`
	// [Internal] Inbox URL for the notification.
	InboxURL string `json:"inboxUrl"`
	// [Internal] Notification title.
	Title string `json:"title"`
	// [Internal] Notification subtitle.
	Subtitle string `json:"subtitle"`
	// [Internal] If notification actor was Linear.
	IsLinearActor bool `json:"isLinearActor"`
	// [Internal] Notification avatar URL.
	ActorAvatarURL *string `json:"actorAvatarUrl,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorInitials *string `json:"actorInitials,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorAvatarColor *string `json:"actorAvatarColor,omitempty"`
	// [Internal] Issue's status type for issue notifications.
	IssueStatusType *string `json:"issueStatusType,omitempty"`
	// [Internal] Project update health for new updates.
	ProjectUpdateHealth *string `json:"projectUpdateHealth,omitempty"`
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GroupingKey string `json:"groupingKey"`
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GroupingPriority float64 `json:"groupingPriority"`
	// The bot that caused the notification.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Related document ID.
	DocumentID string `json:"documentId"`
}

func (DocumentNotification) IsEntity() {}

// The unique identifier of the entity.
func (this DocumentNotification) GetID() string { return this.ID }

// The time at which the entity was created.
func (this DocumentNotification) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this DocumentNotification) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this DocumentNotification) GetArchivedAt() *string { return this.ArchivedAt }

func (DocumentNotification) IsNode() {}

// The unique identifier of the entity.

func (DocumentNotification) IsNotification() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// Notification type.
func (this DocumentNotification) GetType() string { return this.Type }

// The user that caused the notification.
func (this DocumentNotification) GetActor() *User { return this.Actor }

// The external user that caused the notification.
func (this DocumentNotification) GetExternalUserActor() *ExternalUser { return this.ExternalUserActor }

// The user that received the notification.
func (this DocumentNotification) GetUser() *User { return this.User }

// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
func (this DocumentNotification) GetReadAt() *string { return this.ReadAt }

// The time at when an email reminder for this notification was sent to the user. Null, if no email
//
//	reminder has been sent.
func (this DocumentNotification) GetEmailedAt() *string { return this.EmailedAt }

// The time until a notification will be snoozed. After that it will appear in the inbox again.
func (this DocumentNotification) GetSnoozedUntilAt() *string { return this.SnoozedUntilAt }

// The time at which a notification was unsnoozed..
func (this DocumentNotification) GetUnsnoozedAt() *string { return this.UnsnoozedAt }

// [Internal] URL to the target of the notification.
func (this DocumentNotification) GetURL() string { return this.URL }

// [Internal] Inbox URL for the notification.
func (this DocumentNotification) GetInboxURL() string { return this.InboxURL }

// [Internal] Notification title.
func (this DocumentNotification) GetTitle() string { return this.Title }

// [Internal] Notification subtitle.
func (this DocumentNotification) GetSubtitle() string { return this.Subtitle }

// [Internal] If notification actor was Linear.
func (this DocumentNotification) GetIsLinearActor() bool { return this.IsLinearActor }

// [Internal] Notification avatar URL.
func (this DocumentNotification) GetActorAvatarURL() *string { return this.ActorAvatarURL }

// [Internal] Notification actor initials if avatar is not available.
func (this DocumentNotification) GetActorInitials() *string { return this.ActorInitials }

// [Internal] Notification actor initials if avatar is not available.
func (this DocumentNotification) GetActorAvatarColor() *string { return this.ActorAvatarColor }

// [Internal] Issue's status type for issue notifications.
func (this DocumentNotification) GetIssueStatusType() *string { return this.IssueStatusType }

// [Internal] Project update health for new updates.
func (this DocumentNotification) GetProjectUpdateHealth() *string { return this.ProjectUpdateHealth }

// [Internal] Notifications with the same grouping key will be grouped together in the UI.
func (this DocumentNotification) GetGroupingKey() string { return this.GroupingKey }

// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
func (this DocumentNotification) GetGroupingPriority() float64 { return this.GroupingPriority }

// The bot that caused the notification.
func (this DocumentNotification) GetBotActor() *ActorBot { return this.BotActor }

type DocumentPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The document that was created or updated.
	Document *Document `json:"document"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type DocumentSearchPayload struct {
	Edges    []*DocumentSearchResultEdge `json:"edges"`
	Nodes    []*DocumentSearchResult     `json:"nodes"`
	PageInfo *PageInfo                   `json:"pageInfo"`
	// Archived entities matching the search term along with all their dependencies.
	ArchivePayload *ArchiveResponse `json:"archivePayload"`
	// Total number of results for query without filters applied.
	TotalCount float64 `json:"totalCount"`
}

type DocumentSearchResult struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The document title.
	Title string `json:"title"`
	// The icon of the document.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon.
	Color *string `json:"color,omitempty"`
	// The user who created the document.
	Creator *User `json:"creator"`
	// The user who last updated the document.
	UpdatedBy *User `json:"updatedBy"`
	// The project that the document is associated with.
	Project *Project `json:"project,omitempty"`
	// [Internal] The initiative that the document is associated with.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The document's unique URL slug.
	SlugID string `json:"slugId"`
	// The last template that was applied to this document.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// The time at which the document was hidden. Null if the entity has not been hidden.
	HiddenAt *string `json:"hiddenAt,omitempty"`
	// A flag that indicates whether the document is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The order of the item in the resources list.
	SortOrder float64 `json:"sortOrder"`
	// Comments associated with the document.
	Comments *CommentConnection `json:"comments"`
	// The documents content in markdown format.
	Content *string `json:"content,omitempty"`
	// [Internal] The documents content as YJS state.
	ContentState *string `json:"contentState,omitempty"`
	// The ID of the document content associated with the document.
	DocumentContentID *string `json:"documentContentId,omitempty"`
	// The canonical url for the document.
	URL string `json:"url"`
	// [Internal] The documents content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// Metadata related to search result.
	Metadata string `json:"metadata"`
}

func (DocumentSearchResult) IsNode() {}

// The unique identifier of the entity.
func (this DocumentSearchResult) GetID() string { return this.ID }

type DocumentSearchResultConnection struct {
	Edges    []*DocumentSearchResultEdge `json:"edges"`
	Nodes    []*DocumentSearchResult     `json:"nodes"`
	PageInfo *PageInfo                   `json:"pageInfo"`
}

type DocumentSearchResultEdge struct {
	Node *DocumentSearchResult `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type DocumentUpdateInput struct {
	// The title of the document.
	Title *string `json:"title,omitempty"`
	// The icon of the document.
	Icon *string `json:"icon,omitempty"`
	// The color of the icon.
	Color *string `json:"color,omitempty"`
	// [Internal] The document content as a Prosemirror document.
	ContentData *string `json:"contentData,omitempty"`
	// The document content as markdown.
	Content *string `json:"content,omitempty"`
	// Related project for the document.
	ProjectID *string `json:"projectId,omitempty"`
	// [Internal] Related initiative for the document.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The ID of the last template applied to the document.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The time at which the document was hidden.
	HiddenAt *string `json:"hiddenAt,omitempty"`
	// The order of the item in the resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// Whether the document has been trashed.
	Trashed *bool `json:"trashed,omitempty"`
	// [INTERNAL] The identifiers of the users subscribing to this document.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
}

// A general purpose draft. Used for comments, project updates, etc.
type Draft struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The text content as a Prosemirror document.
	BodyData string `json:"bodyData"`
	// Additional properties for the draft.
	Data *string `json:"data,omitempty"`
	// Whether the draft was autogenerated for the user.
	IsAutogenerated bool `json:"isAutogenerated"`
	// [INTERNAL] Whether the draft was ported from a local draft.
	WasLocalDraft bool `json:"wasLocalDraft"`
	// The user who created the draft.
	User *User `json:"user"`
	// The issue for which this is a draft comment.
	Issue *Issue `json:"issue,omitempty"`
	// The project for which this is a draft project update.
	Project *Project `json:"project,omitempty"`
	// The project update for which this is a draft comment.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate,omitempty"`
	// The comment for which this is a draft comment reply.
	ParentComment *Comment `json:"parentComment,omitempty"`
}

func (Draft) IsNode() {}

// The unique identifier of the entity.
func (this Draft) GetID() string { return this.ID }

// Issue due date sorting options.
type DueDateSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// An email address that can be used for submitting issues.
type EmailIntakeAddress struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Unique email address user name (before @) used for incoming email.
	Address string `json:"address"`
	// Whether the email address is enabled.
	Enabled bool `json:"enabled"`
	// The template that the email address is associated with.
	Template *Template `json:"template,omitempty"`
	// The team that the email address is associated with.
	Team *Team `json:"team"`
	// The organization that the email address is associated with.
	Organization *Organization `json:"organization"`
	// The user who created the email intake address.
	Creator *User `json:"creator,omitempty"`
}

func (EmailIntakeAddress) IsNode() {}

// The unique identifier of the entity.
func (this EmailIntakeAddress) GetID() string { return this.ID }

type EmailIntakeAddressCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier or key of the team this email address will intake issues for.
	TeamID *string `json:"teamId,omitempty"`
	// The identifier of the template this email address will intake issues for.
	TemplateID *string `json:"templateId,omitempty"`
}

type EmailIntakeAddressPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The email address that was created or updated.
	EmailIntakeAddress *EmailIntakeAddress `json:"emailIntakeAddress"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type EmailIntakeAddressUpdateInput struct {
	// Whether the email address is currently enabled. If set to false, the email address will be disabled and no longer accept incoming emails.
	Enabled bool `json:"enabled"`
}

type EmailUnsubscribeInput struct {
	// Email type to unsubscribed from.
	Type string `json:"type"`
	// The user's email validation token.
	Token string `json:"token"`
	// The identifier of the user.
	UserID string `json:"userId"`
}

type EmailUnsubscribePayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type EmailUserAccountAuthChallengeInput struct {
	// The email for which to generate the magic login code.
	Email string `json:"email"`
	// Whether the login was requested from the desktop app.
	IsDesktop *bool `json:"isDesktop,omitempty"`
	// Auth code for the client initiating the sequence.
	ClientAuthCode *string `json:"clientAuthCode,omitempty"`
	// Signup code.
	SignupCode *string `json:"signupCode,omitempty"`
	// The organization invite link to associate with this authentication.
	InviteLink *string `json:"inviteLink,omitempty"`
	// Whether to only return the login code. This is used by mobile apps to skip showing the login link.
	LoginCodeOnly *bool `json:"loginCodeOnly,omitempty"`
}

type EmailUserAccountAuthChallengeResponse struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// Supported challenge for this user account. Can be either verificationCode or password.
	AuthType string `json:"authType"`
}

// A custom emoji.
type Emoji struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The emoji's name.
	Name string `json:"name"`
	// The emoji image URL.
	URL string `json:"url"`
	// The source of the emoji.
	Source string `json:"source"`
	// The user who created the emoji.
	Creator *User `json:"creator"`
	// The organization that the emoji belongs to.
	Organization *Organization `json:"organization"`
}

func (Emoji) IsNode() {}

// The unique identifier of the entity.
func (this Emoji) GetID() string { return this.ID }

type EmojiConnection struct {
	Edges    []*EmojiEdge `json:"edges"`
	Nodes    []*Emoji     `json:"nodes"`
	PageInfo *PageInfo    `json:"pageInfo"`
}

type EmojiCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the custom emoji.
	Name string `json:"name"`
	// The URL for the emoji.
	URL string `json:"url"`
}

type EmojiEdge struct {
	Node *Emoji `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type EmojiPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The emoji that was created.
	Emoji *Emoji `json:"emoji"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Contains either the full serialized state of the application or delta packets that the requester can apply to the local data set in order to be up-to-date.
type EntityCountResponse struct {
	// Entity counts keyed by the entity name.
	Counts string `json:"counts"`
}

// An external link for an entity like initiative, etc...
type EntityExternalLink struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The link's URL.
	URL string `json:"url"`
	// The link's label.
	Label string `json:"label"`
	// The order of the item in the resources list.
	SortOrder float64 `json:"sortOrder"`
	// The user who created the link.
	Creator *User `json:"creator"`
	// The initiative that the link is associated with.
	Initiative *Initiative `json:"initiative,omitempty"`
}

func (EntityExternalLink) IsNode() {}

// The unique identifier of the entity.
func (this EntityExternalLink) GetID() string { return this.ID }

type EntityExternalLinkConnection struct {
	Edges    []*EntityExternalLinkEdge `json:"edges"`
	Nodes    []*EntityExternalLink     `json:"nodes"`
	PageInfo *PageInfo                 `json:"pageInfo"`
}

type EntityExternalLinkCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The URL of the link.
	URL string `json:"url"`
	// The label for the link.
	Label string `json:"label"`
	// Related initiative link.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// Related project link.
	ProjectID *string `json:"projectId,omitempty"`
	// The order of the item in the entities resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type EntityExternalLinkEdge struct {
	Node *EntityExternalLink `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type EntityExternalLinkPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The link that was created or updated.
	EntityExternalLink *EntityExternalLink `json:"entityExternalLink"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type EntityExternalLinkUpdateInput struct {
	// The URL of the link.
	URL *string `json:"url,omitempty"`
	// The label for the link.
	Label *string `json:"label,omitempty"`
	// The order of the item in the entities resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

// Comparator for estimates.
type EstimateComparator struct {
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// In-array constraint.
	In []float64 `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []float64 `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
	// Compound filters, all of which need to be matched by the estimate.
	Or []*NullableNumberComparator `json:"or,omitempty"`
	// Compound filters, one of which need to be matched by the estimate.
	And []*NullableNumberComparator `json:"and,omitempty"`
}

// Issue estimate sorting options.
type EstimateSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them.
type ExternalUser struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The external user's full name.
	Name string `json:"name"`
	// The external user's display name. Unique within each organization. Can match the display name of an actual user.
	DisplayName string `json:"displayName"`
	// The external user's email address.
	Email *string `json:"email,omitempty"`
	// An URL to the external user's avatar image.
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Organization the external user belongs to.
	Organization *Organization `json:"organization"`
	// The last time the external user was seen interacting with Linear.
	LastSeen *string `json:"lastSeen,omitempty"`
}

func (ExternalUser) IsNode() {}

// The unique identifier of the entity.
func (this ExternalUser) GetID() string { return this.ID }

type ExternalUserConnection struct {
	Edges    []*ExternalUserEdge `json:"edges"`
	Nodes    []*ExternalUser     `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

type ExternalUserEdge struct {
	Node *ExternalUser `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a project to a roadmap for example.
type Facet struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The sort order of the facet.
	SortOrder float64 `json:"sortOrder"`
	// The owning organization.
	SourceOrganization *Organization `json:"sourceOrganization,omitempty"`
	// The owning team.
	SourceTeam *Team `json:"sourceTeam,omitempty"`
	// The owning project.
	SourceProject *Project `json:"sourceProject,omitempty"`
	// The owning initiative.
	SourceInitiative *Initiative `json:"sourceInitiative,omitempty"`
	// The owning page.
	SourcePage *FacetPageSource `json:"sourcePage,omitempty"`
	// The targeted custom view.
	TargetCustomView *CustomView `json:"targetCustomView,omitempty"`
}

func (Facet) IsNode() {}

// The unique identifier of the entity.
func (this Facet) GetID() string { return this.ID }

type FacetConnection struct {
	Edges    []*FacetEdge `json:"edges"`
	Nodes    []*Facet     `json:"nodes"`
	PageInfo *PageInfo    `json:"pageInfo"`
}

type FacetEdge struct {
	Node *Facet `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// User favorites presented in the sidebar.
type Favorite struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The type of the favorite.
	Type string `json:"type"`
	// The parent folder of the favorite.
	Parent *Favorite `json:"parent,omitempty"`
	// The name of the folder. Only applies to favorites of type folder.
	FolderName *string `json:"folderName,omitempty"`
	// The targeted tab of the project.
	ProjectTab *ProjectTab `json:"projectTab,omitempty"`
	// The type of favorited predefined view.
	PredefinedViewType *string `json:"predefinedViewType,omitempty"`
	// The targeted tab of the initiative.
	InitiativeTab *InitiativeTab `json:"initiativeTab,omitempty"`
	// The owner of the favorite.
	Owner *User `json:"owner"`
	// The order of the item in the favorites list.
	SortOrder float64 `json:"sortOrder"`
	// Children of the favorite. Only applies to favorites of type folder.
	Children *FavoriteConnection `json:"children"`
	// The favorited issue.
	Issue *Issue `json:"issue,omitempty"`
	// The favorited project.
	Project *Project `json:"project,omitempty"`
	// [INTERNAL] The favorited facet.
	Facet *Facet `json:"facet,omitempty"`
	// [DEPRECATED] The favorited team of the project.
	ProjectTeam *Team `json:"projectTeam,omitempty"`
	// The favorited cycle.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The favorited custom view.
	CustomView *CustomView `json:"customView,omitempty"`
	// The team of the favorited predefined view.
	PredefinedViewTeam *Team `json:"predefinedViewTeam,omitempty"`
	// The favorited document.
	Document *Document `json:"document,omitempty"`
	// The favorited roadmap.
	Roadmap *Roadmap `json:"roadmap,omitempty"`
	// The favorited initiative.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The favorited label.
	Label *IssueLabel `json:"label,omitempty"`
	// The favorited user.
	User *User `json:"user,omitempty"`
	// URL of the favorited entity. Folders return 'null' value.
	URL *string `json:"url,omitempty"`
	// [Internal] Favorite's title text (name of the favorite'd object or folder).
	Title string `json:"title"`
	// [Internal] Detail text for favorite's `title` (e.g. team's name for a project).
	Detail *string `json:"detail,omitempty"`
	// [Internal] Returns the color of the favorite's icon. Unavailable for avatars and views with fixed icons (e.g. cycle).
	Color *string `json:"color,omitempty"`
	// [Internal] Name of the favorite's icon. Unavailable for standard views, issues, and avatars
	Icon *string `json:"icon,omitempty"`
}

func (Favorite) IsNode() {}

// The unique identifier of the entity.
func (this Favorite) GetID() string { return this.ID }

type FavoriteConnection struct {
	Edges    []*FavoriteEdge `json:"edges"`
	Nodes    []*Favorite     `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type FavoriteCreateInput struct {
	// The identifier. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the favorite folder.
	FolderName *string `json:"folderName,omitempty"`
	// The parent folder of the favorite.
	ParentID *string `json:"parentId,omitempty"`
	// The identifier of the issue to favorite.
	IssueID *string `json:"issueId,omitempty"`
	// The identifier of the facet to favorite.
	FacetID *string `json:"facetId,omitempty"`
	// The identifier of the project to favorite.
	ProjectID *string `json:"projectId,omitempty"`
	// The tab of the project to favorite.
	ProjectTab *ProjectTab `json:"projectTab,omitempty"`
	// The type of the predefined view to favorite.
	PredefinedViewType *string `json:"predefinedViewType,omitempty"`
	// The identifier of team for the predefined view to favorite.
	PredefinedViewTeamID *string `json:"predefinedViewTeamId,omitempty"`
	// The identifier of the cycle to favorite.
	CycleID *string `json:"cycleId,omitempty"`
	// The identifier of the custom view to favorite.
	CustomViewID *string `json:"customViewId,omitempty"`
	// The identifier of the document to favorite.
	DocumentID *string `json:"documentId,omitempty"`
	// The identifier of the roadmap to favorite.
	RoadmapID *string `json:"roadmapId,omitempty"`
	// [INTERNAL] The identifier of the initiative to favorite.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The tab of the initiative to favorite.
	InitiativeTab *InitiativeTab `json:"initiativeTab,omitempty"`
	// The identifier of the label to favorite.
	LabelID *string `json:"labelId,omitempty"`
	// The identifier of the user to favorite.
	UserID *string `json:"userId,omitempty"`
	// The position of the item in the favorites list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type FavoriteEdge struct {
	Node *Favorite `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type FavoritePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The object that was added as a favorite.
	Favorite *Favorite `json:"favorite"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type FavoriteUpdateInput struct {
	// The position of the item in the favorites list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// The identifier (in UUID v4 format) of the folder to move the favorite under.
	ParentID *string `json:"parentId,omitempty"`
	// The name of the favorite folder.
	FolderName *string `json:"folderName,omitempty"`
}

// A feature flag for a project.
type FeatureFlag struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The unique key as defined by the feature flag provider.
	Key string `json:"key"`
	// Url to the feature flag provider's page about the feature flag.
	ExternalURL string `json:"externalUrl"`
	// The description of the feature flag.
	Description *string `json:"description,omitempty"`
	// Whether the feature flag is enabled.
	IsEnabled bool `json:"isEnabled"`
	// The status of the feature flag.
	Status string `json:"status"`
	// Date when the stage was last changed.
	LastStageUpdatedAt *string `json:"lastStageUpdatedAt,omitempty"`
	// The organization of the feature flag.
	Organization *Organization `json:"organization"`
	// The project the feature flag is associated with.
	Project *Project `json:"project,omitempty"`
	// The integration providing the feature flag.
	Integration *Integration `json:"integration"`
	// The rollout stage of the feature flag.
	RolloutStage *FeatureFlagRolloutStage `json:"rolloutStage"`
	// The pending rollout stage for the feature flag.
	PendingRolloutStage *FeatureFlagRolloutStage `json:"pendingRolloutStage,omitempty"`
	// The user who last changed the stage of the feature flag.
	LastStageUpdatedBy *User `json:"lastStageUpdatedBy,omitempty"`
	// The user who created the feature flag.
	Creator *User `json:"creator,omitempty"`
}

func (FeatureFlag) IsNode() {}

// The unique identifier of the entity.
func (this FeatureFlag) GetID() string { return this.ID }

type FeatureFlagConnection struct {
	Edges    []*FeatureFlagEdge `json:"edges"`
	Nodes    []*FeatureFlag     `json:"nodes"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type FeatureFlagEdge struct {
	Node *FeatureFlag `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// A rollout stage for a feature flag.
type FeatureFlagRolloutStage struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the rollout stage.
	Name string `json:"name"`
	// The description of the rollout stage.
	Description *string `json:"description,omitempty"`
	// Which feature flag provider segments this rollout stage is associated with.
	SegmentKeys []string `json:"segmentKeys"`
	// The type of the feature flag rollout stage.
	Type FeatureFlagRolloutStageType `json:"type"`
	// The order of the rollout stages within an organization.
	SortOrder float64 `json:"sortOrder"`
	// The organization of the feature flag rollout stage.
	Organization *Organization `json:"organization"`
	// The integration providing the feature flag.
	Integration *Integration `json:"integration"`
}

func (FeatureFlagRolloutStage) IsNode() {}

// The unique identifier of the entity.
func (this FeatureFlagRolloutStage) GetID() string { return this.ID }

type FeatureFlagRolloutStageConnection struct {
	Edges    []*FeatureFlagRolloutStageEdge `json:"edges"`
	Nodes    []*FeatureFlagRolloutStage     `json:"nodes"`
	PageInfo *PageInfo                      `json:"pageInfo"`
}

type FeatureFlagRolloutStageEdge struct {
	Node *FeatureFlagRolloutStage `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type FrontAttachmentPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Front specific settings.
type FrontSettings struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
}

type FrontSettingsInput struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
}

// A trigger that updates the issue status according to Git automations.
type GitAutomationState struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The associated workflow state.
	State *WorkflowState `json:"state,omitempty"`
	// The team to which this automation state belongs.
	Team *Team `json:"team"`
	// The target branch associated to this automation state.
	TargetBranch *GitAutomationTargetBranch `json:"targetBranch,omitempty"`
	// The event that triggers the automation.
	Event GitAutomationStates `json:"event"`
	// [DEPRECATED] The target branch, if null, the automation will be triggered on any branch.
	BranchPattern *string `json:"branchPattern,omitempty"`
}

func (GitAutomationState) IsNode() {}

// The unique identifier of the entity.
func (this GitAutomationState) GetID() string { return this.ID }

type GitAutomationStateConnection struct {
	Edges    []*GitAutomationStateEdge `json:"edges"`
	Nodes    []*GitAutomationState     `json:"nodes"`
	PageInfo *PageInfo                 `json:"pageInfo"`
}

type GitAutomationStateCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The team associated with the automation state.
	TeamID string `json:"teamId"`
	// The associated workflow state. If null, will override default behaviour and take no action.
	StateID *string `json:"stateId,omitempty"`
	// [DEPRECATED] The target branch pattern. If null, all branches are targeted.
	BranchPattern *string `json:"branchPattern,omitempty"`
	// The associated target branch. If null, all branches are targeted.
	TargetBranchID *string `json:"targetBranchId,omitempty"`
	// The event that triggers the automation.
	Event GitAutomationStates `json:"event"`
}

type GitAutomationStateEdge struct {
	Node *GitAutomationState `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type GitAutomationStatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The automation state that was created or updated.
	GitAutomationState *GitAutomationState `json:"gitAutomationState"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type GitAutomationStateUpdateInput struct {
	// The associated workflow state.
	StateID *string `json:"stateId,omitempty"`
	// [DEPRECATED] The target branch pattern. If null, all branches are targeted.
	BranchPattern *string `json:"branchPattern,omitempty"`
	// The associated target branch. If null, all branches are targeted.
	TargetBranchID *string `json:"targetBranchId,omitempty"`
	// The event that triggers the automation.
	Event *GitAutomationStates `json:"event,omitempty"`
}

// A Git target branch for which there are automations (GitAutomationState).
type GitAutomationTargetBranch struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The team to which this Git target branch automation belongs.
	Team *Team `json:"team"`
	// The target branch pattern.
	BranchPattern string `json:"branchPattern"`
	// Whether the branch pattern is a regular expression.
	IsRegex bool `json:"isRegex"`
	// Automation states associated with the target branch.
	AutomationStates *GitAutomationStateConnection `json:"automationStates"`
}

func (GitAutomationTargetBranch) IsNode() {}

// The unique identifier of the entity.
func (this GitAutomationTargetBranch) GetID() string { return this.ID }

type GitAutomationTargetBranchCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The team associated with the Git target branch automation.
	TeamID string `json:"teamId"`
	// The target branch pattern.
	BranchPattern string `json:"branchPattern"`
	// Whether the branch pattern is a regular expression.
	IsRegex *bool `json:"isRegex,omitempty"`
}

type GitAutomationTargetBranchPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The Git target branch automation that was created or updated.
	TargetBranch *GitAutomationTargetBranch `json:"targetBranch"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type GitAutomationTargetBranchUpdateInput struct {
	// The target branch pattern.
	BranchPattern *string `json:"branchPattern,omitempty"`
	// Whether the branch pattern is a regular expression.
	IsRegex *bool `json:"isRegex,omitempty"`
}

type GitHubCommitIntegrationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The webhook secret to provide to GitHub.
	WebhookSecret string `json:"webhookSecret"`
}

type GitHubEnterpriseServerInstallVerificationPayload struct {
	// Has the install been successful.
	Success bool `json:"success"`
}

type GitHubEnterpriseServerPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The setup address.
	SetupURL string `json:"setupUrl"`
	// The app install address.
	InstallURL string `json:"installUrl"`
	// The webhook secret to provide to GitHub.
	WebhookSecret string `json:"webhookSecret"`
}

// Metadata and settings for a GitHub import integration.
type GitHubImportSettings struct {
	// The GitHub organization's name.
	OrgLogin string `json:"orgLogin"`
	// The avatar URL for the GitHub organization.
	OrgAvatarURL string `json:"orgAvatarUrl"`
	// The names of the repositories connected for the GitHub integration.
	Repositories []*GitHubRepo `json:"repositories"`
	// A map storing all available issue labels per repository
	Labels *string `json:"labels,omitempty"`
	// The type of Github org
	OrgType GithubOrgType `json:"orgType"`
}

type GitHubImportSettingsInput struct {
	// The GitHub organization's name.
	OrgLogin string `json:"orgLogin"`
	// The avatar URL for the GitHub organization.
	OrgAvatarURL string `json:"orgAvatarUrl"`
	// The names of the repositories connected for the GitHub integration.
	Repositories []*GitHubRepoInput `json:"repositories"`
	// A map storing all available issue labels per repository
	Labels *string `json:"labels,omitempty"`
	// The type of Github org
	OrgType GithubOrgType `json:"orgType"`
}

// Metadata and settings for a GitHub Personal integration.
type GitHubPersonalSettings struct {
	// The GitHub user's name.
	Login string `json:"login"`
}

type GitHubPersonalSettingsInput struct {
	// The GitHub user's name.
	Login string `json:"login"`
}

// GitHub repos available to sync.
type GitHubRepo struct {
	// The full name of the repository.
	FullName string `json:"fullName"`
	// The GitHub repo id.
	ID float64 `json:"id"`
}

type GitHubRepoInput struct {
	// The full name of the repository.
	FullName string `json:"fullName"`
	// The GitHub repo id.
	ID float64 `json:"id"`
}

// Mapping of Linear teams to GitHub repos.
type GitHubRepoMapping struct {
	// The Linear team id to map to the given project.
	LinearTeamID string `json:"linearTeamId"`
	// The GitHub repo id.
	GitHubRepoID float64 `json:"gitHubRepoId"`
	// Labels to filter incoming GitHub issue creation by.
	GitHubLabels []string `json:"gitHubLabels,omitempty"`
	// Whether the sync for this mapping is bidirectional.
	Bidirectional *bool `json:"bidirectional,omitempty"`
	// Whether this mapping is the default one for issue creation.
	Default *bool `json:"default,omitempty"`
}

type GitHubRepoMappingInput struct {
	// The Linear team id to map to the given project.
	LinearTeamID string `json:"linearTeamId"`
	// The GitHub repo id.
	GitHubRepoID float64 `json:"gitHubRepoId"`
	// Labels to filter incoming GitHub issue creation by.
	GitHubLabels []string `json:"gitHubLabels,omitempty"`
	// Whether the sync for this mapping is bidirectional.
	Bidirectional *bool `json:"bidirectional,omitempty"`
	// Whether this mapping is the default one for issue creation.
	Default *bool `json:"default,omitempty"`
}

// Metadata and settings for a GitHub integration.
type GitHubSettings struct {
	// The avatar URL for the GitHub organization.
	OrgAvatarURL *string `json:"orgAvatarUrl,omitempty"`
	// The GitHub organization's name.
	OrgLogin string `json:"orgLogin"`
	// The names of the repositories connected for the GitHub integration.
	Repositories []*GitHubRepo `json:"repositories,omitempty"`
	// Mapping of team to repository for syncing.
	RepositoriesMapping []*GitHubRepoMapping `json:"repositoriesMapping,omitempty"`
	// The type of Github org
	OrgType *GithubOrgType `json:"orgType,omitempty"`
}

type GitHubSettingsInput struct {
	// The avatar URL for the GitHub organization.
	OrgAvatarURL *string `json:"orgAvatarUrl,omitempty"`
	// The GitHub organization's name.
	OrgLogin string `json:"orgLogin"`
	// The names of the repositories connected for the GitHub integration.
	Repositories []*GitHubRepoInput `json:"repositories,omitempty"`
	// Mapping of team to repository for syncing.
	RepositoriesMapping []*GitHubRepoMappingInput `json:"repositoriesMapping,omitempty"`
	// The type of Github org
	OrgType *GithubOrgType `json:"orgType,omitempty"`
}

type GitLabIntegrationCreatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The webhook secret to provide to GitLab.
	WebhookSecret string `json:"webhookSecret"`
}

// Metadata and settings for a GitLab integration.
type GitLabSettings struct {
	// The self-hosted URL of the GitLab instance.
	URL *string `json:"url,omitempty"`
	// Whether the token is limited to a read-only scope.
	Readonly *bool `json:"readonly,omitempty"`
	// The ISO timestamp the GitLab access token expires.
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

type GitLabSettingsInput struct {
	// The self-hosted URL of the GitLab instance.
	URL *string `json:"url,omitempty"`
	// Whether the token is limited to a read-only scope.
	Readonly *bool `json:"readonly,omitempty"`
	// The ISO timestamp the GitLab access token expires.
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

// Google Sheets specific settings.
type GoogleSheetsSettings struct {
	SpreadsheetID   string  `json:"spreadsheetId"`
	SpreadsheetURL  string  `json:"spreadsheetUrl"`
	SheetID         float64 `json:"sheetId"`
	UpdatedIssuesAt *string `json:"updatedIssuesAt,omitempty"`
}

type GoogleSheetsSettingsInput struct {
	SpreadsheetID   string  `json:"spreadsheetId"`
	SpreadsheetURL  string  `json:"spreadsheetUrl"`
	SheetID         float64 `json:"sheetId"`
	UpdatedIssuesAt *string `json:"updatedIssuesAt,omitempty"`
}

type GoogleUserAccountAuthInput struct {
	// Code returned from Google's OAuth flow.
	Code string `json:"code"`
	// The URI to redirect the user to.
	RedirectURI *string `json:"redirectUri,omitempty"`
	// The timezone of the user's browser.
	Timezone string `json:"timezone"`
	// The identifiers of the teams to auto-join.
	TeamIdsToJoin []string `json:"teamIdsToJoin,omitempty"`
	// Signup code.
	SignupCode *string `json:"signupCode,omitempty"`
	// An optional invite link for an organization used to populate available organizations.
	InviteLink *string `json:"inviteLink,omitempty"`
	// An optional parameter to disable new user signup and force login. Default: false.
	DisallowSignup *bool `json:"disallowSignup,omitempty"`
}

// Comparator for identifiers.
type IDComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
}

type ImageUploadFromURLPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The URL containing the image.
	URL *string `json:"url,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// An initiative to group projects.
type Initiative struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the initiative.
	Name string `json:"name"`
	// The description of the initiative.
	Description *string `json:"description,omitempty"`
	// The organization of the initiative.
	Organization *Organization `json:"organization"`
	// The user who created the initiative.
	Creator *User `json:"creator,omitempty"`
	// The user who owns the initiative.
	Owner *User `json:"owner,omitempty"`
	// The initiative's unique URL slug.
	SlugID string `json:"slugId"`
	// The sort order of the initiative within the organization.
	SortOrder float64 `json:"sortOrder"`
	// The initiative's color.
	Color *string `json:"color,omitempty"`
	// The icon of the initiative.
	Icon *string `json:"icon,omitempty"`
	// A flag that indicates whether the initiative is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The estimated completion date of the initiative.
	TargetDate *string `json:"targetDate,omitempty"`
	// The resolution of the initiative's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// The status of the initiative. One of Planned, Active, Completed
	Status InitiativeStatus `json:"status"`
	// Projects associated with the initiative.
	Projects *ProjectConnection `json:"projects"`
	// Links associated with the initiative.
	Links *EntityExternalLinkConnection `json:"links"`
}

func (Initiative) IsNode() {}

// The unique identifier of the entity.
func (this Initiative) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type InitiativeArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Initiative `json:"entity,omitempty"`
}

func (InitiativeArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this InitiativeArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this InitiativeArchivePayload) GetSuccess() bool { return this.Success }

// Initiative collection filtering options.
type InitiativeCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the initiative name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the initiative slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Comparator for the initiative status.
	Status *StringComparator `json:"status,omitempty"`
	// Filters that the initiative creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Compound filters, all of which need to be matched by the initiative.
	And []*InitiativeCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the initiative.
	Or []*InitiativeCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some initiatives.
	Some *InitiativeFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all initiatives.
	Every *InitiativeFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type InitiativeConnection struct {
	Edges    []*InitiativeEdge `json:"edges"`
	Nodes    []*Initiative     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

// The properties of the initiative to create.
type InitiativeCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the initiative.
	Name string `json:"name"`
	// The description of the initiative.
	Description *string `json:"description,omitempty"`
	// The owner of the initiative.
	OwnerID *string `json:"ownerId,omitempty"`
	// The sort order of the initiative within the organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// The initiative's color.
	Color *string `json:"color,omitempty"`
	// The initiative's icon.
	Icon *string `json:"icon,omitempty"`
	// The initiative's status.
	Status *InitiativeStatus `json:"status,omitempty"`
	// The estimated completion date of the initiative.
	TargetDate *string `json:"targetDate,omitempty"`
	// The resolution of the initiative's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
}

type InitiativeEdge struct {
	Node *Initiative `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Initiative filtering options.
type InitiativeFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the initiative name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the initiative slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Comparator for the initiative status.
	Status *StringComparator `json:"status,omitempty"`
	// Filters that the initiative creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Compound filters, all of which need to be matched by the initiative.
	And []*InitiativeFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the initiative.
	Or []*InitiativeFilter `json:"or,omitempty"`
}

// An initiative related notification.
type InitiativeNotification struct {
	// Related comment ID. Null if the notification is not related to a comment.
	CommentID *string `json:"commentId,omitempty"`
	// Related parent comment ID. Null if the notification is not related to a comment.
	ParentCommentID *string `json:"parentCommentId,omitempty"`
	// Name of the reaction emoji related to the notification.
	ReactionEmoji *string `json:"reactionEmoji,omitempty"`
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Notification type.
	Type string `json:"type"`
	// The user that caused the notification.
	Actor *User `json:"actor,omitempty"`
	// The external user that caused the notification.
	ExternalUserActor *ExternalUser `json:"externalUserActor,omitempty"`
	// The user that received the notification.
	User *User `json:"user"`
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	ReadAt *string `json:"readAt,omitempty"`
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	EmailedAt *string `json:"emailedAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The time at which a notification was unsnoozed..
	UnsnoozedAt *string `json:"unsnoozedAt,omitempty"`
	// [Internal] URL to the target of the notification.
	URL string `json:"url"`
	// [Internal] Inbox URL for the notification.
	InboxURL string `json:"inboxUrl"`
	// [Internal] Notification title.
	Title string `json:"title"`
	// [Internal] Notification subtitle.
	Subtitle string `json:"subtitle"`
	// [Internal] If notification actor was Linear.
	IsLinearActor bool `json:"isLinearActor"`
	// [Internal] Notification avatar URL.
	ActorAvatarURL *string `json:"actorAvatarUrl,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorInitials *string `json:"actorInitials,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorAvatarColor *string `json:"actorAvatarColor,omitempty"`
	// [Internal] Issue's status type for issue notifications.
	IssueStatusType *string `json:"issueStatusType,omitempty"`
	// [Internal] Project update health for new updates.
	ProjectUpdateHealth *string `json:"projectUpdateHealth,omitempty"`
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GroupingKey string `json:"groupingKey"`
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GroupingPriority float64 `json:"groupingPriority"`
	// The bot that caused the notification.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Related initiative ID.
	InitiativeID string `json:"initiativeId"`
}

func (InitiativeNotification) IsEntity() {}

// The unique identifier of the entity.
func (this InitiativeNotification) GetID() string { return this.ID }

// The time at which the entity was created.
func (this InitiativeNotification) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this InitiativeNotification) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this InitiativeNotification) GetArchivedAt() *string { return this.ArchivedAt }

func (InitiativeNotification) IsNode() {}

// The unique identifier of the entity.

func (InitiativeNotification) IsNotification() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// Notification type.
func (this InitiativeNotification) GetType() string { return this.Type }

// The user that caused the notification.
func (this InitiativeNotification) GetActor() *User { return this.Actor }

// The external user that caused the notification.
func (this InitiativeNotification) GetExternalUserActor() *ExternalUser {
	return this.ExternalUserActor
}

// The user that received the notification.
func (this InitiativeNotification) GetUser() *User { return this.User }

// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
func (this InitiativeNotification) GetReadAt() *string { return this.ReadAt }

// The time at when an email reminder for this notification was sent to the user. Null, if no email
//
//	reminder has been sent.
func (this InitiativeNotification) GetEmailedAt() *string { return this.EmailedAt }

// The time until a notification will be snoozed. After that it will appear in the inbox again.
func (this InitiativeNotification) GetSnoozedUntilAt() *string { return this.SnoozedUntilAt }

// The time at which a notification was unsnoozed..
func (this InitiativeNotification) GetUnsnoozedAt() *string { return this.UnsnoozedAt }

// [Internal] URL to the target of the notification.
func (this InitiativeNotification) GetURL() string { return this.URL }

// [Internal] Inbox URL for the notification.
func (this InitiativeNotification) GetInboxURL() string { return this.InboxURL }

// [Internal] Notification title.
func (this InitiativeNotification) GetTitle() string { return this.Title }

// [Internal] Notification subtitle.
func (this InitiativeNotification) GetSubtitle() string { return this.Subtitle }

// [Internal] If notification actor was Linear.
func (this InitiativeNotification) GetIsLinearActor() bool { return this.IsLinearActor }

// [Internal] Notification avatar URL.
func (this InitiativeNotification) GetActorAvatarURL() *string { return this.ActorAvatarURL }

// [Internal] Notification actor initials if avatar is not available.
func (this InitiativeNotification) GetActorInitials() *string { return this.ActorInitials }

// [Internal] Notification actor initials if avatar is not available.
func (this InitiativeNotification) GetActorAvatarColor() *string { return this.ActorAvatarColor }

// [Internal] Issue's status type for issue notifications.
func (this InitiativeNotification) GetIssueStatusType() *string { return this.IssueStatusType }

// [Internal] Project update health for new updates.
func (this InitiativeNotification) GetProjectUpdateHealth() *string { return this.ProjectUpdateHealth }

// [Internal] Notifications with the same grouping key will be grouped together in the UI.
func (this InitiativeNotification) GetGroupingKey() string { return this.GroupingKey }

// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
func (this InitiativeNotification) GetGroupingPriority() float64 { return this.GroupingPriority }

// The bot that caused the notification.
func (this InitiativeNotification) GetBotActor() *ActorBot { return this.BotActor }

// An initiative notification subscription.
type InitiativeNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The initiative subscribed to.
	Initiative *Initiative `json:"initiative"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (InitiativeNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this InitiativeNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this InitiativeNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this InitiativeNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this InitiativeNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (InitiativeNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (InitiativeNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this InitiativeNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this InitiativeNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this InitiativeNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this InitiativeNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this InitiativeNotificationSubscription) GetActive() bool { return this.Active }

// The payload returned by the initiative mutations.
type InitiativePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The initiative that was created or updated.
	Initiative *Initiative `json:"initiative"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Join table between projects and initiatives.
type InitiativeToProject struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The project that the initiative is associated with.
	Project *Project `json:"project"`
	// The initiative that the project is associated with.
	Initiative *Initiative `json:"initiative"`
	// The sort order of the project within the initiative.
	SortOrder string `json:"sortOrder"`
}

func (InitiativeToProject) IsNode() {}

// The unique identifier of the entity.
func (this InitiativeToProject) GetID() string { return this.ID }

type InitiativeToProjectConnection struct {
	Edges    []*InitiativeToProjectEdge `json:"edges"`
	Nodes    []*InitiativeToProject     `json:"nodes"`
	PageInfo *PageInfo                  `json:"pageInfo"`
}

// The properties of the initiativeToProject to create.
type InitiativeToProjectCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the project.
	ProjectID string `json:"projectId"`
	// The identifier of the initiative.
	InitiativeID string `json:"initiativeId"`
	// The sort order for the project within its organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type InitiativeToProjectEdge struct {
	Node *InitiativeToProject `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// The result of a initiativeToProject mutation.
type InitiativeToProjectPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The initiativeToProject that was created or updated.
	InitiativeToProject *InitiativeToProject `json:"initiativeToProject"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// The properties of the initiativeToProject to update.
type InitiativeToProjectUpdateInput struct {
	// The sort order for the project within its organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

// The properties of the initiative to update.
type InitiativeUpdateInput struct {
	// The name of the initiative.
	Name *string `json:"name,omitempty"`
	// The description of the initiative.
	Description *string `json:"description,omitempty"`
	// The owner of the initiative.
	OwnerID *string `json:"ownerId,omitempty"`
	// The sort order of the initiative within the organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// The initiative's color.
	Color *string `json:"color,omitempty"`
	// The initiative's icon.
	Icon *string `json:"icon,omitempty"`
	// The estimated completion date of the initiative.
	TargetDate *string `json:"targetDate,omitempty"`
	// The initiative's status.
	Status *InitiativeStatus `json:"status,omitempty"`
	// The resolution of the initiative's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// Whether the initiative has been trashed.
	Trashed *bool `json:"trashed,omitempty"`
}

// An integration with an external service.
type Integration struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The integration's type.
	Service string `json:"service"`
	// The organization that the integration is associated with.
	Organization *Organization `json:"organization"`
	// The team that the integration is associated with.
	Team *Team `json:"team,omitempty"`
	// The user that added the integration.
	Creator *User `json:"creator"`
}

func (Integration) IsNode() {}

// The unique identifier of the entity.
func (this Integration) GetID() string { return this.ID }

type IntegrationConnection struct {
	Edges    []*IntegrationEdge `json:"edges"`
	Nodes    []*Integration     `json:"nodes"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type IntegrationEdge struct {
	Node *Integration `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type IntegrationHasScopesPayload struct {
	// Whether the integration has the required scopes.
	HasAllScopes bool `json:"hasAllScopes"`
	// The missing scopes.
	MissingScopes []string `json:"missingScopes,omitempty"`
}

type IntegrationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IntegrationRequestInput struct {
	// Email associated with the request.
	Email *string `json:"email,omitempty"`
	// Name of the requested integration.
	Name string `json:"name"`
}

type IntegrationRequestPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// The integration resource's settings.
type IntegrationSettings struct {
	Slack                        *SlackSettings          `json:"slack,omitempty"`
	SlackAsks                    *SlackAsksSettings      `json:"slackAsks,omitempty"`
	SlackPost                    *SlackPostSettings      `json:"slackPost,omitempty"`
	SlackProjectPost             *SlackPostSettings      `json:"slackProjectPost,omitempty"`
	SlackCustomViewNotifications *SlackPostSettings      `json:"slackCustomViewNotifications,omitempty"`
	SlackOrgProjectUpdatesPost   *SlackPostSettings      `json:"slackOrgProjectUpdatesPost,omitempty"`
	GoogleSheets                 *GoogleSheetsSettings   `json:"googleSheets,omitempty"`
	GitHub                       *GitHubSettings         `json:"gitHub,omitempty"`
	GitHubImport                 *GitHubImportSettings   `json:"gitHubImport,omitempty"`
	GitHubPersonal               *GitHubPersonalSettings `json:"gitHubPersonal,omitempty"`
	GitLab                       *GitLabSettings         `json:"gitLab,omitempty"`
	Sentry                       *SentrySettings         `json:"sentry,omitempty"`
	Zendesk                      *ZendeskSettings        `json:"zendesk,omitempty"`
	Intercom                     *IntercomSettings       `json:"intercom,omitempty"`
	Front                        *FrontSettings          `json:"front,omitempty"`
	Jira                         *JiraSettings           `json:"jira,omitempty"`
	Notion                       *NotionSettings         `json:"notion,omitempty"`
	Opsgenie                     *OpsgenieSettings       `json:"opsgenie,omitempty"`
	PagerDuty                    *PagerDutySettings      `json:"pagerDuty,omitempty"`
	LaunchDarkly                 *LaunchDarklySettings   `json:"launchDarkly,omitempty"`
	JiraPersonal                 *JiraPersonalSettings   `json:"jiraPersonal,omitempty"`
}

type IntegrationSettingsInput struct {
	Slack                        *SlackSettingsInput          `json:"slack,omitempty"`
	SlackAsks                    *SlackAsksSettingsInput      `json:"slackAsks,omitempty"`
	SlackPost                    *SlackPostSettingsInput      `json:"slackPost,omitempty"`
	SlackProjectPost             *SlackPostSettingsInput      `json:"slackProjectPost,omitempty"`
	SlackCustomViewNotifications *SlackPostSettingsInput      `json:"slackCustomViewNotifications,omitempty"`
	SlackOrgProjectUpdatesPost   *SlackPostSettingsInput      `json:"slackOrgProjectUpdatesPost,omitempty"`
	GoogleSheets                 *GoogleSheetsSettingsInput   `json:"googleSheets,omitempty"`
	GitHub                       *GitHubSettingsInput         `json:"gitHub,omitempty"`
	GitHubImport                 *GitHubImportSettingsInput   `json:"gitHubImport,omitempty"`
	GitHubPersonal               *GitHubPersonalSettingsInput `json:"gitHubPersonal,omitempty"`
	GitLab                       *GitLabSettingsInput         `json:"gitLab,omitempty"`
	Sentry                       *SentrySettingsInput         `json:"sentry,omitempty"`
	Zendesk                      *ZendeskSettingsInput        `json:"zendesk,omitempty"`
	Intercom                     *IntercomSettingsInput       `json:"intercom,omitempty"`
	Front                        *FrontSettingsInput          `json:"front,omitempty"`
	Jira                         *JiraSettingsInput           `json:"jira,omitempty"`
	Notion                       *NotionSettingsInput         `json:"notion,omitempty"`
	Opsgenie                     *OpsgenieInput               `json:"opsgenie,omitempty"`
	PagerDuty                    *PagerDutyInput              `json:"pagerDuty,omitempty"`
	LaunchDarkly                 *LaunchDarklySettingsInput   `json:"launchDarkly,omitempty"`
	JiraPersonal                 *JiraPersonalSettingsInput   `json:"jiraPersonal,omitempty"`
}

// Join table between templates and integrations.
type IntegrationTemplate struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The template that the integration is associated with.
	Template *Template `json:"template"`
	// The integration that the template is associated with.
	Integration *Integration `json:"integration"`
	// ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID.
	ForeignEntityID *string `json:"foreignEntityId,omitempty"`
}

func (IntegrationTemplate) IsNode() {}

// The unique identifier of the entity.
func (this IntegrationTemplate) GetID() string { return this.ID }

type IntegrationTemplateConnection struct {
	Edges    []*IntegrationTemplateEdge `json:"edges"`
	Nodes    []*IntegrationTemplate     `json:"nodes"`
	PageInfo *PageInfo                  `json:"pageInfo"`
}

type IntegrationTemplateCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the integration.
	IntegrationID string `json:"integrationId"`
	// The identifier of the template.
	TemplateID string `json:"templateId"`
	// The foreign identifier in the other service.
	ForeignEntityID *string `json:"foreignEntityId,omitempty"`
}

type IntegrationTemplateEdge struct {
	Node *IntegrationTemplate `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type IntegrationTemplatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The IntegrationTemplate that was created or updated.
	IntegrationTemplate *IntegrationTemplate `json:"integrationTemplate"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// The configuration of all integrations for a project or a team.
type IntegrationsSettings struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The type of view to which the integration settings context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated,omitempty"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone,omitempty"`
	// Whether to send a Slack message when an issue is added to the custom view.
	SlackIssueAddedToView *bool `json:"slackIssueAddedToView,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll,omitempty"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated,omitempty"`
	// Whether to send a new project update to team Slack channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam,omitempty"`
	// Whether to send a new project update to workspace Slack channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace,omitempty"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage,omitempty"`
	// Whether to send a Slack message when an SLA is at high risk.
	SlackIssueSLAHighRisk *bool `json:"slackIssueSlaHighRisk,omitempty"`
	// Whether to send a Slack message when an SLA is breached.
	SlackIssueSLABreached *bool `json:"slackIssueSlaBreached,omitempty"`
	// Team which those settings apply to.
	Team *Team `json:"team,omitempty"`
	// Project which those settings apply to.
	Project *Project `json:"project,omitempty"`
}

func (IntegrationsSettings) IsNode() {}

// The unique identifier of the entity.
func (this IntegrationsSettings) GetID() string { return this.ID }

type IntegrationsSettingsConnection struct {
	Edges    []*IntegrationsSettingsEdge `json:"edges"`
	Nodes    []*IntegrationsSettings     `json:"nodes"`
	PageInfo *PageInfo                   `json:"pageInfo"`
}

type IntegrationsSettingsCreateInput struct {
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated,omitempty"`
	// Whether to send a Slack message when an issue is added to a view.
	SlackIssueAddedToView *bool `json:"slackIssueAddedToView,omitempty"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll,omitempty"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated,omitempty"`
	// Whether to send a Slack message when a project update is created to team channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam,omitempty"`
	// Whether to send a Slack message when a project update is created to workspace channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace,omitempty"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage,omitempty"`
	// Whether to send a Slack message when an SLA is at high risk.
	SlackIssueSLAHighRisk *bool `json:"slackIssueSlaHighRisk,omitempty"`
	// Whether to receive notification when an SLA has breached on Slack.
	SlackIssueSLABreached *bool `json:"slackIssueSlaBreached,omitempty"`
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the team to create settings for.
	TeamID *string `json:"teamId,omitempty"`
	// The identifier of the project to create settings for.
	ProjectID *string `json:"projectId,omitempty"`
	// The identifier of the custom view to create settings for.
	CustomViewID *string `json:"customViewId,omitempty"`
	// The type of view to which the integration settings context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
}

type IntegrationsSettingsEdge struct {
	Node *IntegrationsSettings `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type IntegrationsSettingsPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The settings that were created or updated.
	IntegrationsSettings *IntegrationsSettings `json:"integrationsSettings"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IntegrationsSettingsUpdateInput struct {
	// Whether to send a Slack message when a new issue is created for the project or the team.
	SlackIssueCreated *bool `json:"slackIssueCreated,omitempty"`
	// Whether to send a Slack message when an issue is added to a view.
	SlackIssueAddedToView *bool `json:"slackIssueAddedToView,omitempty"`
	// Whether to send a Slack message when a comment is created on any of the project or team's issues.
	SlackIssueNewComment *bool `json:"slackIssueNewComment,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
	SlackIssueStatusChangedDone *bool `json:"slackIssueStatusChangedDone,omitempty"`
	// Whether to send a Slack message when any of the project or team's issues has a change in status.
	SlackIssueStatusChangedAll *bool `json:"slackIssueStatusChangedAll,omitempty"`
	// Whether to send a Slack message when a project update is created.
	SlackProjectUpdateCreated *bool `json:"slackProjectUpdateCreated,omitempty"`
	// Whether to send a Slack message when a project update is created to team channels.
	SlackProjectUpdateCreatedToTeam *bool `json:"slackProjectUpdateCreatedToTeam,omitempty"`
	// Whether to send a Slack message when a project update is created to workspace channel.
	SlackProjectUpdateCreatedToWorkspace *bool `json:"slackProjectUpdateCreatedToWorkspace,omitempty"`
	// Whether to send a Slack message when a new issue is added to triage.
	SlackIssueAddedToTriage *bool `json:"slackIssueAddedToTriage,omitempty"`
	// Whether to send a Slack message when an SLA is at high risk.
	SlackIssueSLAHighRisk *bool `json:"slackIssueSlaHighRisk,omitempty"`
	// Whether to receive notification when an SLA has breached on Slack.
	SlackIssueSLABreached *bool `json:"slackIssueSlaBreached,omitempty"`
}

// Intercom specific settings.
type IntercomSettings struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
}

type IntercomSettingsInput struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
}

// An issue.
type Issue struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The issue's unique number.
	Number float64 `json:"number"`
	// The issue's title.
	Title string `json:"title"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate,omitempty"`
	// The order of the item in its column on the board.
	BoardOrder float64 `json:"boardOrder"`
	// The order of the item in relation to other items in the organization.
	SortOrder float64 `json:"sortOrder"`
	// [ALPHA] The order of the item in relation to other items in the organization, when ordered by priority.
	PrioritySortOrder float64 `json:"prioritySortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *string `json:"startedAt,omitempty"`
	// The time at which the issue was moved into completed state.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The time at which the issue entered triage.
	StartedTriageAt *string `json:"startedTriageAt,omitempty"`
	// The time at which the issue left triage.
	TriagedAt *string `json:"triagedAt,omitempty"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *string `json:"autoClosedAt,omitempty"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *string `json:"autoArchivedAt,omitempty"`
	// The date at which the issue is due.
	DueDate *string `json:"dueDate,omitempty"`
	// The time at which the issue's SLA began.
	SLAStartedAt *string `json:"slaStartedAt,omitempty"`
	// The time at which the issue's SLA will breach.
	SLABreachesAt *string `json:"slaBreachesAt,omitempty"`
	// The time at which the issue was added to a project.
	AddedToProjectAt *string `json:"addedToProjectAt,omitempty"`
	// The time at which the issue was added to a cycle.
	AddedToCycleAt *string `json:"addedToCycleAt,omitempty"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// Id of the labels associated with this issue.
	LabelIds []string `json:"labelIds"`
	// The team that the issue is associated with.
	Team *Team `json:"team"`
	// The cycle that the issue is associated with.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The project that the issue is associated with.
	Project *Project `json:"project,omitempty"`
	// The projectMilestone that the issue is associated with.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone,omitempty"`
	// The last template that was applied to this issue.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []string `json:"previousIdentifiers"`
	// The user who created the issue.
	Creator *User `json:"creator,omitempty"`
	// The external user who created the issue.
	ExternalUserCreator *ExternalUser `json:"externalUserCreator,omitempty"`
	// The user to whom the issue is assigned to.
	Assignee *User `json:"assignee,omitempty"`
	// The user who snoozed the issue.
	SnoozedBy *User `json:"snoozedBy,omitempty"`
	// The workflow state that the issue is associated with.
	State *WorkflowState `json:"state"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// Emoji reaction summary, grouped by emoji type.
	ReactionData string `json:"reactionData"`
	// Label for the priority.
	PriorityLabel string `json:"priorityLabel"`
	// The comment that this issue was created from.
	SourceComment *Comment `json:"sourceComment,omitempty"`
	// Integration type that created this issue, if applicable.
	IntegrationSourceType *IntegrationService `json:"integrationSourceType,omitempty"`
	// The bot that created the issue, if applicable.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// The users favorite associated with this issue.
	Favorite *Favorite `json:"favorite,omitempty"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier string `json:"identifier"`
	// Issue URL.
	URL string `json:"url"`
	// Suggested branch name for the issue.
	BranchName string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount int64 `json:"customerTicketCount"`
	// Users who are subscribed to the issue.
	Subscribers *UserConnection `json:"subscribers"`
	// The parent of the issue.
	Parent *Issue `json:"parent,omitempty"`
	// Children of the issue.
	Children *IssueConnection `json:"children"`
	// Comments associated with the issue.
	Comments *CommentConnection `json:"comments"`
	// History entries associated with the issue.
	History *IssueHistoryConnection `json:"history"`
	// Labels associated with this issue.
	Labels *IssueLabelConnection `json:"labels"`
	// Relations associated with this issue.
	Relations *IssueRelationConnection `json:"relations"`
	// Inverse relations associated with this issue.
	InverseRelations *IssueRelationConnection `json:"inverseRelations"`
	// Attachments associated with the issue.
	Attachments *AttachmentConnection `json:"attachments"`
	// The issue's description in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The issue's description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// [Internal] The issue's description content as YJS state.
	DescriptionState *string `json:"descriptionState,omitempty"`
	// Reactions associated with the issue.
	Reactions []*Reaction `json:"reactions"`
}

func (Issue) IsNode() {}

// The unique identifier of the entity.
func (this Issue) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type IssueArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Issue `json:"entity,omitempty"`
}

func (IssueArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this IssueArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this IssueArchivePayload) GetSuccess() bool { return this.Success }

type IssueBatchPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The issues that were updated.
	Issues []*Issue `json:"issues"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Issue filtering options.
type IssueCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the source must satisfy.
	SourceMetadata *SourceMetadataComparator `json:"sourceMetadata,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for the issues sla status.
	SLAStatus *SLAStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the issue's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the issue.
	And []*IssueCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*IssueCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some issues.
	Some *IssueFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all issues.
	Every *IssueFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type IssueConnection struct {
	Edges    []*IssueEdge `json:"edges"`
	Nodes    []*Issue     `json:"nodes"`
	PageInfo *PageInfo    `json:"pageInfo"`
}

type IssueCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The title of the issue.
	Title *string `json:"title,omitempty"`
	// The issue description in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The issue description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The identifier of the user to assign the issue to.
	AssigneeID *string `json:"assigneeId,omitempty"`
	// The identifier of the parent issue.
	ParentID *string `json:"parentId,omitempty"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *int64 `json:"priority,omitempty"`
	// The estimated complexity of the issue.
	Estimate *int64 `json:"estimate,omitempty"`
	// The identifiers of the users subscribing to this ticket.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
	// The identifiers of the issue labels associated with this ticket.
	LabelIds []string `json:"labelIds,omitempty"`
	// The identifier of the team associated with the issue.
	TeamID string `json:"teamId"`
	// The cycle associated with the issue.
	CycleID *string `json:"cycleId,omitempty"`
	// The project associated with the issue.
	ProjectID *string `json:"projectId,omitempty"`
	// The project milestone associated with the issue.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The ID of the last template applied to the issue.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The team state of the issue.
	StateID *string `json:"stateId,omitempty"`
	// The comment the issue is referencing.
	ReferenceCommentID *string `json:"referenceCommentId,omitempty"`
	// The comment the issue is created from.
	SourceCommentID *string `json:"sourceCommentId,omitempty"`
	// The position of the issue in its column on the board view.
	BoardOrder *float64 `json:"boardOrder,omitempty"`
	// The position of the issue related to other issues.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// [ALPHA] The position of the issue related to other issues, when ordered by priority.
	PrioritySortOrder *float64 `json:"prioritySortOrder,omitempty"`
	// The position of the issue in parent's sub-issue list.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// The date at which the issue is due.
	DueDate *string `json:"dueDate,omitempty"`
	// Create issue as a user with the provided name. This option is only available to OAuth applications creating issues in `actor=application` mode.
	CreateAsUser *string `json:"createAsUser,omitempty"`
	// Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
	DisplayIconURL *string `json:"displayIconUrl,omitempty"`
	// Whether the passed sort order should be preserved.
	PreserveSortOrderOnCreate *bool `json:"preserveSortOrderOnCreate,omitempty"`
	// The date when the issue was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now.
	CreatedAt *string `json:"createdAt,omitempty"`
	// [Internal] The timestamp at which an issue will be considered in breach of SLA.
	SLABreachesAt *string `json:"slaBreachesAt,omitempty"`
	// The identifier of a template the issue should be created from. If other values are provided in the input, they will override template values.
	TemplateID *string `json:"templateId,omitempty"`
	// The date when the issue was completed (e.g. if importing from another system). Must be a date in the past and after createdAt date. Cannot be provided with an incompatible workflow state.
	CompletedAt *string `json:"completedAt,omitempty"`
}

// [Internal] A draft issue.
type IssueDraft struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The draft's title.
	Title string `json:"title"`
	// The draft's description in markdown format.
	Description *string `json:"description,omitempty"`
	// The priority of the draft.
	Priority float64 `json:"priority"`
	// The estimate of the complexity of the draft.
	Estimate *float64 `json:"estimate,omitempty"`
	// The date at which the issue would be due.
	DueDate *string `json:"dueDate,omitempty"`
	// The team associated with the draft.
	TeamID string `json:"teamId"`
	// The cycle associated with the draft.
	CycleID *string `json:"cycleId,omitempty"`
	// The project associated with the draft.
	ProjectID *string `json:"projectId,omitempty"`
	// The project milestone associated with the draft.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The user who created the draft.
	Creator *User `json:"creator"`
	// The user assigned to the draft.
	AssigneeID *string `json:"assigneeId,omitempty"`
	// The workflow state associated with the draft.
	StateID string `json:"stateId"`
	// The parent draft of the draft.
	Parent *IssueDraft `json:"parent,omitempty"`
	// The parent issue of the draft.
	ParentIssue *Issue `json:"parentIssue,omitempty"`
	// The order of items in the sub-draft list. Only set if the draft has `parent` set.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// Label for the priority.
	PriorityLabel string `json:"priorityLabel"`
	// [Internal] The draft's description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// Serialized array of JSONs representing attachments.
	Attachments *string `json:"attachments,omitempty"`
}

func (IssueDraft) IsNode() {}

// The unique identifier of the entity.
func (this IssueDraft) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type IssueDraftArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *IssueDraft `json:"entity,omitempty"`
}

func (IssueDraftArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this IssueDraftArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this IssueDraftArchivePayload) GetSuccess() bool { return this.Success }

type IssueDraftConnection struct {
	Edges    []*IssueDraftEdge `json:"edges"`
	Nodes    []*IssueDraft     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type IssueDraftCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The title of the draft.
	Title string `json:"title"`
	// The draft description in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The draft description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The identifier of the user to assign the draft to.
	AssigneeID *string `json:"assigneeId,omitempty"`
	// The identifier of the parent draft.
	ParentID *string `json:"parentId,omitempty"`
	// The identifier of the parent issue.
	ParentIssueID *string `json:"parentIssueId,omitempty"`
	// The priority of the draft.
	Priority *int64 `json:"priority,omitempty"`
	// The estimated complexity of the draft.
	Estimate *int64 `json:"estimate,omitempty"`
	// The identifiers of the issue labels associated with this draft.
	LabelIds []string `json:"labelIds,omitempty"`
	// The identifier or key of the team associated with the draft.
	TeamID string `json:"teamId"`
	// The cycle associated with the draft.
	CycleID *string `json:"cycleId,omitempty"`
	// The project associated with the draft.
	ProjectID *string `json:"projectId,omitempty"`
	// The project milestone associated with the draft.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The team state of the draft.
	StateID *string `json:"stateId,omitempty"`
	// The position of the draft in parent draft's sub-draft list.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// The date at which the draft is due.
	DueDate *string `json:"dueDate,omitempty"`
	// The attachments associated with this draft.
	Attachments *string `json:"attachments,omitempty"`
}

type IssueDraftEdge struct {
	Node *IssueDraft `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type IssueDraftPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The draft that was created or updated.
	IssueDraft *IssueDraft `json:"issueDraft"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IssueDraftUpdateInput struct {
	// The title of the draft.
	Title *string `json:"title,omitempty"`
	// The draft description in markdown format.
	Description *string `json:"description,omitempty"`
	// The draft description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The identifier of the user to assign the draft to.
	AssigneeID *string `json:"assigneeId,omitempty"`
	// The identifier of the parent draft.
	ParentID *string `json:"parentId,omitempty"`
	// The identifier of the parent issue.
	ParentIssueID *string `json:"parentIssueId,omitempty"`
	// The priority of the draft.
	Priority *int64 `json:"priority,omitempty"`
	// The estimated complexity of the draft.
	Estimate *int64 `json:"estimate,omitempty"`
	// The identifiers of the issue labels associated with this draft.
	LabelIds []string `json:"labelIds,omitempty"`
	// The identifier or key of the team associated with the draft.
	TeamID *string `json:"teamId,omitempty"`
	// The cycle associated with the draft.
	CycleID *string `json:"cycleId,omitempty"`
	// The project associated with the draft.
	ProjectID *string `json:"projectId,omitempty"`
	// The project milestone associated with the draft.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The team state of the draft.
	StateID *string `json:"stateId,omitempty"`
	// The position of the draft in parent draft's sub-draft list.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// The date at which the draft is due.
	DueDate *string `json:"dueDate,omitempty"`
	// The attachments associated with this draft.
	Attachments *string `json:"attachments,omitempty"`
}

type IssueEdge struct {
	Node *Issue `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Issue filtering options.
type IssueFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the source must satisfy.
	SourceMetadata *SourceMetadataComparator `json:"sourceMetadata,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for the issues sla status.
	SLAStatus *SLAStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the issue's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the issue.
	And []*IssueFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*IssueFilter `json:"or,omitempty"`
}

type IssueFilterSuggestionPayload struct {
	// The json filter that is suggested.
	Filter *string `json:"filter,omitempty"`
}

// A record of changes to an issue.
type IssueHistory struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The issue that was changed.
	Issue *Issue `json:"issue"`
	// The id of user who made these changes. If null, possibly means that the change made by an integration.
	ActorID *string `json:"actorId,omitempty"`
	// Whether the issue's description was updated.
	UpdatedDescription *bool `json:"updatedDescription,omitempty"`
	// What the title was changed from.
	FromTitle *string `json:"fromTitle,omitempty"`
	// What the title was changed to.
	ToTitle *string `json:"toTitle,omitempty"`
	// The id of user from whom the issue was re-assigned from.
	FromAssigneeID *string `json:"fromAssigneeId,omitempty"`
	// The id of user to whom the issue was assigned to.
	ToAssigneeID *string `json:"toAssigneeId,omitempty"`
	// What the priority was changed from.
	FromPriority *float64 `json:"fromPriority,omitempty"`
	// What the priority was changed to.
	ToPriority *float64 `json:"toPriority,omitempty"`
	// The id of team from which the issue was moved from.
	FromTeamID *string `json:"fromTeamId,omitempty"`
	// The id of team to which the issue was moved to.
	ToTeamID *string `json:"toTeamId,omitempty"`
	// The id of previous parent of the issue.
	FromParentID *string `json:"fromParentId,omitempty"`
	// The id of new parent of the issue.
	ToParentID *string `json:"toParentId,omitempty"`
	// The id of previous workflow state of the issue.
	FromStateID *string `json:"fromStateId,omitempty"`
	// The id of new workflow state of the issue.
	ToStateID *string `json:"toStateId,omitempty"`
	// The id of previous cycle of the issue.
	FromCycleID *string `json:"fromCycleId,omitempty"`
	// The id of new cycle of the issue.
	ToCycleID *string `json:"toCycleId,omitempty"`
	// The id of new project created from the issue.
	ToConvertedProjectID *string `json:"toConvertedProjectId,omitempty"`
	// The id of previous project of the issue.
	FromProjectID *string `json:"fromProjectId,omitempty"`
	// The id of new project of the issue.
	ToProjectID *string `json:"toProjectId,omitempty"`
	// What the estimate was changed from.
	FromEstimate *float64 `json:"fromEstimate,omitempty"`
	// What the estimate was changed to.
	ToEstimate *float64 `json:"toEstimate,omitempty"`
	// Whether the issue is archived at the time of this history entry.
	Archived *bool `json:"archived,omitempty"`
	// Whether the issue was trashed or un-trashed.
	Trashed *bool `json:"trashed,omitempty"`
	// The id of linked attachment.
	AttachmentID *string `json:"attachmentId,omitempty"`
	// ID's of labels that were added.
	AddedLabelIds []string `json:"addedLabelIds,omitempty"`
	// ID's of labels that were removed.
	RemovedLabelIds []string `json:"removedLabelIds,omitempty"`
	// Changed issue relationships.
	RelationChanges []*IssueRelationHistoryPayload `json:"relationChanges,omitempty"`
	// Whether the issue was auto-closed.
	AutoClosed *bool `json:"autoClosed,omitempty"`
	// Whether the issue was auto-archived.
	AutoArchived *bool `json:"autoArchived,omitempty"`
	// What the due date was changed from.
	FromDueDate *string `json:"fromDueDate,omitempty"`
	// What the due date was changed to.
	ToDueDate *string `json:"toDueDate,omitempty"`
	// [Internal] Serialized JSON representing changes for certain non-relational properties.
	Changes *string `json:"changes,omitempty"`
	// The actor that performed the actions. This field may be empty in the case of integrations or automations.
	Actor *User `json:"actor,omitempty"`
	// The actors that performed the actions. This field may be empty in the case of integrations or automations.
	Actors []*User `json:"actors,omitempty"`
	// The user that was unassigned from the issue.
	FromAssignee *User `json:"fromAssignee,omitempty"`
	// The user that was assigned to the issue.
	ToAssignee *User `json:"toAssignee,omitempty"`
	// The cycle that the issue was moved from.
	FromCycle *Cycle `json:"fromCycle,omitempty"`
	// The cycle that the issue was moved to.
	ToCycle *Cycle `json:"toCycle,omitempty"`
	// The new project created from the issue.
	ToConvertedProject *Project `json:"toConvertedProject,omitempty"`
	// The project that the issue was moved from.
	FromProject *Project `json:"fromProject,omitempty"`
	// The project that the issue was moved to.
	ToProject *Project `json:"toProject,omitempty"`
	// The state that the issue was moved from.
	FromState *WorkflowState `json:"fromState,omitempty"`
	// The state that the issue was moved to.
	ToState *WorkflowState `json:"toState,omitempty"`
	// The team that the issue was moved from.
	FromTeam *Team `json:"fromTeam,omitempty"`
	// The team that the issue was moved to.
	ToTeam *Team `json:"toTeam,omitempty"`
	// The parent issue that the issue was moved from.
	FromParent *Issue `json:"fromParent,omitempty"`
	// The parent issue that the issue was moved to.
	ToParent *Issue `json:"toParent,omitempty"`
	// The linked attachment.
	Attachment *Attachment `json:"attachment,omitempty"`
	// The import record.
	IssueImport *IssueImport `json:"issueImport,omitempty"`
	// The users that were notified of the issue.
	TriageResponsibilityNotifiedUsers []*User `json:"triageResponsibilityNotifiedUsers,omitempty"`
	// The bot that performed the action.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// The labels that were added to the issue.
	AddedLabels []*IssueLabel `json:"addedLabels,omitempty"`
	// The labels that were removed from the issue.
	RemovedLabels []*IssueLabel `json:"removedLabels,omitempty"`
}

func (IssueHistory) IsNode() {}

// The unique identifier of the entity.
func (this IssueHistory) GetID() string { return this.ID }

type IssueHistoryConnection struct {
	Edges    []*IssueHistoryEdge `json:"edges"`
	Nodes    []*IssueHistory     `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

type IssueHistoryEdge struct {
	Node *IssueHistory `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// An import job for data from an external service.
type IssueImport struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// New team's name in cases when teamId not set.
	TeamName *string `json:"teamName,omitempty"`
	// The id for the user that started the job.
	CreatorID string `json:"creatorId"`
	// The service from which data will be imported.
	Service string `json:"service"`
	// The status for the import job.
	Status string `json:"status"`
	// The data mapping configuration for the import job.
	Mapping *string `json:"mapping,omitempty"`
	// User readable error message, if one has occurred during the import.
	Error *string `json:"error,omitempty"`
	// Current step progress in % (0-100).
	Progress *float64 `json:"progress,omitempty"`
	// File URL for the uploaded CSV for the import, if there is one.
	CSVFileURL *string `json:"csvFileUrl,omitempty"`
	// Error code and metadata, if one has occurred during the import.
	ErrorMetadata *string `json:"errorMetadata,omitempty"`
	// Metadata related to import service.
	ServiceMetadata *string `json:"serviceMetadata,omitempty"`
	// The display name of the import service.
	DisplayName string `json:"displayName"`
}

func (IssueImport) IsNode() {}

// The unique identifier of the entity.
func (this IssueImport) GetID() string { return this.ID }

type IssueImportCheckPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IssueImportDeletePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The import job that was deleted.
	IssueImport *IssueImport `json:"issueImport,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Issue import mapping input.
type IssueImportMappingInput struct {
	// The mapping configuration for users.
	Users *string `json:"users,omitempty"`
	// The mapping configuration for workflow states.
	WorkflowStates *string `json:"workflowStates,omitempty"`
	// The mapping configuration for epics.
	Epics *string `json:"epics,omitempty"`
}

type IssueImportPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The import job that was created or updated.
	IssueImport *IssueImport `json:"issueImport,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Whether an issue import can be synced at the end of an import or not
type IssueImportSyncCheckPayload struct {
	// Returns true if the import can be synced, false otherwise
	CanSync bool `json:"canSync"`
	// An error message with a root cause of why the import cannot be synced
	Error *string `json:"error,omitempty"`
}

type IssueImportUpdateInput struct {
	// The mapping configuration for the import.
	Mapping string `json:"mapping"`
}

// Labels that can be associated with issues.
type IssueLabel struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The label's name.
	Name string `json:"name"`
	// The label's description.
	Description *string `json:"description,omitempty"`
	// The label's color as a HEX string.
	Color        string        `json:"color"`
	Organization *Organization `json:"organization"`
	// The team that the label is associated with. If null, the label is associated with the global workspace.
	Team *Team `json:"team,omitempty"`
	// The user who created the label.
	Creator *User `json:"creator,omitempty"`
	// The parent label.
	Parent *IssueLabel `json:"parent,omitempty"`
	// Issues associated with the label.
	Issues *IssueConnection `json:"issues"`
	// Children of the label.
	Children *IssueLabelConnection `json:"children"`
	// Whether this label is considered to be a group.
	IsGroup bool `json:"isGroup"`
}

func (IssueLabel) IsNode() {}

// The unique identifier of the entity.
func (this IssueLabel) GetID() string { return this.ID }

// Issue label filtering options.
type IssueLabelCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the name.
	Name *StringComparator `json:"name,omitempty"`
	// Filters that the issue labels creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issue labels team must satisfy.
	Team *NullableTeamFilter `json:"team,omitempty"`
	// Filters that the issue label's parent label must satisfy.
	Parent *IssueLabelFilter `json:"parent,omitempty"`
	// Compound filters, all of which need to be matched by the label.
	And []*IssueLabelCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the label.
	Or []*IssueLabelCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some issue labels.
	Some *IssueLabelFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all issue labels.
	Every *IssueLabelFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type IssueLabelConnection struct {
	Edges    []*IssueLabelEdge `json:"edges"`
	Nodes    []*IssueLabel     `json:"nodes"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type IssueLabelCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the label.
	Name string `json:"name"`
	// The description of the label.
	Description *string `json:"description,omitempty"`
	// The color of the label.
	Color *string `json:"color,omitempty"`
	// The identifier of the parent label.
	ParentID *string `json:"parentId,omitempty"`
	// The team associated with the label. If not given, the label will be associated with the entire workspace.
	TeamID *string `json:"teamId,omitempty"`
}

type IssueLabelEdge struct {
	Node *IssueLabel `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Issue label filtering options.
type IssueLabelFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the name.
	Name *StringComparator `json:"name,omitempty"`
	// Filters that the issue labels creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issue labels team must satisfy.
	Team *NullableTeamFilter `json:"team,omitempty"`
	// Filters that the issue label's parent label must satisfy.
	Parent *IssueLabelFilter `json:"parent,omitempty"`
	// Compound filters, all of which need to be matched by the label.
	And []*IssueLabelFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the label.
	Or []*IssueLabelFilter `json:"or,omitempty"`
}

type IssueLabelPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The label that was created or updated.
	IssueLabel *IssueLabel `json:"issueLabel"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IssueLabelUpdateInput struct {
	// The name of the label.
	Name *string `json:"name,omitempty"`
	// The description of the label.
	Description *string `json:"description,omitempty"`
	// The identifier of the parent label.
	ParentID *string `json:"parentId,omitempty"`
	// The color of the label.
	Color *string `json:"color,omitempty"`
}

// An issue related notification.
type IssueNotification struct {
	// Related comment ID. Null if the notification is not related to a comment.
	CommentID *string `json:"commentId,omitempty"`
	// Related parent comment ID. Null if the notification is not related to a comment.
	ParentCommentID *string `json:"parentCommentId,omitempty"`
	// Name of the reaction emoji related to the notification.
	ReactionEmoji *string `json:"reactionEmoji,omitempty"`
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Notification type.
	Type string `json:"type"`
	// The user that caused the notification.
	Actor *User `json:"actor,omitempty"`
	// The external user that caused the notification.
	ExternalUserActor *ExternalUser `json:"externalUserActor,omitempty"`
	// The user that received the notification.
	User *User `json:"user"`
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	ReadAt *string `json:"readAt,omitempty"`
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	EmailedAt *string `json:"emailedAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The time at which a notification was unsnoozed..
	UnsnoozedAt *string `json:"unsnoozedAt,omitempty"`
	// [Internal] URL to the target of the notification.
	URL string `json:"url"`
	// [Internal] Inbox URL for the notification.
	InboxURL string `json:"inboxUrl"`
	// [Internal] Notification title.
	Title string `json:"title"`
	// [Internal] Notification subtitle.
	Subtitle string `json:"subtitle"`
	// [Internal] If notification actor was Linear.
	IsLinearActor bool `json:"isLinearActor"`
	// [Internal] Notification avatar URL.
	ActorAvatarURL *string `json:"actorAvatarUrl,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorInitials *string `json:"actorInitials,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorAvatarColor *string `json:"actorAvatarColor,omitempty"`
	// [Internal] Issue's status type for issue notifications.
	IssueStatusType *string `json:"issueStatusType,omitempty"`
	// [Internal] Project update health for new updates.
	ProjectUpdateHealth *string `json:"projectUpdateHealth,omitempty"`
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GroupingKey string `json:"groupingKey"`
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GroupingPriority float64 `json:"groupingPriority"`
	// The bot that caused the notification.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Related issue ID.
	IssueID string `json:"issueId"`
	// The issue related to the notification.
	Issue *Issue `json:"issue"`
	// The comment related to the notification.
	Comment *Comment `json:"comment,omitempty"`
	// The parent comment related to the notification, if a notification is a reply comment notification.
	ParentComment *Comment `json:"parentComment,omitempty"`
	// The team related to the issue notification.
	Team *Team `json:"team"`
	// The subscriptions related to the notification.
	Subscriptions []NotificationSubscription `json:"subscriptions,omitempty"`
}

func (IssueNotification) IsEntity() {}

// The unique identifier of the entity.
func (this IssueNotification) GetID() string { return this.ID }

// The time at which the entity was created.
func (this IssueNotification) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this IssueNotification) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this IssueNotification) GetArchivedAt() *string { return this.ArchivedAt }

func (IssueNotification) IsNode() {}

// The unique identifier of the entity.

func (IssueNotification) IsNotification() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// Notification type.
func (this IssueNotification) GetType() string { return this.Type }

// The user that caused the notification.
func (this IssueNotification) GetActor() *User { return this.Actor }

// The external user that caused the notification.
func (this IssueNotification) GetExternalUserActor() *ExternalUser { return this.ExternalUserActor }

// The user that received the notification.
func (this IssueNotification) GetUser() *User { return this.User }

// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
func (this IssueNotification) GetReadAt() *string { return this.ReadAt }

// The time at when an email reminder for this notification was sent to the user. Null, if no email
//
//	reminder has been sent.
func (this IssueNotification) GetEmailedAt() *string { return this.EmailedAt }

// The time until a notification will be snoozed. After that it will appear in the inbox again.
func (this IssueNotification) GetSnoozedUntilAt() *string { return this.SnoozedUntilAt }

// The time at which a notification was unsnoozed..
func (this IssueNotification) GetUnsnoozedAt() *string { return this.UnsnoozedAt }

// [Internal] URL to the target of the notification.
func (this IssueNotification) GetURL() string { return this.URL }

// [Internal] Inbox URL for the notification.
func (this IssueNotification) GetInboxURL() string { return this.InboxURL }

// [Internal] Notification title.
func (this IssueNotification) GetTitle() string { return this.Title }

// [Internal] Notification subtitle.
func (this IssueNotification) GetSubtitle() string { return this.Subtitle }

// [Internal] If notification actor was Linear.
func (this IssueNotification) GetIsLinearActor() bool { return this.IsLinearActor }

// [Internal] Notification avatar URL.
func (this IssueNotification) GetActorAvatarURL() *string { return this.ActorAvatarURL }

// [Internal] Notification actor initials if avatar is not available.
func (this IssueNotification) GetActorInitials() *string { return this.ActorInitials }

// [Internal] Notification actor initials if avatar is not available.
func (this IssueNotification) GetActorAvatarColor() *string { return this.ActorAvatarColor }

// [Internal] Issue's status type for issue notifications.
func (this IssueNotification) GetIssueStatusType() *string { return this.IssueStatusType }

// [Internal] Project update health for new updates.
func (this IssueNotification) GetProjectUpdateHealth() *string { return this.ProjectUpdateHealth }

// [Internal] Notifications with the same grouping key will be grouped together in the UI.
func (this IssueNotification) GetGroupingKey() string { return this.GroupingKey }

// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
func (this IssueNotification) GetGroupingPriority() float64 { return this.GroupingPriority }

// The bot that caused the notification.
func (this IssueNotification) GetBotActor() *ActorBot { return this.BotActor }

type IssuePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The issue that was created or updated.
	Issue *Issue `json:"issue,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IssuePriorityValue struct {
	// Priority's number value.
	Priority int64 `json:"priority"`
	// Priority's label.
	Label string `json:"label"`
}

// A relation between two issues.
type IssueRelation struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The relationship of the issue with the related issue.
	Type string `json:"type"`
	// The issue whose relationship is being described.
	Issue *Issue `json:"issue"`
	// The related issue.
	RelatedIssue *Issue `json:"relatedIssue"`
}

func (IssueRelation) IsNode() {}

// The unique identifier of the entity.
func (this IssueRelation) GetID() string { return this.ID }

type IssueRelationConnection struct {
	Edges    []*IssueRelationEdge `json:"edges"`
	Nodes    []*IssueRelation     `json:"nodes"`
	PageInfo *PageInfo            `json:"pageInfo"`
}

type IssueRelationCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The type of relation of the issue to the related issue.
	Type IssueRelationType `json:"type"`
	// The identifier of the issue that is related to another issue.
	IssueID string `json:"issueId"`
	// The identifier of the related issue.
	RelatedIssueID string `json:"relatedIssueId"`
}

type IssueRelationEdge struct {
	Node *IssueRelation `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Issue relation history's payload.
type IssueRelationHistoryPayload struct {
	// The identifier of the related issue.
	Identifier string `json:"identifier"`
	// The type of the change.
	Type string `json:"type"`
}

type IssueRelationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The issue relation that was created or updated.
	IssueRelation *IssueRelation `json:"issueRelation"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type IssueRelationUpdateInput struct {
	// The type of relation of the issue to the related issue.
	Type *string `json:"type,omitempty"`
	// The identifier of the issue that is related to another issue.
	IssueID *string `json:"issueId,omitempty"`
	// The identifier of the related issue.
	RelatedIssueID *string `json:"relatedIssueId,omitempty"`
}

type IssueSearchPayload struct {
	Edges    []*IssueSearchResultEdge `json:"edges"`
	Nodes    []*IssueSearchResult     `json:"nodes"`
	PageInfo *PageInfo                `json:"pageInfo"`
	// Archived entities matching the search term along with all their dependencies.
	ArchivePayload *ArchiveResponse `json:"archivePayload"`
	// Total number of results for query without filters applied.
	TotalCount float64 `json:"totalCount"`
}

type IssueSearchResult struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The issue's unique number.
	Number float64 `json:"number"`
	// The issue's title.
	Title string `json:"title"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority float64 `json:"priority"`
	// The estimate of the complexity of the issue..
	Estimate *float64 `json:"estimate,omitempty"`
	// The order of the item in its column on the board.
	BoardOrder float64 `json:"boardOrder"`
	// The order of the item in relation to other items in the organization.
	SortOrder float64 `json:"sortOrder"`
	// [ALPHA] The order of the item in relation to other items in the organization, when ordered by priority.
	PrioritySortOrder float64 `json:"prioritySortOrder"`
	// The time at which the issue was moved into started state.
	StartedAt *string `json:"startedAt,omitempty"`
	// The time at which the issue was moved into completed state.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The time at which the issue entered triage.
	StartedTriageAt *string `json:"startedTriageAt,omitempty"`
	// The time at which the issue left triage.
	TriagedAt *string `json:"triagedAt,omitempty"`
	// The time at which the issue was moved into canceled state.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The time at which the issue was automatically closed by the auto pruning process.
	AutoClosedAt *string `json:"autoClosedAt,omitempty"`
	// The time at which the issue was automatically archived by the auto pruning process.
	AutoArchivedAt *string `json:"autoArchivedAt,omitempty"`
	// The date at which the issue is due.
	DueDate *string `json:"dueDate,omitempty"`
	// The time at which the issue's SLA began.
	SLAStartedAt *string `json:"slaStartedAt,omitempty"`
	// The time at which the issue's SLA will breach.
	SLABreachesAt *string `json:"slaBreachesAt,omitempty"`
	// The time at which the issue was added to a project.
	AddedToProjectAt *string `json:"addedToProjectAt,omitempty"`
	// The time at which the issue was added to a cycle.
	AddedToCycleAt *string `json:"addedToCycleAt,omitempty"`
	// A flag that indicates whether the issue is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// Id of the labels associated with this issue.
	LabelIds []string `json:"labelIds"`
	// The team that the issue is associated with.
	Team *Team `json:"team"`
	// The cycle that the issue is associated with.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The project that the issue is associated with.
	Project *Project `json:"project,omitempty"`
	// The projectMilestone that the issue is associated with.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone,omitempty"`
	// The last template that was applied to this issue.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// Previous identifiers of the issue if it has been moved between teams.
	PreviousIdentifiers []string `json:"previousIdentifiers"`
	// The user who created the issue.
	Creator *User `json:"creator,omitempty"`
	// The external user who created the issue.
	ExternalUserCreator *ExternalUser `json:"externalUserCreator,omitempty"`
	// The user to whom the issue is assigned to.
	Assignee *User `json:"assignee,omitempty"`
	// The user who snoozed the issue.
	SnoozedBy *User `json:"snoozedBy,omitempty"`
	// The workflow state that the issue is associated with.
	State *WorkflowState `json:"state"`
	// The order of the item in the sub-issue list. Only set if the issue has a parent.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// Emoji reaction summary, grouped by emoji type.
	ReactionData string `json:"reactionData"`
	// Label for the priority.
	PriorityLabel string `json:"priorityLabel"`
	// The comment that this issue was created from.
	SourceComment *Comment `json:"sourceComment,omitempty"`
	// Integration type that created this issue, if applicable.
	IntegrationSourceType *IntegrationService `json:"integrationSourceType,omitempty"`
	// The bot that created the issue, if applicable.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// The users favorite associated with this issue.
	Favorite *Favorite `json:"favorite,omitempty"`
	// Issue's human readable identifier (e.g. ENG-123).
	Identifier string `json:"identifier"`
	// Issue URL.
	URL string `json:"url"`
	// Suggested branch name for the issue.
	BranchName string `json:"branchName"`
	// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
	CustomerTicketCount int64 `json:"customerTicketCount"`
	// Users who are subscribed to the issue.
	Subscribers *UserConnection `json:"subscribers"`
	// The parent of the issue.
	Parent *Issue `json:"parent,omitempty"`
	// Children of the issue.
	Children *IssueConnection `json:"children"`
	// Comments associated with the issue.
	Comments *CommentConnection `json:"comments"`
	// History entries associated with the issue.
	History *IssueHistoryConnection `json:"history"`
	// Labels associated with this issue.
	Labels *IssueLabelConnection `json:"labels"`
	// Relations associated with this issue.
	Relations *IssueRelationConnection `json:"relations"`
	// Inverse relations associated with this issue.
	InverseRelations *IssueRelationConnection `json:"inverseRelations"`
	// Attachments associated with the issue.
	Attachments *AttachmentConnection `json:"attachments"`
	// The issue's description in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The issue's description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// [Internal] The issue's description content as YJS state.
	DescriptionState *string `json:"descriptionState,omitempty"`
	// Reactions associated with the issue.
	Reactions []*Reaction `json:"reactions"`
	// Metadata related to search result.
	Metadata string `json:"metadata"`
}

func (IssueSearchResult) IsNode() {}

// The unique identifier of the entity.
func (this IssueSearchResult) GetID() string { return this.ID }

type IssueSearchResultConnection struct {
	Edges    []*IssueSearchResultEdge `json:"edges"`
	Nodes    []*IssueSearchResult     `json:"nodes"`
	PageInfo *PageInfo                `json:"pageInfo"`
}

type IssueSearchResultEdge struct {
	Node *IssueSearchResult `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Issue sorting options.
type IssueSortInput struct {
	// Sort by priority
	Priority *PrioritySort `json:"priority,omitempty"`
	// Sort by estimate
	Estimate *EstimateSort `json:"estimate,omitempty"`
	// Sort by issue title
	Title *TitleSort `json:"title,omitempty"`
	// Sort by label
	Label *LabelSort `json:"label,omitempty"`
	// Sort by SLA status
	SLAStatus *SLAStatusSort `json:"slaStatus,omitempty"`
	// Sort by issue creation date
	CreatedAt *CreatedAtSort `json:"createdAt,omitempty"`
	// Sort by issue update date
	UpdatedAt *UpdatedAtSort `json:"updatedAt,omitempty"`
	// Sort by issue completion date
	CompletedAt *CompletedAtSort `json:"completedAt,omitempty"`
	// Sort by issue due date
	DueDate *DueDateSort `json:"dueDate,omitempty"`
	// Sort by Cycle start date
	Cycle *CycleSort `json:"cycle,omitempty"`
	// Sort by Project Milestone target date
	Milestone *MilestoneSort `json:"milestone,omitempty"`
	// Sort by assignee name
	Assignee *AssigneeSort `json:"assignee,omitempty"`
	// Sort by Project name
	Project *ProjectSort `json:"project,omitempty"`
	// Sort by Team name
	Team *TeamSort `json:"team,omitempty"`
	// Sort by manual order
	Manual *ManualSort `json:"manual,omitempty"`
	// Sort by workflow state type
	WorkflowState *WorkflowStateSort `json:"workflowState,omitempty"`
}

type IssueUpdateInput struct {
	// The issue title.
	Title *string `json:"title,omitempty"`
	// The issue description in markdown format.
	Description *string `json:"description,omitempty"`
	// The issue description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The identifier of the user to assign the issue to.
	AssigneeID *string `json:"assigneeId,omitempty"`
	// The identifier of the parent issue.
	ParentID *string `json:"parentId,omitempty"`
	// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *int64 `json:"priority,omitempty"`
	// The estimated complexity of the issue.
	Estimate *int64 `json:"estimate,omitempty"`
	// The identifiers of the users subscribing to this ticket.
	SubscriberIds []string `json:"subscriberIds,omitempty"`
	// The identifiers of the issue labels associated with this ticket.
	LabelIds []string `json:"labelIds,omitempty"`
	// The identifier of the team associated with the issue.
	TeamID *string `json:"teamId,omitempty"`
	// The cycle associated with the issue.
	CycleID *string `json:"cycleId,omitempty"`
	// The project associated with the issue.
	ProjectID *string `json:"projectId,omitempty"`
	// The project milestone associated with the issue.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The ID of the last template applied to the issue.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The team state of the issue.
	StateID *string `json:"stateId,omitempty"`
	// The position of the issue in its column on the board view.
	BoardOrder *float64 `json:"boardOrder,omitempty"`
	// The position of the issue related to other issues.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// [ALPHA] The position of the issue related to other issues, when ordered by priority.
	PrioritySortOrder *float64 `json:"prioritySortOrder,omitempty"`
	// The position of the issue in parent's sub-issue list.
	SubIssueSortOrder *float64 `json:"subIssueSortOrder,omitempty"`
	// The date at which the issue is due.
	DueDate *string `json:"dueDate,omitempty"`
	// Whether the issue has been trashed.
	Trashed *bool `json:"trashed,omitempty"`
	// [Internal] The timestamp at which an issue will be considered in breach of SLA.
	SLABreachesAt *string `json:"slaBreachesAt,omitempty"`
	// The time until an issue will be snoozed in Triage view.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The identifier of the user who snoozed the issue.
	SnoozedByID *string `json:"snoozedById,omitempty"`
}

type JiraConfigurationInput struct {
	// The Jira personal access token.
	AccessToken string `json:"accessToken"`
	// The Jira user's email address.
	Email string `json:"email"`
	// The Jira installation hostname.
	Hostname string `json:"hostname"`
	// [DEPRECATED] The Jira project keys to scope the integration to.
	Project *string `json:"project,omitempty"`
	// Whether this integration will be setup using the manual webhook flow.
	ManualSetup *bool `json:"manualSetup,omitempty"`
}

// Tuple for mapping Jira projects to Linear teams.
type JiraLinearMapping struct {
	// The Jira id for this project.
	JiraProjectID string `json:"jiraProjectId"`
	// The Linear team id to map to the given project.
	LinearTeamID string `json:"linearTeamId"`
	// Whether the sync for this mapping is bidirectional.
	Bidirectional *bool `json:"bidirectional,omitempty"`
	// Whether this mapping is the default one for issue creation.
	Default *bool `json:"default,omitempty"`
}

type JiraLinearMappingInput struct {
	// The Jira id for this project.
	JiraProjectID string `json:"jiraProjectId"`
	// The Linear team id to map to the given project.
	LinearTeamID string `json:"linearTeamId"`
	// Whether the sync for this mapping is bidirectional.
	Bidirectional *bool `json:"bidirectional,omitempty"`
	// Whether this mapping is the default one for issue creation.
	Default *bool `json:"default,omitempty"`
}

// Jira personal specific settings.
type JiraPersonalSettings struct {
	// The name of the Jira site currently authorized through the integration.
	SiteName *string `json:"siteName,omitempty"`
}

type JiraPersonalSettingsInput struct {
	// The name of the Jira site currently authorized through the integration.
	SiteName *string `json:"siteName,omitempty"`
}

// Metadata about a Jira project.
type JiraProjectData struct {
	// The Jira id for this project.
	ID string `json:"id"`
	// The Jira key for this project, such as ENG.
	Key string `json:"key"`
	// The Jira name for this project, such as Engineering.
	Name string `json:"name"`
}

type JiraProjectDataInput struct {
	// The Jira id for this project.
	ID string `json:"id"`
	// The Jira key for this project, such as ENG.
	Key string `json:"key"`
	// The Jira name for this project, such as Engineering.
	Name string `json:"name"`
}

// Jira specific settings.
type JiraSettings struct {
	// The mapping of Jira project id => Linear team id.
	ProjectMapping []*JiraLinearMapping `json:"projectMapping,omitempty"`
	// The Jira projects for the organization.
	Projects []*JiraProjectData `json:"projects"`
	// Whether this integration is for Jira Server or not.
	IsJiraServer *bool `json:"isJiraServer,omitempty"`
	// Whether the user needs to provide setup information about the webhook to complete the integration setup. Only relevant for integrations that use a manual setup flow
	SetupPending *bool `json:"setupPending,omitempty"`
	// Whether this integration is using a manual setup flow.
	ManualSetup *bool `json:"manualSetup,omitempty"`
}

type JiraSettingsInput struct {
	// The mapping of Jira project id => Linear team id.
	ProjectMapping []*JiraLinearMappingInput `json:"projectMapping,omitempty"`
	// The Jira projects for the organization.
	Projects []*JiraProjectDataInput `json:"projects"`
	// Whether this integration is for Jira Server or not.
	IsJiraServer *bool `json:"isJiraServer,omitempty"`
	// Whether the user needs to provide setup information about the webhook to complete the integration setup. Only relevant for integrations that use a manual setup flow
	SetupPending *bool `json:"setupPending,omitempty"`
	// Whether this integration is using a manual setup flow.
	ManualSetup *bool `json:"manualSetup,omitempty"`
}

type JiraUpdateInput struct {
	// The id of the integration to update.
	ID string `json:"id"`
	// Whether to refresh Jira Projects for the integration.
	UpdateProjects *bool `json:"updateProjects,omitempty"`
	// Whether to refresh Jira metadata for the integration.
	UpdateMetadata *bool `json:"updateMetadata,omitempty"`
	// Whether to delete the current manual webhook configuration.
	DeleteWebhook *bool `json:"deleteWebhook,omitempty"`
	// Webhook secret for a new manual configuration.
	WebhookSecret *string `json:"webhookSecret,omitempty"`
}

type JoinOrganizationInput struct {
	// The identifier of the organization.
	OrganizationID string `json:"organizationId"`
	// An optional invite link for an organization.
	InviteLink *string `json:"inviteLink,omitempty"`
}

// A label notification subscription.
type LabelNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The label subscribed to.
	Label *IssueLabel `json:"label"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (LabelNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this LabelNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this LabelNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this LabelNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this LabelNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (LabelNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (LabelNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this LabelNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this LabelNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this LabelNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this LabelNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this LabelNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this LabelNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this LabelNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this LabelNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this LabelNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this LabelNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this LabelNotificationSubscription) GetActive() bool { return this.Active }

// Issue sorting options.
type LabelSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// LaunchDarkly specific settings.
type LaunchDarklySettings struct {
	// The project key of the LaunchDarkly integration.
	ProjectKey string `json:"projectKey"`
	// The environment of the LaunchDarkly integration.
	Environment string `json:"environment"`
}

type LaunchDarklySettingsInput struct {
	// The project key of the LaunchDarkly integration.
	ProjectKey string `json:"projectKey"`
	// The environment of the LaunchDarkly integration.
	Environment string `json:"environment"`
}

type LogoutResponse struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Issue manual sorting options.
type ManualSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// Issue project milestone options.
type MilestoneSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type Mutation struct {
}

// Customer name sorting options.
type NameSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// A generic payload return from entity archive mutations.
type NotificationArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity Notification `json:"entity,omitempty"`
}

func (NotificationArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this NotificationArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this NotificationArchivePayload) GetSuccess() bool { return this.Success }

type NotificationBatchActionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The notifications that were updated.
	Notifications []Notification `json:"notifications"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type NotificationConnection struct {
	Edges    []*NotificationEdge `json:"edges"`
	Nodes    []Notification      `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

// A user's notification delivery preferences.
type NotificationDeliveryPreferences struct {
	// The delivery preferences for the mobile channel.
	Mobile *NotificationDeliveryPreferencesChannel `json:"mobile,omitempty"`
}

// A user's notification delivery preferences.
type NotificationDeliveryPreferencesChannel struct {
	// Whether notifications are enabled for this channel.
	NotificationsDisabled *bool `json:"notificationsDisabled,omitempty"`
	// The schedule for notifications on this channel.
	Schedule *NotificationDeliveryPreferencesSchedule `json:"schedule,omitempty"`
}

type NotificationDeliveryPreferencesChannelInput struct {
	// Whether notifications are enabled for this channel.
	NotificationsDisabled *bool `json:"notificationsDisabled,omitempty"`
	// The schedule for notifications on this channel.
	Schedule *NotificationDeliveryPreferencesScheduleInput `json:"schedule,omitempty"`
}

// A user's notification delivery schedule for a particular day.
type NotificationDeliveryPreferencesDay struct {
	// The time notifications start.
	Start *string `json:"start,omitempty"`
	// The time notifications end.
	End *string `json:"end,omitempty"`
}

type NotificationDeliveryPreferencesDayInput struct {
	// The time notifications start.
	Start *string `json:"start,omitempty"`
	// The time notifications end.
	End *string `json:"end,omitempty"`
}

type NotificationDeliveryPreferencesInput struct {
	// The delivery preferences for the mobile channel.
	Mobile *NotificationDeliveryPreferencesChannelInput `json:"mobile,omitempty"`
}

// A user's notification delivery schedule for a particular day.
type NotificationDeliveryPreferencesSchedule struct {
	// Whether the schedule is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Delivery preferences for Sunday.
	Sunday *NotificationDeliveryPreferencesDay `json:"sunday"`
	// Delivery preferences for Monday.
	Monday *NotificationDeliveryPreferencesDay `json:"monday"`
	// Delivery preferences for Tuesday.
	Tuesday *NotificationDeliveryPreferencesDay `json:"tuesday"`
	// Delivery preferences for Wednesday.
	Wednesday *NotificationDeliveryPreferencesDay `json:"wednesday"`
	// Delivery preferences for Thursday.
	Thursday *NotificationDeliveryPreferencesDay `json:"thursday"`
	// Delivery preferences for Friday.
	Friday *NotificationDeliveryPreferencesDay `json:"friday"`
	// Delivery preferences for Saturday.
	Saturday *NotificationDeliveryPreferencesDay `json:"saturday"`
}

type NotificationDeliveryPreferencesScheduleInput struct {
	// Whether the schedule is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Delivery preferences for Sunday.
	Sunday *NotificationDeliveryPreferencesDayInput `json:"sunday"`
	// Delivery preferences for Monday.
	Monday *NotificationDeliveryPreferencesDayInput `json:"monday"`
	// Delivery preferences for Tuesday.
	Tuesday *NotificationDeliveryPreferencesDayInput `json:"tuesday"`
	// Delivery preferences for Wednesday.
	Wednesday *NotificationDeliveryPreferencesDayInput `json:"wednesday"`
	// Delivery preferences for Thursday.
	Thursday *NotificationDeliveryPreferencesDayInput `json:"thursday"`
	// Delivery preferences for Friday.
	Friday *NotificationDeliveryPreferencesDayInput `json:"friday"`
	// Delivery preferences for Saturday.
	Saturday *NotificationDeliveryPreferencesDayInput `json:"saturday"`
}

type NotificationEdge struct {
	Node Notification `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Describes the type and id of the entity to target for notifications.
type NotificationEntityInput struct {
	// The id of the issue related to the notification.
	IssueID *string `json:"issueId,omitempty"`
	// [DEPRECATED] The id of the project related to the notification.
	ProjectID *string `json:"projectId,omitempty"`
	// The id of the initiative related to the notification.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The id of the project update related to the notification.
	ProjectUpdateID *string `json:"projectUpdateId,omitempty"`
	// The id of the OAuth client approval related to the notification.
	OauthClientApprovalID *string `json:"oauthClientApprovalId,omitempty"`
	// The id of the notification.
	ID *string `json:"id,omitempty"`
}

// Notification filtering options.
type NotificationFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the notification type.
	Type *StringComparator `json:"type,omitempty"`
	// Comparator for the archived at date.
	ArchivedAt *DateComparator `json:"archivedAt,omitempty"`
	// Compound filters, all of which need to be matched by the notification.
	And []*NotificationFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the notification.
	Or []*NotificationFilter `json:"or,omitempty"`
}

type NotificationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The notification that was created or updated.
	Notification Notification `json:"notification"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type NotificationSubscriptionConnection struct {
	Edges    []*NotificationSubscriptionEdge `json:"edges"`
	Nodes    []NotificationSubscription      `json:"nodes"`
	PageInfo *PageInfo                       `json:"pageInfo"`
}

type NotificationSubscriptionCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the custom view to subscribe to.
	CustomViewID *string `json:"customViewId,omitempty"`
	// The identifier of the cycle to subscribe to.
	CycleID *string `json:"cycleId,omitempty"`
	// The identifier of the label to subscribe to.
	LabelID *string `json:"labelId,omitempty"`
	// The identifier of the project to subscribe to.
	ProjectID *string `json:"projectId,omitempty"`
	// The identifier of the team to subscribe to.
	TeamID *string `json:"teamId,omitempty"`
	// The identifier of the user to subscribe to.
	UserID *string `json:"userId,omitempty"`
	// The identifier of the initiative to subscribe to.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// The types of notifications of the subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes,omitempty"`
	// Whether the subscription is active.
	Active *bool `json:"active,omitempty"`
}

type NotificationSubscriptionEdge struct {
	Node NotificationSubscription `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type NotificationSubscriptionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The notification subscription that was created or updated.
	NotificationSubscription NotificationSubscription `json:"notificationSubscription"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type NotificationSubscriptionUpdateInput struct {
	// The types of notifications of the subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes,omitempty"`
	// Whether the subscription is active.
	Active *bool `json:"active,omitempty"`
}

type NotificationUpdateInput struct {
	// The time when notification was marked as read.
	ReadAt *string `json:"readAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The id of the project update related to the notification.
	ProjectUpdateID *string `json:"projectUpdateId,omitempty"`
}

// Notion specific settings.
type NotionSettings struct {
	// The ID of the Notion workspace being connected.
	WorkspaceID string `json:"workspaceId"`
	// The name of the Notion workspace being connected.
	WorkspaceName string `json:"workspaceName"`
}

type NotionSettingsInput struct {
	// The ID of the Notion workspace being connected.
	WorkspaceID string `json:"workspaceId"`
	// The name of the Notion workspace being connected.
	WorkspaceName string `json:"workspaceName"`
}

// Comment filtering options.
type NullableCommentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the comments body.
	Body *StringComparator `json:"body,omitempty"`
	// Filters that the comments creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
	// Filters that the comments issue must satisfy.
	Issue *NullableIssueFilter `json:"issue,omitempty"`
	// Filters that the comments project update must satisfy.
	ProjectUpdate *ProjectUpdateFilter `json:"projectUpdate,omitempty"`
	// Filters that the comment parent must satisfy.
	Parent *NullableCommentFilter `json:"parent,omitempty"`
	// Filters that the comments document content must satisfy.
	DocumentContent *DocumentContentFilter `json:"documentContent,omitempty"`
	// Filters that the comments reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the comment's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the comment.
	And []*NullableCommentFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the comment.
	Or []*NullableCommentFilter `json:"or,omitempty"`
}

// Cycle filtering options.
type NullableCycleFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the cycle number.
	Number *NumberComparator `json:"number,omitempty"`
	// Comparator for the cycle name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the cycle start date.
	StartsAt *DateComparator `json:"startsAt,omitempty"`
	// Comparator for the cycle ends at date.
	EndsAt *DateComparator `json:"endsAt,omitempty"`
	// Comparator for the cycle completed at date.
	CompletedAt *DateComparator `json:"completedAt,omitempty"`
	// Comparator for the filtering active cycle.
	IsActive *BooleanComparator `json:"isActive,omitempty"`
	// Comparator for filtering for whether the cycle is currently in cooldown.
	IsInCooldown *BooleanComparator `json:"isInCooldown,omitempty"`
	// Comparator for the filtering next cycle.
	IsNext *BooleanComparator `json:"isNext,omitempty"`
	// Comparator for the filtering previous cycle.
	IsPrevious *BooleanComparator `json:"isPrevious,omitempty"`
	// Comparator for the filtering future cycles.
	IsFuture *BooleanComparator `json:"isFuture,omitempty"`
	// Comparator for the filtering past cycles.
	IsPast *BooleanComparator `json:"isPast,omitempty"`
	// Filters that the cycles team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the cycles issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, one of which need to be matched by the cycle.
	And []*NullableCycleFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the cycle.
	Or []*NullableCycleFilter `json:"or,omitempty"`
}

// Comparator for optional dates.
type NullableDateComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *string `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *string `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *string `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *string `json:"gte,omitempty"`
}

// Document content filtering options.
type NullableDocumentContentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Filters that the document content project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the document content document must satisfy.
	Document *DocumentFilter `json:"document,omitempty"`
}

// Document filtering options.
type NullableDocumentFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the document title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the document slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Filters that the document's creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the document's project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the document's initiative must satisfy.
	Initiative *InitiativeFilter `json:"initiative,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the document.
	And []*NullableDocumentFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the document.
	Or []*NullableDocumentFilter `json:"or,omitempty"`
}

// Issue filtering options.
type NullableIssueFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the issues number.
	Number *NumberComparator `json:"number,omitempty"`
	// Comparator for the issues title.
	Title *StringComparator `json:"title,omitempty"`
	// Comparator for the issues description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Comparator for the issues priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// Comparator for the issues estimate.
	Estimate *EstimateComparator `json:"estimate,omitempty"`
	// Comparator for the issues started at date.
	StartedAt *NullableDateComparator `json:"startedAt,omitempty"`
	// Comparator for the issues triaged at date.
	TriagedAt *NullableDateComparator `json:"triagedAt,omitempty"`
	// Comparator for the issues completed at date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the issues canceled at date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the issues auto closed at date.
	AutoClosedAt *NullableDateComparator `json:"autoClosedAt,omitempty"`
	// Comparator for the issues auto archived at date.
	AutoArchivedAt *NullableDateComparator `json:"autoArchivedAt,omitempty"`
	// Comparator for the issues due date.
	DueDate *NullableTimelessDateComparator `json:"dueDate,omitempty"`
	// Comparator for the issues snoozed until date.
	SnoozedUntilAt *NullableDateComparator `json:"snoozedUntilAt,omitempty"`
	// Filters that the issues assignee must satisfy.
	Assignee *NullableUserFilter `json:"assignee,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the source must satisfy.
	SourceMetadata *SourceMetadataComparator `json:"sourceMetadata,omitempty"`
	// Filters that the issues creator must satisfy.
	Creator *NullableUserFilter `json:"creator,omitempty"`
	// Filters that the issue parent must satisfy.
	Parent *NullableIssueFilter `json:"parent,omitempty"`
	// Filters that the issues snoozer must satisfy.
	SnoozedBy *NullableUserFilter `json:"snoozedBy,omitempty"`
	// Filters that issue labels must satisfy.
	Labels *IssueLabelCollectionFilter `json:"labels,omitempty"`
	// Filters that issue subscribers must satisfy.
	Subscribers *UserCollectionFilter `json:"subscribers,omitempty"`
	// Filters that the issues team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the issues project milestone must satisfy.
	ProjectMilestone *NullableProjectMilestoneFilter `json:"projectMilestone,omitempty"`
	// Filters that the issues comments must satisfy.
	Comments *CommentCollectionFilter `json:"comments,omitempty"`
	// Filters that the issues cycle must satisfy.
	Cycle *NullableCycleFilter `json:"cycle,omitempty"`
	// Filters that the issues project must satisfy.
	Project *NullableProjectFilter `json:"project,omitempty"`
	// Filters that the issues state must satisfy.
	State *WorkflowStateFilter `json:"state,omitempty"`
	// Filters that the child issues must satisfy.
	Children *IssueCollectionFilter `json:"children,omitempty"`
	// Filters that the issues attachments must satisfy.
	Attachments *AttachmentCollectionFilter `json:"attachments,omitempty"`
	// [Internal] Comparator for the issues content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for filtering issues with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// Comparator for filtering issues which are duplicates.
	HasDuplicateRelations *RelationExistsComparator `json:"hasDuplicateRelations,omitempty"`
	// Comparator for filtering issues which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering issues which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for the issues sla status.
	SLAStatus *SLAStatusComparator `json:"slaStatus,omitempty"`
	// Filters that the issues reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Filters that the issue's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the issue.
	And []*NullableIssueFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the issue.
	Or []*NullableIssueFilter `json:"or,omitempty"`
}

// Comparator for optional numbers.
type NullableNumberComparator struct {
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// In-array constraint.
	In []float64 `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []float64 `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
}

// Project filtering options.
type NullableProjectFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// [DEPRECATED] Comparator for the project state.
	State *StringComparator `json:"state,omitempty"`
	// Filters that the project's status must satisfy.
	Status *ProjectStatusFilter `json:"status,omitempty"`
	// [ALPHA] Comparator for the projects priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// [Internal] Comparator for the project's content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the project completion date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the project cancelation date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the project start date.
	StartDate *NullableDateComparator `json:"startDate,omitempty"`
	// Comparator for the project target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Comparator for the project health.
	Health *StringComparator `json:"health,omitempty"`
	// Comparator for the project health (with age).
	HealthWithAge *StringComparator `json:"healthWithAge,omitempty"`
	// Comparator for filtering projects with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// [Deprecated] Comparator for filtering projects which this is depended on by.
	HasDependedOnByRelations *RelationExistsComparator `json:"hasDependedOnByRelations,omitempty"`
	// [Deprecated]Comparator for filtering projects which this depends on.
	HasDependsOnRelations *RelationExistsComparator `json:"hasDependsOnRelations,omitempty"`
	// Comparator for filtering projects which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering projects which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering projects with violated dependencies.
	HasViolatedRelations *RelationExistsComparator `json:"hasViolatedRelations,omitempty"`
	// Comparator for the project updates.
	ProjectUpdates *ProjectUpdatesCollectionFilter `json:"projectUpdates,omitempty"`
	// Filters that the projects creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the projects lead must satisfy.
	Lead *NullableUserFilter `json:"lead,omitempty"`
	// Filters that the projects members must satisfy.
	Members *UserCollectionFilter `json:"members,omitempty"`
	// Filters that the projects issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filters that the projects roadmaps must satisfy.
	Roadmaps *RoadmapCollectionFilter `json:"roadmaps,omitempty"`
	// Filters that the projects initiatives must satisfy.
	Initiatives *InitiativeCollectionFilter `json:"initiatives,omitempty"`
	// Filters that the project's milestones must satisfy.
	ProjectMilestones *ProjectMilestoneCollectionFilter `json:"projectMilestones,omitempty"`
	// Filters that the project's completed milestones must satisfy.
	CompletedProjectMilestones *ProjectMilestoneCollectionFilter `json:"completedProjectMilestones,omitempty"`
	// Filters that the project's next milestone must satisfy.
	NextProjectMilestone *ProjectMilestoneFilter `json:"nextProjectMilestone,omitempty"`
	// Filters that the project's team must satisfy.
	AccessibleTeams *TeamCollectionFilter `json:"accessibleTeams,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the project's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the project.
	And []*NullableProjectFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project.
	Or []*NullableProjectFilter `json:"or,omitempty"`
}

// Project milestone filtering options.
type NullableProjectMilestoneFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project milestone name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project milestone target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the project milestone.
	And []*NullableProjectMilestoneFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project milestone.
	Or []*NullableProjectMilestoneFilter `json:"or,omitempty"`
}

// Options for filtering projects by project updates.
type NullableProjectUpdatesFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project update health.
	Health *StringComparator `json:"health,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the project updates.
	And []*NullableProjectUpdatesFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project updates.
	Or []*NullableProjectUpdatesFilter `json:"or,omitempty"`
}

// Reaction filtering options.
type NullableReactionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the reactions emoji.
	Emoji *StringComparator `json:"emoji,omitempty"`
	// Comparator for the reactions custom emoji.
	CustomEmojiID *IDComparator `json:"customEmojiId,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the reaction.
	And []*NullableReactionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the reaction.
	Or []*NullableReactionFilter `json:"or,omitempty"`
}

// Comparator for optional strings.
type NullableStringComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
	// Starts with case insensitive constraint. Matches any values that start with the given string.
	StartsWithIgnoreCase *string `json:"startsWithIgnoreCase,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
}

// Team filtering options.
type NullableTeamFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the team name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the team key.
	Key *StringComparator `json:"key,omitempty"`
	// Comparator for the team description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Filters that the teams issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the team.
	And []*NullableTeamFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the team.
	Or []*NullableTeamFilter `json:"or,omitempty"`
}

// Template filtering options.
type NullableTemplateFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the template's name.
	Name *StringComparator `json:"name,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the template.
	And []*NullableTemplateFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the template.
	Or []*NullableTemplateFilter `json:"or,omitempty"`
}

// Comparator for optional timeless dates.
type NullableTimelessDateComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *string `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *string `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *string `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *string `json:"gte,omitempty"`
}

// User filtering options.
type NullableUserFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Filter based on the existence of the relation.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*NullableUserFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*NullableUserFilter `json:"or,omitempty"`
}

// Comparator for numbers.
type NumberComparator struct {
	// Equals constraint.
	Eq *float64 `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *float64 `json:"neq,omitempty"`
	// In-array constraint.
	In []float64 `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []float64 `json:"nin,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *float64 `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *float64 `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *float64 `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *float64 `json:"gte,omitempty"`
}

// OAuth2 client application
type OauthClient struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// OAuth application's client name.
	Name string `json:"name"`
	// Information about the application.
	Description *string `json:"description,omitempty"`
	// Name of the developer.
	Developer string `json:"developer"`
	// Url of the developer.
	DeveloperURL string `json:"developerUrl"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// OAuth application's client secret.
	ClientSecret string `json:"clientSecret"`
	// List of allowed redirect URIs for the application.
	RedirectUris []string `json:"redirectUris"`
	// Whether the OAuth application can be installed in other organizations.
	PublicEnabled bool `json:"publicEnabled"`
	// The user who created the OAuth application.
	Creator *User `json:"creator"`
	// The organization that the OAuth application is associated with.
	Organization *Organization `json:"organization"`
	// The resource types to request when creating new webhooks.
	WebhookResourceTypes []string `json:"webhookResourceTypes"`
	// Webhook URL.
	WebhookURL *string `json:"webhookUrl,omitempty"`
	// Webhook secret token for verifying the origin on the recipient side.
	WebhookSecret *string `json:"webhookSecret,omitempty"`
}

func (OauthClient) IsNode() {}

// The unique identifier of the entity.
func (this OauthClient) GetID() string { return this.ID }

// Request to install OAuth clients on organizations and the response to the request.
type OauthClientApproval struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The uuid of the OAuth client being requested for installation.
	OauthClientID string `json:"oauthClientId"`
	// The person who requested installing the OAuth client.
	RequesterID string `json:"requesterId"`
	// The person who responded to the request to install the OAuth client.
	ResponderID *string `json:"responderId,omitempty"`
	// The status for the OAuth client approval request.
	Status OAuthClientApprovalStatus `json:"status"`
	// The scopes the app has requested.
	Scopes []string `json:"scopes"`
	// The reason the person wants to install this OAuth client.
	RequestReason *string `json:"requestReason,omitempty"`
	// The reason the request for the OAuth client approval was denied.
	DenyReason *string `json:"denyReason,omitempty"`
}

func (OauthClientApproval) IsNode() {}

// The unique identifier of the entity.
func (this OauthClientApproval) GetID() string { return this.ID }

// An oauth client approval related notification.
type OauthClientApprovalNotification struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Notification type.
	Type string `json:"type"`
	// The user that caused the notification.
	Actor *User `json:"actor,omitempty"`
	// The external user that caused the notification.
	ExternalUserActor *ExternalUser `json:"externalUserActor,omitempty"`
	// The user that received the notification.
	User *User `json:"user"`
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	ReadAt *string `json:"readAt,omitempty"`
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	EmailedAt *string `json:"emailedAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The time at which a notification was unsnoozed..
	UnsnoozedAt *string `json:"unsnoozedAt,omitempty"`
	// [Internal] URL to the target of the notification.
	URL string `json:"url"`
	// [Internal] Inbox URL for the notification.
	InboxURL string `json:"inboxUrl"`
	// [Internal] Notification title.
	Title string `json:"title"`
	// [Internal] Notification subtitle.
	Subtitle string `json:"subtitle"`
	// [Internal] If notification actor was Linear.
	IsLinearActor bool `json:"isLinearActor"`
	// [Internal] Notification avatar URL.
	ActorAvatarURL *string `json:"actorAvatarUrl,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorInitials *string `json:"actorInitials,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorAvatarColor *string `json:"actorAvatarColor,omitempty"`
	// [Internal] Issue's status type for issue notifications.
	IssueStatusType *string `json:"issueStatusType,omitempty"`
	// [Internal] Project update health for new updates.
	ProjectUpdateHealth *string `json:"projectUpdateHealth,omitempty"`
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GroupingKey string `json:"groupingKey"`
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GroupingPriority float64 `json:"groupingPriority"`
	// The bot that caused the notification.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Related OAuth client approval request ID.
	OauthClientApprovalID string `json:"oauthClientApprovalId"`
	// The OAuth client approval request related to the notification.
	OauthClientApproval *OauthClientApproval `json:"oauthClientApproval"`
}

func (OauthClientApprovalNotification) IsEntity() {}

// The unique identifier of the entity.
func (this OauthClientApprovalNotification) GetID() string { return this.ID }

// The time at which the entity was created.
func (this OauthClientApprovalNotification) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this OauthClientApprovalNotification) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this OauthClientApprovalNotification) GetArchivedAt() *string { return this.ArchivedAt }

func (OauthClientApprovalNotification) IsNode() {}

// The unique identifier of the entity.

func (OauthClientApprovalNotification) IsNotification() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// Notification type.
func (this OauthClientApprovalNotification) GetType() string { return this.Type }

// The user that caused the notification.
func (this OauthClientApprovalNotification) GetActor() *User { return this.Actor }

// The external user that caused the notification.
func (this OauthClientApprovalNotification) GetExternalUserActor() *ExternalUser {
	return this.ExternalUserActor
}

// The user that received the notification.
func (this OauthClientApprovalNotification) GetUser() *User { return this.User }

// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
func (this OauthClientApprovalNotification) GetReadAt() *string { return this.ReadAt }

// The time at when an email reminder for this notification was sent to the user. Null, if no email
//
//	reminder has been sent.
func (this OauthClientApprovalNotification) GetEmailedAt() *string { return this.EmailedAt }

// The time until a notification will be snoozed. After that it will appear in the inbox again.
func (this OauthClientApprovalNotification) GetSnoozedUntilAt() *string { return this.SnoozedUntilAt }

// The time at which a notification was unsnoozed..
func (this OauthClientApprovalNotification) GetUnsnoozedAt() *string { return this.UnsnoozedAt }

// [Internal] URL to the target of the notification.
func (this OauthClientApprovalNotification) GetURL() string { return this.URL }

// [Internal] Inbox URL for the notification.
func (this OauthClientApprovalNotification) GetInboxURL() string { return this.InboxURL }

// [Internal] Notification title.
func (this OauthClientApprovalNotification) GetTitle() string { return this.Title }

// [Internal] Notification subtitle.
func (this OauthClientApprovalNotification) GetSubtitle() string { return this.Subtitle }

// [Internal] If notification actor was Linear.
func (this OauthClientApprovalNotification) GetIsLinearActor() bool { return this.IsLinearActor }

// [Internal] Notification avatar URL.
func (this OauthClientApprovalNotification) GetActorAvatarURL() *string { return this.ActorAvatarURL }

// [Internal] Notification actor initials if avatar is not available.
func (this OauthClientApprovalNotification) GetActorInitials() *string { return this.ActorInitials }

// [Internal] Notification actor initials if avatar is not available.
func (this OauthClientApprovalNotification) GetActorAvatarColor() *string {
	return this.ActorAvatarColor
}

// [Internal] Issue's status type for issue notifications.
func (this OauthClientApprovalNotification) GetIssueStatusType() *string { return this.IssueStatusType }

// [Internal] Project update health for new updates.
func (this OauthClientApprovalNotification) GetProjectUpdateHealth() *string {
	return this.ProjectUpdateHealth
}

// [Internal] Notifications with the same grouping key will be grouped together in the UI.
func (this OauthClientApprovalNotification) GetGroupingKey() string { return this.GroupingKey }

// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
func (this OauthClientApprovalNotification) GetGroupingPriority() float64 {
	return this.GroupingPriority
}

// The bot that caused the notification.
func (this OauthClientApprovalNotification) GetBotActor() *ActorBot { return this.BotActor }

type OauthClientConnection struct {
	Edges    []*OauthClientEdge `json:"edges"`
	Nodes    []*OauthClient     `json:"nodes"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type OauthClientEdge struct {
	Node *OauthClient `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type OauthToken struct {
	ID float64 `json:"id"`
	// Scopes associated with the access token.
	Scope     []string `json:"scope"`
	RevokedAt *string  `json:"revokedAt,omitempty"`
	CreatedAt string   `json:"createdAt"`
	// OAuth2 client for which the access token belongs to.
	Client   *AuthOauthClient `json:"client"`
	ClientID string           `json:"clientId"`
	// Auth user who authorized the OAuth application.
	User *AuthUser `json:"user"`
	// Id of the user who authorized the OAuth application.
	UserID string `json:"userId"`
}

type OnboardingCustomerSurvey struct {
	CompanyRole *string `json:"companyRole,omitempty"`
	CompanySize *string `json:"companySize,omitempty"`
}

type OpsgenieInput struct {
	// The date when the Opsgenie API failed with an unauthorized error.
	APIFailedWithUnauthorizedErrorAt *string `json:"apiFailedWithUnauthorizedErrorAt,omitempty"`
}

// Opsgenie specific settings.
type OpsgenieSettings struct {
	// The date when the Opsgenie API failed with an unauthorized error.
	APIFailedWithUnauthorizedErrorAt *string `json:"apiFailedWithUnauthorizedErrorAt,omitempty"`
}

// An organization. Organizations are root-level objects that contain user accounts and teams.
type Organization struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The organization's name.
	Name string `json:"name"`
	// The organization's unique URL key.
	URLKey string `json:"urlKey"`
	// The organization's logo URL.
	LogoURL *string `json:"logoUrl,omitempty"`
	// Rolling 30-day total upload volume for the organization, in megabytes.
	PeriodUploadVolume float64 `json:"periodUploadVolume"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat,omitempty"`
	// Whether the Git integration linkback messages should be sent to private repositories.
	GitLinkbackMessagesEnabled bool `json:"gitLinkbackMessagesEnabled"`
	// Whether the Git integration linkback messages should be sent to public repositories.
	GitPublicLinkbackMessagesEnabled bool `json:"gitPublicLinkbackMessagesEnabled"`
	// Whether the organization is using a roadmap.
	RoadmapEnabled bool `json:"roadmapEnabled"`
	// The n-weekly frequency at which to prompt for project updates. When not set, reminders are off.
	ProjectUpdateReminderFrequencyInWeeks *float64 `json:"projectUpdateReminderFrequencyInWeeks,omitempty"`
	// The day at which to prompt for project updates.
	ProjectUpdateRemindersDay Day `json:"projectUpdateRemindersDay"`
	// The hour at which to prompt for project updates.
	ProjectUpdateRemindersHour float64 `json:"projectUpdateRemindersHour"`
	// The month at which the fiscal year starts. Defaults to January (0).
	FiscalYearStartMonth float64 `json:"fiscalYearStartMonth"`
	// Whether SAML authentication is enabled for organization.
	SamlEnabled bool `json:"samlEnabled"`
	// [INTERNAL] SAML settings.
	SamlSettings *string `json:"samlSettings,omitempty"`
	// Whether SCIM provisioning is enabled for organization.
	ScimEnabled bool `json:"scimEnabled"`
	// Allowed authentication providers, empty array means all are allowed.
	AllowedAuthServices []string `json:"allowedAuthServices"`
	// IP restriction configurations.
	IPRestrictions []*OrganizationIPRestriction `json:"ipRestrictions,omitempty"`
	// The time at which deletion of the organization was requested.
	DeletionRequestedAt *string `json:"deletionRequestedAt,omitempty"`
	// The time at which the trial will end.
	TrialEndsAt *string `json:"trialEndsAt,omitempty"`
	// Previously used URL keys for the organization (last 3 are kept and redirected).
	PreviousURLKeys []string `json:"previousUrlKeys"`
	// Whether member users are allowed to send invites.
	AllowMembersToInvite *bool `json:"allowMembersToInvite,omitempty"`
	// [ALPHA] Theme settings for the organization.
	ThemeSettings *string `json:"themeSettings,omitempty"`
	// The feature release channel the organization belongs to.
	ReleaseChannel ReleaseChannel `json:"releaseChannel"`
	// Which day count to use for SLA calculations.
	SLADayCount SLADayCountType `json:"slaDayCount"`
	// The organization's project statuses.
	ProjectStatuses []*ProjectStatus `json:"projectStatuses"`
	// [DEPRECATED] The frequency at which to prompt for project updates.
	ProjectUpdatesReminderFrequency ProjectUpdateReminderFrequency `json:"projectUpdatesReminderFrequency"`
	// Users associated with the organization.
	Users *UserConnection `json:"users"`
	// Teams associated with the organization.
	Teams *TeamConnection `json:"teams"`
	// Integrations associated with the organization.
	Integrations *IntegrationConnection `json:"integrations"`
	// The organization's subscription to a paid plan.
	Subscription *PaidSubscription `json:"subscription,omitempty"`
	// Number of active users in the organization.
	UserCount int64 `json:"userCount"`
	// Number of issues in the organization.
	CreatedIssueCount int64 `json:"createdIssueCount"`
	// Templates associated with the organization.
	Templates *TemplateConnection `json:"templates"`
	// Labels associated with the organization.
	Labels *IssueLabelConnection `json:"labels"`
}

func (Organization) IsNode() {}

// The unique identifier of the entity.
func (this Organization) GetID() string { return this.ID }

type OrganizationAcceptedOrExpiredInviteDetailsPayload struct {
	// The status of the invite.
	Status OrganizationInviteStatus `json:"status"`
}

func (OrganizationAcceptedOrExpiredInviteDetailsPayload) IsOrganizationInviteDetailsPayload() {}

type OrganizationCancelDeletePayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type OrganizationDeletePayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Defines the use of a domain by an organization.
type OrganizationDomain struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Domain name.
	Name string `json:"name"`
	// Is this domain verified.
	Verified bool `json:"verified"`
	// E-mail used to verify this domain.
	VerificationEmail *string `json:"verificationEmail,omitempty"`
	// The user who added the domain.
	Creator *User `json:"creator,omitempty"`
	// What type of auth is the domain used for.
	AuthType OrganizationDomainAuthType `json:"authType"`
	// Whether the domains was claimed by the organization through DNS verification.
	Claimed *bool `json:"claimed,omitempty"`
	// Prevent users with this domain to create new workspaces.
	DisableOrganizationCreation *bool `json:"disableOrganizationCreation,omitempty"`
}

func (OrganizationDomain) IsNode() {}

// The unique identifier of the entity.
func (this OrganizationDomain) GetID() string { return this.ID }

// [INTERNAL] Domain claim request response.
type OrganizationDomainClaimPayload struct {
	// String to put into DNS for verification.
	VerificationString string `json:"verificationString"`
}

type OrganizationDomainCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The domain name to add.
	Name string `json:"name"`
	// The email address to which to send the verification code.
	VerificationEmail *string `json:"verificationEmail,omitempty"`
	// The authentication type this domain is for.
	AuthType *string `json:"authType,omitempty"`
}

// [INTERNAL] Organization domain operation response.
type OrganizationDomainPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The organization domain that was created or updated.
	OrganizationDomain *OrganizationDomain `json:"organizationDomain"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// [INTERNAL] Organization domain operation response.
type OrganizationDomainSimplePayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type OrganizationDomainUpdateInput struct {
	// Prevent users with this domain to create new workspaces. Only allowed to set on claimed domains!
	DisableOrganizationCreation *bool `json:"disableOrganizationCreation,omitempty"`
}

type OrganizationDomainVerificationInput struct {
	// The identifier in UUID v4 format of the domain being verified.
	OrganizationDomainID string `json:"organizationDomainId"`
	// The verification code sent via email.
	VerificationCode string `json:"verificationCode"`
}

type OrganizationExistsPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// Whether the organization exists.
	Exists bool `json:"exists"`
}

// An invitation to the organization that has been sent via email.
type OrganizationInvite struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The invitees email address.
	Email string `json:"email"`
	// The user role that the invitee will receive upon accepting the invite.
	Role UserRoleType `json:"role"`
	// The invite was sent to external address.
	External bool `json:"external"`
	// The time at which the invite was accepted. Null, if the invite hasn't been accepted.
	AcceptedAt *string `json:"acceptedAt,omitempty"`
	// The time at which the invite will be expiring. Null, if the invite shouldn't expire.
	ExpiresAt *string `json:"expiresAt,omitempty"`
	// Extra metadata associated with the organization invite.
	Metadata *string `json:"metadata,omitempty"`
	// The user who created the invitation.
	Inviter *User `json:"inviter"`
	// The user who has accepted the invite. Null, if the invite hasn't been accepted.
	Invitee *User `json:"invitee,omitempty"`
	// The organization that the invite is associated with.
	Organization *Organization `json:"organization"`
}

func (OrganizationInvite) IsNode() {}

// The unique identifier of the entity.
func (this OrganizationInvite) GetID() string { return this.ID }

type OrganizationInviteConnection struct {
	Edges    []*OrganizationInviteEdge `json:"edges"`
	Nodes    []*OrganizationInvite     `json:"nodes"`
	PageInfo *PageInfo                 `json:"pageInfo"`
}

type OrganizationInviteCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The email of the invitee.
	Email string `json:"email"`
	// What user role the invite should grant.
	Role *UserRoleType `json:"role,omitempty"`
	// The message to send to the invitee.
	Message *string `json:"message,omitempty"`
	// The teams that the user has been invited to.
	TeamIds []string `json:"teamIds,omitempty"`
	// [INTERNAL] Optional metadata about the invite.
	Metadata *string `json:"metadata,omitempty"`
}

type OrganizationInviteEdge struct {
	Node *OrganizationInvite `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type OrganizationInviteFullDetailsPayload struct {
	// The status of the invite.
	Status OrganizationInviteStatus `json:"status"`
	// The name of the inviter.
	Inviter string `json:"inviter"`
	// The email of the invitee.
	Email string `json:"email"`
	// What user role the invite should grant.
	Role UserRoleType `json:"role"`
	// When the invite was created.
	CreatedAt string `json:"createdAt"`
	// Name of the workspace the invite is for.
	OrganizationName string `json:"organizationName"`
	// ID of the workspace the invite is for.
	OrganizationID string `json:"organizationId"`
	// URL of the workspace logo the invite is for.
	OrganizationLogoURL *string `json:"organizationLogoUrl,omitempty"`
	// Whether the invite has already been accepted.
	Accepted bool `json:"accepted"`
	// Whether the invite has expired.
	Expired bool `json:"expired"`
	// Allowed authentication providers, empty array means all are allowed.
	AllowedAuthServices []string `json:"allowedAuthServices"`
}

func (OrganizationInviteFullDetailsPayload) IsOrganizationInviteDetailsPayload() {}

type OrganizationInviteLinkDetailsPayload struct {
	// Name of the workspace the invite link is for.
	OrganizationName *string `json:"organizationName,omitempty"`
	// ID of the workspace the invite link is for.
	OrganizationID *string `json:"organizationId,omitempty"`
	// URL of the workspace logo the invite link is for.
	OrganizationLogoURL *string `json:"organizationLogoUrl,omitempty"`
	// URL key of the workspace the invite link is for.
	OrganizationURLKey *string `json:"organizationUrlKey,omitempty"`
	// Region of the workspace the invite link is for.
	OrganizationRegion *string `json:"organizationRegion,omitempty"`
	// Allowed authentication providers, empty array means all are allowed.
	AllowedAuthServices []string `json:"allowedAuthServices"`
}

type OrganizationInvitePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The organization invite that was created or updated.
	OrganizationInvite *OrganizationInvite `json:"organizationInvite"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type OrganizationInviteUpdateInput struct {
	// The teams that the user has been invited to.
	TeamIds []string `json:"teamIds"`
}

type OrganizationIPRestriction struct {
	// IP range in CIDR format.
	Range string `json:"range"`
	// Restriction type.
	Type string `json:"type"`
	// Optional restriction description.
	Description *string `json:"description,omitempty"`
	// Whether the restriction is enabled.
	Enabled bool `json:"enabled"`
}

// [INTERNAL] Organization IP restriction configuration.
type OrganizationIPRestrictionInput struct {
	// IP range in CIDR format.
	Range string `json:"range"`
	// Restriction type.
	Type string `json:"type"`
	// Optional restriction description.
	Description *string `json:"description,omitempty"`
	// Whether the restriction is enabled.
	Enabled bool `json:"enabled"`
}

type OrganizationMeta struct {
	// The region the organization is hosted in.
	Region string `json:"region"`
	// Allowed authentication providers, empty array means all are allowed.
	AllowedAuthServices []string `json:"allowedAuthServices"`
}

type OrganizationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The organization that was created or updated.
	Organization *Organization `json:"organization,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type OrganizationRegionResponse struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The region for the organization.
	Region *string `json:"region,omitempty"`
}

type OrganizationStartTrialPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type OrganizationUpdateInput struct {
	// The name of the organization.
	Name *string `json:"name,omitempty"`
	// The logo of the organization.
	LogoURL *string `json:"logoUrl,omitempty"`
	// The URL key of the organization.
	URLKey *string `json:"urlKey,omitempty"`
	// How git branches are formatted. If null, default formatting will be used.
	GitBranchFormat *string `json:"gitBranchFormat,omitempty"`
	// Whether the Git integration linkback messages should be sent for private repositories.
	GitLinkbackMessagesEnabled *bool `json:"gitLinkbackMessagesEnabled,omitempty"`
	// Whether the Git integration linkback messages should be sent for public repositories.
	GitPublicLinkbackMessagesEnabled *bool `json:"gitPublicLinkbackMessagesEnabled,omitempty"`
	// Whether the organization is using roadmap.
	RoadmapEnabled *bool `json:"roadmapEnabled,omitempty"`
	// The n-weekly frequency at which to prompt for project updates.
	ProjectUpdateReminderFrequencyInWeeks *float64 `json:"projectUpdateReminderFrequencyInWeeks,omitempty"`
	// The day at which project updates are sent.
	ProjectUpdateRemindersDay *Day `json:"projectUpdateRemindersDay,omitempty"`
	// The hour at which project updates are sent.
	ProjectUpdateRemindersHour *float64 `json:"projectUpdateRemindersHour,omitempty"`
	// The month at which the fiscal year starts.
	FiscalYearStartMonth *float64 `json:"fiscalYearStartMonth,omitempty"`
	// Whether the organization has opted for reduced customer support attachment information.
	ReducedPersonalInformation *bool `json:"reducedPersonalInformation,omitempty"`
	// Whether the organization has opted for having to approve all OAuth applications for install.
	OauthAppReview *bool `json:"oauthAppReview,omitempty"`
	// List of services that are allowed to be used for login.
	AllowedAuthServices []string `json:"allowedAuthServices,omitempty"`
	// Internal. Whether SLAs have been enabled for the organization.
	SLAEnabled *bool `json:"slaEnabled,omitempty"`
	// Which day count to use for SLA calculation.
	SLADayCount *SLADayCountType `json:"slaDayCount,omitempty"`
	// Whether member users are allowed to send invites.
	AllowMembersToInvite *bool `json:"allowMembersToInvite,omitempty"`
	// IP restriction configurations controlling allowed access the workspace.
	IPRestrictions []*OrganizationIPRestrictionInput `json:"ipRestrictions,omitempty"`
	// [ALPHA] Theme settings for the organization.
	ThemeSettings *string `json:"themeSettings,omitempty"`
}

// Customer owner sorting options.
type OwnerSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type PageInfo struct {
	// Indicates if there are more results when paginating backward.
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Indicates if there are more results when paginating forward.
	HasNextPage bool `json:"hasNextPage"`
	// Cursor representing the first result in the paginated results.
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor representing the last result in the paginated results.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PagerDutyInput struct {
	// The date when the PagerDuty API failed with an unauthorized error.
	APIFailedWithUnauthorizedErrorAt *string `json:"apiFailedWithUnauthorizedErrorAt,omitempty"`
}

// PagerDuty specific settings.
type PagerDutySettings struct {
	// The date when the PagerDuty API failed with an unauthorized error.
	APIFailedWithUnauthorizedErrorAt *string `json:"apiFailedWithUnauthorizedErrorAt,omitempty"`
}

// The paid subscription of an organization.
type PaidSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The subscription type.
	Type string `json:"type"`
	// The number of seats in the subscription.
	Seats float64 `json:"seats"`
	// The minimum number of seats that will be billed in the subscription.
	SeatsMinimum *float64 `json:"seatsMinimum,omitempty"`
	// The maximum number of seats that will be billed in the subscription.
	SeatsMaximum *float64 `json:"seatsMaximum,omitempty"`
	// The creator of the subscription.
	Creator *User `json:"creator,omitempty"`
	// The organization that the subscription is associated with.
	Organization *Organization `json:"organization"`
	// The collection method for this subscription, either automatically charged or invoiced.
	CollectionMethod string `json:"collectionMethod"`
	// The date the subscription was canceled, if any.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The subscription type of a pending change. Null if no change pending.
	PendingChangeType *string `json:"pendingChangeType,omitempty"`
	// The date the subscription will be billed next.
	NextBillingAt *string `json:"nextBillingAt,omitempty"`
}

func (PaidSubscription) IsNode() {}

// The unique identifier of the entity.
func (this PaidSubscription) GetID() string { return this.ID }

// Registered passkey for authentication.
type Passkey struct {
	ID     string `json:"id"`
	Label  string `json:"label"`
	Aaguid string `json:"aaguid"`
	// Date when the passkey was last updated.
	UpdatedAt         string  `json:"updatedAt"`
	LastUsedSessionID *string `json:"lastUsedSessionId,omitempty"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The time when the passkey was last used.
	LastUsedAt string `json:"lastUsedAt"`
	// Type of application used to create.
	ClientType AuthenticationSessionType `json:"clientType"`
	// Location region code. Only set on creation.
	LocationRegionCode *string `json:"locationRegionCode,omitempty"`
	// Location city name. Only set on creation.
	LocationCity *string `json:"locationCity,omitempty"`
	// Creating session's user-agent. Only set on creation.
	UserAgent *string `json:"userAgent,omitempty"`
	// Used web browser. Only set on creation.
	BrowserType *string `json:"browserType,omitempty"`
	// IP address. Only set on creation.
	IP *string `json:"ip,omitempty"`
	// Location country name. Only set on creation.
	LocationCountry *string `json:"locationCountry,omitempty"`
	// Location country code. Only set on creation.
	LocationCountryCode *string `json:"locationCountryCode,omitempty"`
}

type PasskeyLoginStartResponse struct {
	Success bool   `json:"success"`
	Options string `json:"options"`
}

// Issue priority sorting options.
type PrioritySort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
	// Whether to consider no priority as the highest or lowest priority
	NoPriorityFirst *bool `json:"noPriorityFirst,omitempty"`
}

// A project.
type Project struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The project's name.
	Name string `json:"name"`
	// The project's description.
	Description string `json:"description"`
	// The content of the project description.
	DocumentContent *DocumentContent `json:"documentContent,omitempty"`
	// The project's unique URL slug.
	SlugID string `json:"slugId"`
	// The icon of the project.
	Icon *string `json:"icon,omitempty"`
	// The project's color.
	Color string `json:"color"`
	// The status that the project is associated with.
	Status *ProjectStatus `json:"status"`
	// The user who created the project.
	Creator *User `json:"creator,omitempty"`
	// The project lead.
	Lead *User `json:"lead,omitempty"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *string `json:"projectUpdateRemindersPausedUntilAt,omitempty"`
	// The estimated start date of the project.
	StartDate *string `json:"startDate,omitempty"`
	// [INTERNAL] The resolution of the project's start date.
	StartDateResolution *DateResolutionType `json:"startDateResolution,omitempty"`
	// The estimated completion date of the project.
	TargetDate *string `json:"targetDate,omitempty"`
	// [INTERNAL] The resolution of the project's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// The time at which the project was moved into started state.
	StartedAt *string `json:"startedAt,omitempty"`
	// The time at which the project was moved into completed state.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The time at which the project was moved into canceled state.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *string `json:"autoArchivedAt,omitempty"`
	// A flag that indicates whether the project is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The sort order for the project within the organization.
	SortOrder float64 `json:"sortOrder"`
	// [ALPHA] The sort order for the project within the organization, when ordered by priority.
	PrioritySortOrder float64 `json:"prioritySortOrder"`
	// The project was created based on this issue.
	ConvertedFromIssue *Issue `json:"convertedFromIssue,omitempty"`
	// The last template that was applied to this project.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority int64 `json:"priority"`
	// The time at which the project health was updated.
	HealthUpdatedAt *string `json:"healthUpdatedAt,omitempty"`
	// The total number of issues in the project after each week.
	IssueCountHistory []float64 `json:"issueCountHistory"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []float64 `json:"completedIssueCountHistory"`
	// The total number of estimation points after each week.
	ScopeHistory []float64 `json:"scopeHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []float64 `json:"completedScopeHistory"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []float64 `json:"inProgressScopeHistory"`
	// [Internal] The progress history of the project.
	ProgressHistory string `json:"progressHistory"`
	// [Internal] The current progress of the project.
	CurrentProgress string `json:"currentProgress"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue bool `json:"slackNewIssue"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses bool `json:"slackIssueStatuses"`
	// The user's favorite associated with this project.
	Favorite *Favorite `json:"favorite,omitempty"`
	// Project URL.
	URL string `json:"url"`
	// Initiatives that this project belongs to.
	Initiatives *InitiativeConnection `json:"initiatives"`
	// Teams associated with this project.
	Teams *TeamConnection `json:"teams"`
	// Users that are members of the project.
	Members *UserConnection `json:"members"`
	// Project updates associated with the project.
	ProjectUpdates *ProjectUpdateConnection `json:"projectUpdates"`
	// Documents associated with the project.
	Documents *DocumentConnection `json:"documents"`
	// Milestones associated with the project.
	ProjectMilestones *ProjectMilestoneConnection `json:"projectMilestones"`
	// Issues associated with the project.
	Issues *IssueConnection `json:"issues"`
	// [DEPRECATED] Links associated with the project.
	Links *ProjectLinkConnection `json:"links"`
	// External links associated with the project.
	ExternalLinks *EntityExternalLinkConnection `json:"externalLinks"`
	// History entries associated with the project.
	History *ProjectHistoryConnection `json:"history"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress float64 `json:"progress"`
	// The health of the project based on the last project update.
	Health *ProjectUpdateHealthType `json:"health,omitempty"`
	// The overall scope (total estimate points) of the project.
	Scope float64 `json:"scope"`
	// Settings for all integrations associated with that project.
	IntegrationsSettings *IntegrationsSettings `json:"integrationsSettings,omitempty"`
	// The project's content in markdown format.
	Content *string `json:"content,omitempty"`
	// [Internal] The project's content as YJS state.
	ContentState *string `json:"contentState,omitempty"`
	// [DEPRECATED] The type of the state.
	State string `json:"state"`
}

func (Project) IsNode() {}

// The unique identifier of the entity.
func (this Project) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type ProjectArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Project `json:"entity,omitempty"`
}

func (ProjectArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this ProjectArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this ProjectArchivePayload) GetSuccess() bool { return this.Success }

// Project filtering options.
type ProjectCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// [DEPRECATED] Comparator for the project state.
	State *StringComparator `json:"state,omitempty"`
	// Filters that the project's status must satisfy.
	Status *ProjectStatusFilter `json:"status,omitempty"`
	// [ALPHA] Comparator for the projects priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// [Internal] Comparator for the project's content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the project completion date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the project cancelation date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the project start date.
	StartDate *NullableDateComparator `json:"startDate,omitempty"`
	// Comparator for the project target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Comparator for the project health.
	Health *StringComparator `json:"health,omitempty"`
	// Comparator for the project health (with age).
	HealthWithAge *StringComparator `json:"healthWithAge,omitempty"`
	// Comparator for filtering projects with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// [Deprecated] Comparator for filtering projects which this is depended on by.
	HasDependedOnByRelations *RelationExistsComparator `json:"hasDependedOnByRelations,omitempty"`
	// [Deprecated]Comparator for filtering projects which this depends on.
	HasDependsOnRelations *RelationExistsComparator `json:"hasDependsOnRelations,omitempty"`
	// Comparator for filtering projects which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering projects which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering projects with violated dependencies.
	HasViolatedRelations *RelationExistsComparator `json:"hasViolatedRelations,omitempty"`
	// Comparator for the project updates.
	ProjectUpdates *ProjectUpdatesCollectionFilter `json:"projectUpdates,omitempty"`
	// Filters that the projects creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the projects lead must satisfy.
	Lead *NullableUserFilter `json:"lead,omitempty"`
	// Filters that the projects members must satisfy.
	Members *UserCollectionFilter `json:"members,omitempty"`
	// Filters that the projects issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filters that the projects roadmaps must satisfy.
	Roadmaps *RoadmapCollectionFilter `json:"roadmaps,omitempty"`
	// Filters that the projects initiatives must satisfy.
	Initiatives *InitiativeCollectionFilter `json:"initiatives,omitempty"`
	// Filters that the project's milestones must satisfy.
	ProjectMilestones *ProjectMilestoneCollectionFilter `json:"projectMilestones,omitempty"`
	// Filters that the project's completed milestones must satisfy.
	CompletedProjectMilestones *ProjectMilestoneCollectionFilter `json:"completedProjectMilestones,omitempty"`
	// Filters that the project's next milestone must satisfy.
	NextProjectMilestone *ProjectMilestoneFilter `json:"nextProjectMilestone,omitempty"`
	// Filters that the project's team must satisfy.
	AccessibleTeams *TeamCollectionFilter `json:"accessibleTeams,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the project's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the project.
	And []*ProjectCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project.
	Or []*ProjectCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some projects.
	Some *ProjectFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all projects.
	Every *ProjectFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type ProjectConnection struct {
	Edges    []*ProjectEdge `json:"edges"`
	Nodes    []*Project     `json:"nodes"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

type ProjectCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the project.
	Name string `json:"name"`
	// The icon of the project.
	Icon *string `json:"icon,omitempty"`
	// The color of the project.
	Color *string `json:"color,omitempty"`
	// [DEPRECATED] The state of the project.
	State *string `json:"state,omitempty"`
	// The ID of the project status.
	StatusID *string `json:"statusId,omitempty"`
	// The description for the project.
	Description *string `json:"description,omitempty"`
	// The identifiers of the teams this project is associated with.
	TeamIds []string `json:"teamIds"`
	// The ID of the issue from which that project is created.
	ConvertedFromIssueID *string `json:"convertedFromIssueId,omitempty"`
	// The ID of the last template applied to the project.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The identifier of the project lead.
	LeadID *string `json:"leadId,omitempty"`
	// The identifiers of the members of this project.
	MemberIds []string `json:"memberIds,omitempty"`
	// The planned start date of the project.
	StartDate *string `json:"startDate,omitempty"`
	// [INTERNAL] The resolution of the project's start date.
	StartDateResolution *DateResolutionType `json:"startDateResolution,omitempty"`
	// The planned target date of the project.
	TargetDate *string `json:"targetDate,omitempty"`
	// [INTERNAL] The resolution of the project's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// The sort order for the project within shared views.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// [ALPHA] The sort order for the project within shared views, when ordered by priority.
	PrioritySortOrder *float64 `json:"prioritySortOrder,omitempty"`
	// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *int64 `json:"priority,omitempty"`
}

type ProjectEdge struct {
	Node *Project `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Project filtering options.
type ProjectFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// [DEPRECATED] Comparator for the project state.
	State *StringComparator `json:"state,omitempty"`
	// Filters that the project's status must satisfy.
	Status *ProjectStatusFilter `json:"status,omitempty"`
	// [ALPHA] Comparator for the projects priority.
	Priority *NullableNumberComparator `json:"priority,omitempty"`
	// [Internal] Comparator for the project's content.
	SearchableContent *ContentComparator `json:"searchableContent,omitempty"`
	// Comparator for the project completion date.
	CompletedAt *NullableDateComparator `json:"completedAt,omitempty"`
	// Comparator for the project cancelation date.
	CanceledAt *NullableDateComparator `json:"canceledAt,omitempty"`
	// Comparator for the project start date.
	StartDate *NullableDateComparator `json:"startDate,omitempty"`
	// Comparator for the project target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Comparator for the project health.
	Health *StringComparator `json:"health,omitempty"`
	// Comparator for the project health (with age).
	HealthWithAge *StringComparator `json:"healthWithAge,omitempty"`
	// Comparator for filtering projects with relations.
	HasRelatedRelations *RelationExistsComparator `json:"hasRelatedRelations,omitempty"`
	// [Deprecated] Comparator for filtering projects which this is depended on by.
	HasDependedOnByRelations *RelationExistsComparator `json:"hasDependedOnByRelations,omitempty"`
	// [Deprecated]Comparator for filtering projects which this depends on.
	HasDependsOnRelations *RelationExistsComparator `json:"hasDependsOnRelations,omitempty"`
	// Comparator for filtering projects which are blocked.
	HasBlockedByRelations *RelationExistsComparator `json:"hasBlockedByRelations,omitempty"`
	// Comparator for filtering projects which are blocking.
	HasBlockingRelations *RelationExistsComparator `json:"hasBlockingRelations,omitempty"`
	// Comparator for filtering projects with violated dependencies.
	HasViolatedRelations *RelationExistsComparator `json:"hasViolatedRelations,omitempty"`
	// Comparator for the project updates.
	ProjectUpdates *ProjectUpdatesCollectionFilter `json:"projectUpdates,omitempty"`
	// Filters that the projects creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Filters that the projects lead must satisfy.
	Lead *NullableUserFilter `json:"lead,omitempty"`
	// Filters that the projects members must satisfy.
	Members *UserCollectionFilter `json:"members,omitempty"`
	// Filters that the projects issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Filters that the projects roadmaps must satisfy.
	Roadmaps *RoadmapCollectionFilter `json:"roadmaps,omitempty"`
	// Filters that the projects initiatives must satisfy.
	Initiatives *InitiativeCollectionFilter `json:"initiatives,omitempty"`
	// Filters that the project's milestones must satisfy.
	ProjectMilestones *ProjectMilestoneCollectionFilter `json:"projectMilestones,omitempty"`
	// Filters that the project's completed milestones must satisfy.
	CompletedProjectMilestones *ProjectMilestoneCollectionFilter `json:"completedProjectMilestones,omitempty"`
	// Filters that the project's next milestone must satisfy.
	NextProjectMilestone *ProjectMilestoneFilter `json:"nextProjectMilestone,omitempty"`
	// Filters that the project's team must satisfy.
	AccessibleTeams *TeamCollectionFilter `json:"accessibleTeams,omitempty"`
	// Filters that the last applied template must satisfy.
	LastAppliedTemplate *NullableTemplateFilter `json:"lastAppliedTemplate,omitempty"`
	// Filters that the project's customer needs must satisfy.
	Needs *CustomerNeedCollectionFilter `json:"needs,omitempty"`
	// Compound filters, all of which need to be matched by the project.
	And []*ProjectFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project.
	Or []*ProjectFilter `json:"or,omitempty"`
}

type ProjectFilterSuggestionPayload struct {
	// The json filter that is suggested.
	Filter *string `json:"filter,omitempty"`
}

// An history associated with a project.
type ProjectHistory struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The project that the history is associated with.
	Project *Project `json:"project"`
	// The events that happened while recording that history.
	Entries string `json:"entries"`
}

func (ProjectHistory) IsNode() {}

// The unique identifier of the entity.
func (this ProjectHistory) GetID() string { return this.ID }

type ProjectHistoryConnection struct {
	Edges    []*ProjectHistoryEdge `json:"edges"`
	Nodes    []*ProjectHistory     `json:"nodes"`
	PageInfo *PageInfo             `json:"pageInfo"`
}

type ProjectHistoryEdge struct {
	Node *ProjectHistory `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// An external link for a project.
type ProjectLink struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The link's URL.
	URL string `json:"url"`
	// The link's label.
	Label string `json:"label"`
	// The order of the item in the project resources list.
	SortOrder float64 `json:"sortOrder"`
	// The user who created the link.
	Creator *User `json:"creator"`
	// The project that the link is associated with.
	Project *Project `json:"project"`
}

func (ProjectLink) IsNode() {}

// The unique identifier of the entity.
func (this ProjectLink) GetID() string { return this.ID }

type ProjectLinkConnection struct {
	Edges    []*ProjectLinkEdge `json:"edges"`
	Nodes    []*ProjectLink     `json:"nodes"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type ProjectLinkCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The URL of the link.
	URL string `json:"url"`
	// The label for the link.
	Label string `json:"label"`
	// Related project for the link.
	ProjectID string `json:"projectId"`
	// The order of the item in the project resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type ProjectLinkEdge struct {
	Node *ProjectLink `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type ProjectLinkPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project that was created or updated.
	ProjectLink *ProjectLink `json:"projectLink"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectLinkUpdateInput struct {
	// The URL of the link.
	URL *string `json:"url,omitempty"`
	// The label for the link.
	Label *string `json:"label,omitempty"`
	// The order of the item in the project resources list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

// A milestone for a project.
type ProjectMilestone struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the project milestone.
	Name string `json:"name"`
	// The content of the project milestone description.
	DocumentContent *DocumentContent `json:"documentContent,omitempty"`
	// The planned completion date of the milestone.
	TargetDate *string `json:"targetDate,omitempty"`
	// The project of the milestone.
	Project *Project `json:"project"`
	// The order of the milestone in relation to other milestones within a project.
	SortOrder float64 `json:"sortOrder"`
	// The project milestone's description in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The project milestone's description as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// [Internal] The project milestone's description as YJS state.
	DescriptionState *string `json:"descriptionState,omitempty"`
	// Issues associated with the project milestone.
	Issues *IssueConnection `json:"issues"`
}

func (ProjectMilestone) IsNode() {}

// The unique identifier of the entity.
func (this ProjectMilestone) GetID() string { return this.ID }

// Milestone collection filtering options.
type ProjectMilestoneCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project milestone name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project milestone target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Compound filters, all of which need to be matched by the milestone.
	And []*ProjectMilestoneCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the milestone.
	Or []*ProjectMilestoneCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some milestones.
	Some *ProjectMilestoneFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all milestones.
	Every *ProjectMilestoneFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type ProjectMilestoneConnection struct {
	Edges    []*ProjectMilestoneEdge `json:"edges"`
	Nodes    []*ProjectMilestone     `json:"nodes"`
	PageInfo *PageInfo               `json:"pageInfo"`
}

type ProjectMilestoneCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the project milestone.
	Name string `json:"name"`
	// The description of the project milestone in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The description of the project milestone as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The planned target date of the project milestone.
	TargetDate *string `json:"targetDate,omitempty"`
	// Related project for the project milestone.
	ProjectID string `json:"projectId"`
	// The sort order for the project milestone within a project.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type ProjectMilestoneEdge struct {
	Node *ProjectMilestone `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Project milestone filtering options.
type ProjectMilestoneFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project milestone name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project milestone target date.
	TargetDate *NullableDateComparator `json:"targetDate,omitempty"`
	// Compound filters, all of which need to be matched by the project milestone.
	And []*ProjectMilestoneFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project milestone.
	Or []*ProjectMilestoneFilter `json:"or,omitempty"`
}

type ProjectMilestoneMoveInput struct {
	// The identifier of the project to move the milestone to.
	ProjectID string `json:"projectId"`
	// The team id to move the attached issues to. This is needed when there is a mismatch between a project's teams and the milestone's issues' teams. Either this or addIssueTeamToProject is required in that situation to resolve constraints.
	NewIssueTeamID *string `json:"newIssueTeamId,omitempty"`
	// Whether to add each milestone issue's team to the project. This is needed when there is a mismatch between a project's teams and the milestone's issues' teams. Either this or newIssueTeamId is required in that situation to resolve constraints.
	AddIssueTeamToProject *bool `json:"addIssueTeamToProject,omitempty"`
	// A list of issue id to team ids, used for undoing a previous milestone move where the specified issues were moved from the specified teams.
	UndoIssueTeamIds []*ProjectMilestoneMoveIssueToTeamInput `json:"undoIssueTeamIds,omitempty"`
	// A mapping of project id to a previous set of team ids, used for undoing a previous milestone move where the specified teams were added to the project.
	UndoProjectTeamIds *ProjectMilestoneMoveProjectTeamsInput `json:"undoProjectTeamIds,omitempty"`
}

type ProjectMilestoneMoveIssueToTeam struct {
	// The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
	IssueID string `json:"issueId"`
	// The team id in this relationship
	TeamID string `json:"teamId"`
}

// [Internal] Used for ProjectMilestoneMoveInput to describe a mapping between an issue and its team.
type ProjectMilestoneMoveIssueToTeamInput struct {
	// The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
	IssueID string `json:"issueId"`
	// The team id in this relationship
	TeamID string `json:"teamId"`
}

type ProjectMilestoneMovePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project milestone that was created or updated.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// A snapshot of the issues that were moved to new teams, if the user selected to do it, containing an array of mappings between an issue and its previous team. Store on the client to use for undoing a previous milestone move.
	PreviousIssueTeamIds []*ProjectMilestoneMoveIssueToTeam `json:"previousIssueTeamIds,omitempty"`
	// A snapshot of the project that had new teams added to it, if the user selected to do it, containing an array of mappings between a project and its previous teams. Store on the client to use for undoing a previous milestone move.
	PreviousProjectTeamIds *ProjectMilestoneMoveProjectTeams `json:"previousProjectTeamIds,omitempty"`
}

type ProjectMilestoneMoveProjectTeams struct {
	// The project id
	ProjectID string `json:"projectId"`
	// The team ids for the project
	TeamIds []string `json:"teamIds"`
}

// [Internal] Used for ProjectMilestoneMoveInput to describe a snapshot of a project and its team ids
type ProjectMilestoneMoveProjectTeamsInput struct {
	// The project id
	ProjectID string `json:"projectId"`
	// The team ids for the project
	TeamIds []string `json:"teamIds"`
}

type ProjectMilestonePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project milestone that was created or updated.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectMilestoneUpdateInput struct {
	// The name of the project milestone.
	Name *string `json:"name,omitempty"`
	// The description of the project milestone in markdown format.
	Description *string `json:"description,omitempty"`
	// [Internal] The description of the project milestone as a Prosemirror document.
	DescriptionData *string `json:"descriptionData,omitempty"`
	// The planned target date of the project milestone.
	TargetDate *string `json:"targetDate,omitempty"`
	// The sort order for the project milestone within a project.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// Related project for the project milestone.
	ProjectID *string `json:"projectId,omitempty"`
}

// A project related notification.
type ProjectNotification struct {
	// Related comment ID. Null if the notification is not related to a comment.
	CommentID *string `json:"commentId,omitempty"`
	// Related parent comment ID. Null if the notification is not related to a comment.
	ParentCommentID *string `json:"parentCommentId,omitempty"`
	// Name of the reaction emoji related to the notification.
	ReactionEmoji *string `json:"reactionEmoji,omitempty"`
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Notification type.
	Type string `json:"type"`
	// The user that caused the notification.
	Actor *User `json:"actor,omitempty"`
	// The external user that caused the notification.
	ExternalUserActor *ExternalUser `json:"externalUserActor,omitempty"`
	// The user that received the notification.
	User *User `json:"user"`
	// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
	ReadAt *string `json:"readAt,omitempty"`
	// The time at when an email reminder for this notification was sent to the user. Null, if no email
	//     reminder has been sent.
	EmailedAt *string `json:"emailedAt,omitempty"`
	// The time until a notification will be snoozed. After that it will appear in the inbox again.
	SnoozedUntilAt *string `json:"snoozedUntilAt,omitempty"`
	// The time at which a notification was unsnoozed..
	UnsnoozedAt *string `json:"unsnoozedAt,omitempty"`
	// [Internal] URL to the target of the notification.
	URL string `json:"url"`
	// [Internal] Inbox URL for the notification.
	InboxURL string `json:"inboxUrl"`
	// [Internal] Notification title.
	Title string `json:"title"`
	// [Internal] Notification subtitle.
	Subtitle string `json:"subtitle"`
	// [Internal] If notification actor was Linear.
	IsLinearActor bool `json:"isLinearActor"`
	// [Internal] Notification avatar URL.
	ActorAvatarURL *string `json:"actorAvatarUrl,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorInitials *string `json:"actorInitials,omitempty"`
	// [Internal] Notification actor initials if avatar is not available.
	ActorAvatarColor *string `json:"actorAvatarColor,omitempty"`
	// [Internal] Issue's status type for issue notifications.
	IssueStatusType *string `json:"issueStatusType,omitempty"`
	// [Internal] Project update health for new updates.
	ProjectUpdateHealth *string `json:"projectUpdateHealth,omitempty"`
	// [Internal] Notifications with the same grouping key will be grouped together in the UI.
	GroupingKey string `json:"groupingKey"`
	// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
	GroupingPriority float64 `json:"groupingPriority"`
	// The bot that caused the notification.
	BotActor *ActorBot `json:"botActor,omitempty"`
	// Related project ID.
	ProjectID string `json:"projectId"`
	// Related project milestone ID.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// Related project update ID.
	ProjectUpdateID *string `json:"projectUpdateId,omitempty"`
	// The project related to the notification.
	Project *Project `json:"project"`
	// The project update related to the notification.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate,omitempty"`
	// The comment related to the notification.
	Comment *Comment `json:"comment,omitempty"`
	// The parent comment related to the notification, if a notification is a reply comment notification.
	ParentComment *Comment `json:"parentComment,omitempty"`
}

func (ProjectNotification) IsEntity() {}

// The unique identifier of the entity.
func (this ProjectNotification) GetID() string { return this.ID }

// The time at which the entity was created.
func (this ProjectNotification) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this ProjectNotification) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this ProjectNotification) GetArchivedAt() *string { return this.ArchivedAt }

func (ProjectNotification) IsNode() {}

// The unique identifier of the entity.

func (ProjectNotification) IsNotification() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// Notification type.
func (this ProjectNotification) GetType() string { return this.Type }

// The user that caused the notification.
func (this ProjectNotification) GetActor() *User { return this.Actor }

// The external user that caused the notification.
func (this ProjectNotification) GetExternalUserActor() *ExternalUser { return this.ExternalUserActor }

// The user that received the notification.
func (this ProjectNotification) GetUser() *User { return this.User }

// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
func (this ProjectNotification) GetReadAt() *string { return this.ReadAt }

// The time at when an email reminder for this notification was sent to the user. Null, if no email
//
//	reminder has been sent.
func (this ProjectNotification) GetEmailedAt() *string { return this.EmailedAt }

// The time until a notification will be snoozed. After that it will appear in the inbox again.
func (this ProjectNotification) GetSnoozedUntilAt() *string { return this.SnoozedUntilAt }

// The time at which a notification was unsnoozed..
func (this ProjectNotification) GetUnsnoozedAt() *string { return this.UnsnoozedAt }

// [Internal] URL to the target of the notification.
func (this ProjectNotification) GetURL() string { return this.URL }

// [Internal] Inbox URL for the notification.
func (this ProjectNotification) GetInboxURL() string { return this.InboxURL }

// [Internal] Notification title.
func (this ProjectNotification) GetTitle() string { return this.Title }

// [Internal] Notification subtitle.
func (this ProjectNotification) GetSubtitle() string { return this.Subtitle }

// [Internal] If notification actor was Linear.
func (this ProjectNotification) GetIsLinearActor() bool { return this.IsLinearActor }

// [Internal] Notification avatar URL.
func (this ProjectNotification) GetActorAvatarURL() *string { return this.ActorAvatarURL }

// [Internal] Notification actor initials if avatar is not available.
func (this ProjectNotification) GetActorInitials() *string { return this.ActorInitials }

// [Internal] Notification actor initials if avatar is not available.
func (this ProjectNotification) GetActorAvatarColor() *string { return this.ActorAvatarColor }

// [Internal] Issue's status type for issue notifications.
func (this ProjectNotification) GetIssueStatusType() *string { return this.IssueStatusType }

// [Internal] Project update health for new updates.
func (this ProjectNotification) GetProjectUpdateHealth() *string { return this.ProjectUpdateHealth }

// [Internal] Notifications with the same grouping key will be grouped together in the UI.
func (this ProjectNotification) GetGroupingKey() string { return this.GroupingKey }

// [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
func (this ProjectNotification) GetGroupingPriority() float64 { return this.GroupingPriority }

// The bot that caused the notification.
func (this ProjectNotification) GetBotActor() *ActorBot { return this.BotActor }

// A project notification subscription.
type ProjectNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The project subscribed to.
	Project *Project `json:"project"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (ProjectNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this ProjectNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this ProjectNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this ProjectNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this ProjectNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (ProjectNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (ProjectNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this ProjectNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this ProjectNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this ProjectNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this ProjectNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this ProjectNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this ProjectNotificationSubscription) GetActive() bool { return this.Active }

type ProjectPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project that was created or updated.
	Project *Project `json:"project,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// A relation between two projects.
type ProjectRelation struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The relationship of the project with the related project.
	Type string `json:"type"`
	// The project whose relationship is being described.
	Project *Project `json:"project"`
	// The milestone within the project whose relationship is being described.
	ProjectMilestone *ProjectMilestone `json:"projectMilestone,omitempty"`
	// The type of anchor on the project end of the relation.
	AnchorType string `json:"anchorType"`
	// The related project.
	RelatedProject *Project `json:"relatedProject"`
	// The milestone within the related project whose relationship is being described.
	RelatedProjectMilestone *ProjectMilestone `json:"relatedProjectMilestone,omitempty"`
	// The type of anchor on the relatedProject end of the relation.
	RelatedAnchorType string `json:"relatedAnchorType"`
	// The last user who created or modified the relation.
	User *User `json:"user,omitempty"`
}

func (ProjectRelation) IsNode() {}

// The unique identifier of the entity.
func (this ProjectRelation) GetID() string { return this.ID }

type ProjectRelationConnection struct {
	Edges    []*ProjectRelationEdge `json:"edges"`
	Nodes    []*ProjectRelation     `json:"nodes"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type ProjectRelationCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The type of relation of the project to the related project.
	Type string `json:"type"`
	// The identifier of the project that is related to another project.
	ProjectID string `json:"projectId"`
	// The identifier of the project milestone.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The type of the anchor for the project.
	AnchorType string `json:"anchorType"`
	// The identifier of the related project.
	RelatedProjectID string `json:"relatedProjectId"`
	// The identifier of the related project milestone.
	RelatedProjectMilestoneID *string `json:"relatedProjectMilestoneId,omitempty"`
	// The type of the anchor for the related project.
	RelatedAnchorType string `json:"relatedAnchorType"`
}

type ProjectRelationEdge struct {
	Node *ProjectRelation `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type ProjectRelationPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project relation that was created or updated.
	ProjectRelation *ProjectRelation `json:"projectRelation"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectRelationUpdateInput struct {
	// The type of relation of the project to the related project.
	Type *string `json:"type,omitempty"`
	// The identifier of the project that is related to another project.
	ProjectID *string `json:"projectId,omitempty"`
	// The identifier of the project milestone.
	ProjectMilestoneID *string `json:"projectMilestoneId,omitempty"`
	// The type of the anchor for the project.
	AnchorType *string `json:"anchorType,omitempty"`
	// The identifier of the related project.
	RelatedProjectID *string `json:"relatedProjectId,omitempty"`
	// The identifier of the related project milestone.
	RelatedProjectMilestoneID *string `json:"relatedProjectMilestoneId,omitempty"`
	// The type of the anchor for the related project.
	RelatedAnchorType *string `json:"relatedAnchorType,omitempty"`
}

type ProjectSearchPayload struct {
	Edges    []*ProjectSearchResultEdge `json:"edges"`
	Nodes    []*ProjectSearchResult     `json:"nodes"`
	PageInfo *PageInfo                  `json:"pageInfo"`
	// Archived entities matching the search term along with all their dependencies.
	ArchivePayload *ArchiveResponse `json:"archivePayload"`
	// Total number of results for query without filters applied.
	TotalCount float64 `json:"totalCount"`
}

type ProjectSearchResult struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The project's name.
	Name string `json:"name"`
	// The project's description.
	Description string `json:"description"`
	// The content of the project description.
	DocumentContent *DocumentContent `json:"documentContent,omitempty"`
	// The project's unique URL slug.
	SlugID string `json:"slugId"`
	// The icon of the project.
	Icon *string `json:"icon,omitempty"`
	// The project's color.
	Color string `json:"color"`
	// The status that the project is associated with.
	Status *ProjectStatus `json:"status"`
	// The user who created the project.
	Creator *User `json:"creator,omitempty"`
	// The project lead.
	Lead *User `json:"lead,omitempty"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *string `json:"projectUpdateRemindersPausedUntilAt,omitempty"`
	// The estimated start date of the project.
	StartDate *string `json:"startDate,omitempty"`
	// [INTERNAL] The resolution of the project's start date.
	StartDateResolution *DateResolutionType `json:"startDateResolution,omitempty"`
	// The estimated completion date of the project.
	TargetDate *string `json:"targetDate,omitempty"`
	// [INTERNAL] The resolution of the project's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// The time at which the project was moved into started state.
	StartedAt *string `json:"startedAt,omitempty"`
	// The time at which the project was moved into completed state.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The time at which the project was moved into canceled state.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// The time at which the project was automatically archived by the auto pruning process.
	AutoArchivedAt *string `json:"autoArchivedAt,omitempty"`
	// A flag that indicates whether the project is in the trash bin.
	Trashed *bool `json:"trashed,omitempty"`
	// The sort order for the project within the organization.
	SortOrder float64 `json:"sortOrder"`
	// [ALPHA] The sort order for the project within the organization, when ordered by priority.
	PrioritySortOrder float64 `json:"prioritySortOrder"`
	// The project was created based on this issue.
	ConvertedFromIssue *Issue `json:"convertedFromIssue,omitempty"`
	// The last template that was applied to this project.
	LastAppliedTemplate *Template `json:"lastAppliedTemplate,omitempty"`
	// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority int64 `json:"priority"`
	// The time at which the project health was updated.
	HealthUpdatedAt *string `json:"healthUpdatedAt,omitempty"`
	// The total number of issues in the project after each week.
	IssueCountHistory []float64 `json:"issueCountHistory"`
	// The number of completed issues in the project after each week.
	CompletedIssueCountHistory []float64 `json:"completedIssueCountHistory"`
	// The total number of estimation points after each week.
	ScopeHistory []float64 `json:"scopeHistory"`
	// The number of completed estimation points after each week.
	CompletedScopeHistory []float64 `json:"completedScopeHistory"`
	// The number of in progress estimation points after each week.
	InProgressScopeHistory []float64 `json:"inProgressScopeHistory"`
	// [Internal] The progress history of the project.
	ProgressHistory string `json:"progressHistory"`
	// [Internal] The current progress of the project.
	CurrentProgress string `json:"currentProgress"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue bool `json:"slackNewIssue"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses bool `json:"slackIssueStatuses"`
	// The user's favorite associated with this project.
	Favorite *Favorite `json:"favorite,omitempty"`
	// Project URL.
	URL string `json:"url"`
	// Initiatives that this project belongs to.
	Initiatives *InitiativeConnection `json:"initiatives"`
	// Teams associated with this project.
	Teams *TeamConnection `json:"teams"`
	// Users that are members of the project.
	Members *UserConnection `json:"members"`
	// Project updates associated with the project.
	ProjectUpdates *ProjectUpdateConnection `json:"projectUpdates"`
	// Documents associated with the project.
	Documents *DocumentConnection `json:"documents"`
	// Milestones associated with the project.
	ProjectMilestones *ProjectMilestoneConnection `json:"projectMilestones"`
	// Issues associated with the project.
	Issues *IssueConnection `json:"issues"`
	// [DEPRECATED] Links associated with the project.
	Links *ProjectLinkConnection `json:"links"`
	// External links associated with the project.
	ExternalLinks *EntityExternalLinkConnection `json:"externalLinks"`
	// History entries associated with the project.
	History *ProjectHistoryConnection `json:"history"`
	// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
	Progress float64 `json:"progress"`
	// The health of the project based on the last project update.
	Health *ProjectUpdateHealthType `json:"health,omitempty"`
	// The overall scope (total estimate points) of the project.
	Scope float64 `json:"scope"`
	// Settings for all integrations associated with that project.
	IntegrationsSettings *IntegrationsSettings `json:"integrationsSettings,omitempty"`
	// The project's content in markdown format.
	Content *string `json:"content,omitempty"`
	// [Internal] The project's content as YJS state.
	ContentState *string `json:"contentState,omitempty"`
	// [DEPRECATED] The type of the state.
	State string `json:"state"`
	// Metadata related to search result.
	Metadata string `json:"metadata"`
}

func (ProjectSearchResult) IsNode() {}

// The unique identifier of the entity.
func (this ProjectSearchResult) GetID() string { return this.ID }

type ProjectSearchResultConnection struct {
	Edges    []*ProjectSearchResultEdge `json:"edges"`
	Nodes    []*ProjectSearchResult     `json:"nodes"`
	PageInfo *PageInfo                  `json:"pageInfo"`
}

type ProjectSearchResultEdge struct {
	Node *ProjectSearchResult `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Issue project sorting options.
type ProjectSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// A project status.
type ProjectStatus struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the status.
	Name string `json:"name"`
	// The UI color of the status as a HEX string.
	Color string `json:"color"`
	// Description of the status.
	Description *string `json:"description,omitempty"`
	// The position of the status in the workspace's project flow.
	Position float64 `json:"position"`
	// The type of the project status.
	Type ProjectStatusType `json:"type"`
	// Whether or not a project can be in this status indefinitely.
	Indefinite bool `json:"indefinite"`
}

func (ProjectStatus) IsNode() {}

// The unique identifier of the entity.
func (this ProjectStatus) GetID() string { return this.ID }

type ProjectStatusConnection struct {
	Edges    []*ProjectStatusEdge `json:"edges"`
	Nodes    []*ProjectStatus     `json:"nodes"`
	PageInfo *PageInfo            `json:"pageInfo"`
}

type ProjectStatusEdge struct {
	Node *ProjectStatus `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Project status filtering options.
type ProjectStatusFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project status name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the project status description.
	Description *StringComparator `json:"description,omitempty"`
	// Comparator for the project status position.
	Position *NumberComparator `json:"position,omitempty"`
	// Comparator for the project status type.
	Type *StringComparator `json:"type,omitempty"`
	// Filters that the project status projects must satisfy.
	Projects *ProjectCollectionFilter `json:"projects,omitempty"`
	// Compound filters, all of which need to be matched by the project status.
	And []*ProjectStatusFilter `json:"and,omitempty"`
	// Compound filters, one of which needs to be matched by the project status.
	Or []*ProjectStatusFilter `json:"or,omitempty"`
}

// An update associated with a project.
type ProjectUpdate struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The update content in markdown format.
	Body string `json:"body"`
	// The project that the update is associated with.
	Project *Project `json:"project"`
	// The health of the project at the time of the update.
	Health ProjectUpdateHealthType `json:"health"`
	// The user who wrote the update.
	User *User `json:"user"`
	// The time the project update was edited.
	EditedAt *string `json:"editedAt,omitempty"`
	// Emoji reaction summary, grouped by emoji type.
	ReactionData string `json:"reactionData"`
	// [Internal] Serialized JSON representing current state of the project properties when posting the project update.
	InfoSnapshot *string `json:"infoSnapshot,omitempty"`
	// Whether project update diff should be hidden.
	IsDiffHidden bool `json:"isDiffHidden"`
	// [Internal] The content of the project update as a Prosemirror document.
	BodyData string `json:"bodyData"`
	// The project update's unique URL slug.
	SlugID string `json:"slugId"`
	// The URL to the project update.
	URL string `json:"url"`
	// The diff between the current update and the previous one.
	Diff *string `json:"diff,omitempty"`
	// The diff between the current update and the previous one, formatted as markdown.
	DiffMarkdown *string `json:"diffMarkdown,omitempty"`
	// Reactions associated with the project update.
	Reactions []*Reaction `json:"reactions"`
	// Comments associated with the project update.
	Comments *CommentConnection `json:"comments"`
}

func (ProjectUpdate) IsNode() {}

// The unique identifier of the entity.
func (this ProjectUpdate) GetID() string { return this.ID }

type ProjectUpdateConnection struct {
	Edges    []*ProjectUpdateEdge `json:"edges"`
	Nodes    []*ProjectUpdate     `json:"nodes"`
	PageInfo *PageInfo            `json:"pageInfo"`
}

type ProjectUpdateCreateInput struct {
	// The identifier. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The content of the project update in markdown format.
	Body *string `json:"body,omitempty"`
	// [Internal] The content of the project update as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The project to associate the project update with.
	ProjectID string `json:"projectId"`
	// The health of the project at the time of the update.
	Health *ProjectUpdateHealthType `json:"health,omitempty"`
	// Whether the diff between the current update and the previous one should be hidden.
	IsDiffHidden *bool `json:"isDiffHidden,omitempty"`
}

type ProjectUpdateEdge struct {
	Node *ProjectUpdate `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Options for filtering project updates.
type ProjectUpdateFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Filters that the project update creator must satisfy.
	User *UserFilter `json:"user,omitempty"`
	// Filters that the project update project must satisfy.
	Project *ProjectFilter `json:"project,omitempty"`
	// Filters that the project updates reactions must satisfy.
	Reactions *ReactionCollectionFilter `json:"reactions,omitempty"`
	// Compound filters, all of which need to be matched by the ProjectUpdate.
	And []*ProjectUpdateFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the ProjectUpdate.
	Or []*ProjectUpdateFilter `json:"or,omitempty"`
}

type ProjectUpdateInput struct {
	// [DEPRECATED] The state of the project.
	State *string `json:"state,omitempty"`
	// The ID of the project status.
	StatusID *string `json:"statusId,omitempty"`
	// The name of the project.
	Name *string `json:"name,omitempty"`
	// The description for the project.
	Description *string `json:"description,omitempty"`
	// The ID of the issue from which that project is created.
	ConvertedFromIssueID *string `json:"convertedFromIssueId,omitempty"`
	// The ID of the last template applied to the project.
	LastAppliedTemplateID *string `json:"lastAppliedTemplateId,omitempty"`
	// The icon of the project.
	Icon *string `json:"icon,omitempty"`
	// The color of the project.
	Color *string `json:"color,omitempty"`
	// The identifiers of the teams this project is associated with.
	TeamIds []string `json:"teamIds,omitempty"`
	// The time until which project update reminders are paused.
	ProjectUpdateRemindersPausedUntilAt *string `json:"projectUpdateRemindersPausedUntilAt,omitempty"`
	// The identifier of the project lead.
	LeadID *string `json:"leadId,omitempty"`
	// The identifiers of the members of this project.
	MemberIds []string `json:"memberIds,omitempty"`
	// The planned start date of the project.
	StartDate *string `json:"startDate,omitempty"`
	// [INTERNAL] The resolution of the project's start date.
	StartDateResolution *DateResolutionType `json:"startDateResolution,omitempty"`
	// The planned target date of the project.
	TargetDate *string `json:"targetDate,omitempty"`
	// [INTERNAL] The resolution of the project's estimated completion date.
	TargetDateResolution *DateResolutionType `json:"targetDateResolution,omitempty"`
	// The date when the project was completed.
	CompletedAt *string `json:"completedAt,omitempty"`
	// The date when the project was canceled.
	CanceledAt *string `json:"canceledAt,omitempty"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue,omitempty"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments,omitempty"`
	// Whether to send issue status update notifications to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses,omitempty"`
	// The sort order for the project in shared views.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// [ALPHA] The sort order for the project within shared views, when ordered by priority.
	PrioritySortOrder *float64 `json:"prioritySortOrder,omitempty"`
	// Whether the project has been trashed.
	Trashed *bool `json:"trashed,omitempty"`
	// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
	Priority *int64 `json:"priority,omitempty"`
}

// Holds information about when a user has interacted with a project update.
type ProjectUpdateInteraction struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that has interacted with the project update.
	User *User `json:"user"`
	// The project update that has been interacted with.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate"`
	// The time at which the user read the project update.
	ReadAt string `json:"readAt"`
}

func (ProjectUpdateInteraction) IsNode() {}

// The unique identifier of the entity.
func (this ProjectUpdateInteraction) GetID() string { return this.ID }

type ProjectUpdateInteractionConnection struct {
	Edges    []*ProjectUpdateInteractionEdge `json:"edges"`
	Nodes    []*ProjectUpdateInteraction     `json:"nodes"`
	PageInfo *PageInfo                       `json:"pageInfo"`
}

type ProjectUpdateInteractionCreateInput struct {
	// The identifier. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The id of the project update that has been interacted with.
	ProjectUpdateID string `json:"projectUpdateId"`
	// The time at which the user read the project update.
	ReadAt string `json:"readAt"`
}

type ProjectUpdateInteractionEdge struct {
	Node *ProjectUpdateInteraction `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type ProjectUpdateInteractionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project update interaction that was created or updated.
	ProjectUpdateInteraction *ProjectUpdateInteraction `json:"projectUpdateInteraction"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectUpdatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project update that was created or updated.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectUpdateReminderPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ProjectUpdateUpdateInput struct {
	// The content of the project update in markdown format.
	Body *string `json:"body,omitempty"`
	// The content of the project update as a Prosemirror document.
	BodyData *string `json:"bodyData,omitempty"`
	// The health of the project at the time of the update.
	Health *ProjectUpdateHealthType `json:"health,omitempty"`
	// Whether the diff between the current update and the previous one should be hidden.
	IsDiffHidden *bool `json:"isDiffHidden,omitempty"`
}

type ProjectUpdateWithInteractionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The project update that was created or updated.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The project update that was created or updated.
	Interaction *ProjectUpdateInteraction `json:"interaction"`
}

// Collection filtering options for filtering projects by project updates.
type ProjectUpdatesCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project update health.
	Health *StringComparator `json:"health,omitempty"`
	// Compound filters, all of which need to be matched by the project update.
	And []*ProjectUpdatesCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the update.
	Or []*ProjectUpdatesCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some updates.
	Some *ProjectUpdatesFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all updates.
	Every *ProjectUpdatesFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

// Options for filtering projects by project updates.
type ProjectUpdatesFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the project update health.
	Health *StringComparator `json:"health,omitempty"`
	// Compound filters, all of which need to be matched by the project updates.
	And []*ProjectUpdatesFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the project updates.
	Or []*ProjectUpdatesFilter `json:"or,omitempty"`
}

// A user's web or mobile push notification subscription.
type PushSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
}

func (PushSubscription) IsNode() {}

// The unique identifier of the entity.
func (this PushSubscription) GetID() string { return this.ID }

type PushSubscriptionConnection struct {
	Edges    []*PushSubscriptionEdge `json:"edges"`
	Nodes    []*PushSubscription     `json:"nodes"`
	PageInfo *PageInfo               `json:"pageInfo"`
}

type PushSubscriptionCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The user identifier of the subscription.
	UserID *string `json:"userId,omitempty"`
	// The data of the subscription in stringified JSON format.
	Data string `json:"data"`
	// Whether this is a subscription payload for Google Cloud Messaging or Apple Push Notification service.
	Type *PushSubscriptionType `json:"type,omitempty"`
}

type PushSubscriptionEdge struct {
	Node *PushSubscription `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type PushSubscriptionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The push subscription that was created or updated.
	Entity *PushSubscription `json:"entity"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type PushSubscriptionTestPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type Query struct {
}

type RateLimitPayload struct {
	// The identifier we rate limit on.
	Identifier *string `json:"identifier,omitempty"`
	// The kind of rate limit selected for this request.
	Kind string `json:"kind"`
	// The state of the rate limit.
	Limits []*RateLimitResultPayload `json:"limits"`
}

type RateLimitResultPayload struct {
	// What is being rate limited.
	Type string `json:"type"`
	// The requested quantity for this type of limit.
	RequestedAmount float64 `json:"requestedAmount"`
	// The total allowed quantity for this type of limit.
	AllowedAmount float64 `json:"allowedAmount"`
	// The period in which the rate limit is fully replenished in ms.
	Period float64 `json:"period"`
	// The remaining quantity for this type of limit after this request.
	RemainingAmount float64 `json:"remainingAmount"`
	// The timestamp after the rate limit is fully replenished as a UNIX timestamp.
	Reset float64 `json:"reset"`
}

// A reaction associated with a comment or a project update.
type Reaction struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Name of the reaction's emoji.
	Emoji string `json:"emoji"`
	// The issue that the reaction is associated with.
	Issue *Issue `json:"issue,omitempty"`
	// The comment that the reaction is associated with.
	Comment *Comment `json:"comment,omitempty"`
	// The project update that the reaction is associated with.
	ProjectUpdate *ProjectUpdate `json:"projectUpdate,omitempty"`
	// The user that created the reaction.
	User *User `json:"user,omitempty"`
	// The external user that created the reaction.
	ExternalUser *ExternalUser `json:"externalUser,omitempty"`
}

func (Reaction) IsNode() {}

// The unique identifier of the entity.
func (this Reaction) GetID() string { return this.ID }

// Reaction filtering options.
type ReactionCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the reactions emoji.
	Emoji *StringComparator `json:"emoji,omitempty"`
	// Comparator for the reactions custom emoji.
	CustomEmojiID *IDComparator `json:"customEmojiId,omitempty"`
	// Compound filters, all of which need to be matched by the reaction.
	And []*ReactionCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the reaction.
	Or []*ReactionCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some reactions.
	Some *ReactionFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all reactions.
	Every *ReactionFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type ReactionConnection struct {
	Edges    []*ReactionEdge `json:"edges"`
	Nodes    []*Reaction     `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type ReactionCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The emoji the user reacted with.
	Emoji string `json:"emoji"`
	// The comment to associate the reaction with.
	CommentID *string `json:"commentId,omitempty"`
	// The project update to associate the reaction with.
	ProjectUpdateID *string `json:"projectUpdateId,omitempty"`
	// The issue to associate the reaction with.
	IssueID *string `json:"issueId,omitempty"`
}

type ReactionEdge struct {
	Node *Reaction `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Reaction filtering options.
type ReactionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the reactions emoji.
	Emoji *StringComparator `json:"emoji,omitempty"`
	// Comparator for the reactions custom emoji.
	CustomEmojiID *IDComparator `json:"customEmojiId,omitempty"`
	// Compound filters, all of which need to be matched by the reaction.
	And []*ReactionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the reaction.
	Or []*ReactionFilter `json:"or,omitempty"`
}

type ReactionPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64   `json:"lastSyncId"`
	Reaction   *Reaction `json:"reaction"`
	Success    bool      `json:"success"`
}

// Comparator for relation existence.
type RelationExistsComparator struct {
	// Equals constraint.
	Eq *bool `json:"eq,omitempty"`
	// Not equals constraint.
	Neq *bool `json:"neq,omitempty"`
}

// A reminder that can be attached to different entities.
type Reminder struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that created a reminder.
	User *User `json:"user"`
	// The time when a reminder triggers a notification in the user's inbox.
	RemindAt *string `json:"remindAt,omitempty"`
	// Scheduling settings for recurring reminders.
	Schedule *string `json:"schedule,omitempty"`
	// The reminder's comment.
	Comment *string `json:"comment,omitempty"`
	// The issue that the reminder is associated with.
	IssueID *Issue `json:"issueId,omitempty"`
	// The document that the reminder is associated with.
	DocumentID *Document `json:"documentId,omitempty"`
	// The project that the reminder is associated with.
	ProjectID *Project `json:"projectId,omitempty"`
}

func (Reminder) IsNode() {}

// The unique identifier of the entity.
func (this Reminder) GetID() string { return this.ID }

// Customer revenue sorting options.
type RevenueSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// A roadmap for projects.
type Roadmap struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the roadmap.
	Name string `json:"name"`
	// The description of the roadmap.
	Description *string `json:"description,omitempty"`
	// The organization of the roadmap.
	Organization *Organization `json:"organization"`
	// The user who created the roadmap.
	Creator *User `json:"creator"`
	// The user who owns the roadmap.
	Owner *User `json:"owner"`
	// The roadmap's unique URL slug.
	SlugID string `json:"slugId"`
	// The sort order of the roadmap within the organization.
	SortOrder float64 `json:"sortOrder"`
	// The roadmap's color.
	Color *string `json:"color,omitempty"`
	// Projects associated with the roadmap.
	Projects *ProjectConnection `json:"projects"`
	// The canonical url for the roadmap.
	URL string `json:"url"`
}

func (Roadmap) IsNode() {}

// The unique identifier of the entity.
func (this Roadmap) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type RoadmapArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Roadmap `json:"entity,omitempty"`
}

func (RoadmapArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this RoadmapArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this RoadmapArchivePayload) GetSuccess() bool { return this.Success }

// Roadmap collection filtering options.
type RoadmapCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the roadmap name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the roadmap slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Filters that the roadmap creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Compound filters, all of which need to be matched by the roadmap.
	And []*RoadmapCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the roadmap.
	Or []*RoadmapCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some roadmaps.
	Some *RoadmapFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all roadmaps.
	Every *RoadmapFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type RoadmapConnection struct {
	Edges    []*RoadmapEdge `json:"edges"`
	Nodes    []*Roadmap     `json:"nodes"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

type RoadmapCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the roadmap.
	Name string `json:"name"`
	// The description of the roadmap.
	Description *string `json:"description,omitempty"`
	// The owner of the roadmap.
	OwnerID *string `json:"ownerId,omitempty"`
	// The sort order of the roadmap within the organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// The roadmap's color.
	Color *string `json:"color,omitempty"`
}

type RoadmapEdge struct {
	Node *Roadmap `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Roadmap filtering options.
type RoadmapFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the roadmap name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the roadmap slug ID.
	SlugID *StringComparator `json:"slugId,omitempty"`
	// Filters that the roadmap creator must satisfy.
	Creator *UserFilter `json:"creator,omitempty"`
	// Compound filters, all of which need to be matched by the roadmap.
	And []*RoadmapFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the roadmap.
	Or []*RoadmapFilter `json:"or,omitempty"`
}

type RoadmapPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The roadmap that was created or updated.
	Roadmap *Roadmap `json:"roadmap"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Join table between projects and roadmaps.
type RoadmapToProject struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The project that the roadmap is associated with.
	Project *Project `json:"project"`
	// The roadmap that the project is associated with.
	Roadmap *Roadmap `json:"roadmap"`
	// The sort order of the project within the roadmap.
	SortOrder string `json:"sortOrder"`
}

func (RoadmapToProject) IsNode() {}

// The unique identifier of the entity.
func (this RoadmapToProject) GetID() string { return this.ID }

type RoadmapToProjectConnection struct {
	Edges    []*RoadmapToProjectEdge `json:"edges"`
	Nodes    []*RoadmapToProject     `json:"nodes"`
	PageInfo *PageInfo               `json:"pageInfo"`
}

type RoadmapToProjectCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the project.
	ProjectID string `json:"projectId"`
	// The identifier of the roadmap.
	RoadmapID string `json:"roadmapId"`
	// The sort order for the project within its organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type RoadmapToProjectEdge struct {
	Node *RoadmapToProject `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type RoadmapToProjectPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The roadmapToProject that was created or updated.
	RoadmapToProject *RoadmapToProject `json:"roadmapToProject"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type RoadmapToProjectUpdateInput struct {
	// The sort order for the project within its organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type RoadmapUpdateInput struct {
	// The name of the roadmap.
	Name *string `json:"name,omitempty"`
	// The description of the roadmap.
	Description *string `json:"description,omitempty"`
	// The owner of the roadmap.
	OwnerID *string `json:"ownerId,omitempty"`
	// The sort order of the roadmap within the organization.
	SortOrder *float64 `json:"sortOrder,omitempty"`
	// The roadmap's color.
	Color *string `json:"color,omitempty"`
}

// Sentry specific settings.
type SentrySettings struct {
	// The slug of the Sentry organization being connected.
	OrganizationSlug string `json:"organizationSlug"`
}

type SentrySettingsInput struct {
	// The slug of the Sentry organization being connected.
	OrganizationSlug string `json:"organizationSlug"`
}

// Shared Slack integration settings.
type SharedSlackSettings struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
}

type SharedSlackSettingsInput struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
}

// Customer size sorting options.
type SizeSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// Comparator for sla status.
type SLAStatusComparator struct {
	// Equals constraint.
	Eq *SLAStatus `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *SLAStatus `json:"neq,omitempty"`
	// In-array constraint.
	In []SLAStatus `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []SLAStatus `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

// Issue SLA status sorting options.
type SLAStatusSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// Slack Asks specific settings.
type SlackAsksSettings struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
	// The mapping of Slack channel ID => Slack channel name for connected channels.
	SlackChannelMapping []*SlackChannelNameMapping `json:"slackChannelMapping,omitempty"`
	// The user role type that is allowed to manage Asks settings.
	CanAdministrate UserRoleType `json:"canAdministrate"`
}

type SlackAsksSettingsInput struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
	// The mapping of Slack channel ID => Slack channel name for connected channels.
	SlackChannelMapping []*SlackChannelNameMappingInput `json:"slackChannelMapping,omitempty"`
	// The user role type that is allowed to manage Asks settings.
	CanAdministrate UserRoleType `json:"canAdministrate"`
}

// Tuple for mapping Slack channel IDs to names.
type SlackAsksTeamSettings struct {
	// The Linear team ID.
	ID string `json:"id"`
	// Whether the default Asks template is enabled in the given channel for this team.
	HasDefaultAsk bool `json:"hasDefaultAsk"`
}

type SlackAsksTeamSettingsInput struct {
	// The Linear team ID.
	ID string `json:"id"`
	// Whether the default Asks template is enabled in the given channel for this team.
	HasDefaultAsk bool `json:"hasDefaultAsk"`
}

type SlackChannelConnectPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The integration that was created or updated.
	Integration *Integration `json:"integration,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// Whether the bot needs to be manually added to the channel.
	AddBot bool `json:"addBot"`
	// Whether it's recommended to connect main Slack integration.
	NudgeToConnectMainSlackIntegration *bool `json:"nudgeToConnectMainSlackIntegration,omitempty"`
	// Whether it's recommended to update main Slack integration.
	NudgeToUpdateMainSlackIntegration *bool `json:"nudgeToUpdateMainSlackIntegration,omitempty"`
}

// Object for mapping Slack channel IDs to names and other settings.
type SlackChannelNameMapping struct {
	// The Slack channel ID.
	ID string `json:"id"`
	// The Slack channel name.
	Name string `json:"name"`
	// Whether or not the Slack channel is private.
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// Whether or not the Slack channel is shared with an external org.
	IsShared *bool `json:"isShared,omitempty"`
	// Whether or not the Linear Asks bot has been added to this Slack channel.
	BotAdded *bool `json:"botAdded,omitempty"`
	// Which teams are connected to the channel and settings for those teams.
	Teams []*SlackAsksTeamSettings `json:"teams"`
	// Whether or not top-level messages in this channel should automatically create Asks.
	AutoCreateOnMessage *bool `json:"autoCreateOnMessage,omitempty"`
	// Whether or not using the :ticket: emoji in this channel should automatically create Asks.
	AutoCreateOnEmoji *bool `json:"autoCreateOnEmoji,omitempty"`
	// Whether or not @-mentioning the bot should automatically create an Ask with the message.
	AutoCreateOnBotMention *bool `json:"autoCreateOnBotMention,omitempty"`
	// The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
	AutoCreateTemplateID *string `json:"autoCreateTemplateId,omitempty"`
	// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
	PostCancellationUpdates *bool `json:"postCancellationUpdates,omitempty"`
	// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
	PostCompletionUpdates *bool `json:"postCompletionUpdates,omitempty"`
	// Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
	PostAcceptedFromTriageUpdates *bool `json:"postAcceptedFromTriageUpdates,omitempty"`
}

type SlackChannelNameMappingInput struct {
	// The Slack channel ID.
	ID string `json:"id"`
	// The Slack channel name.
	Name string `json:"name"`
	// Whether or not the Slack channel is private.
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// Whether or not the Slack channel is shared with an external org.
	IsShared *bool `json:"isShared,omitempty"`
	// Whether or not the Linear Asks bot has been added to this Slack channel.
	BotAdded *bool `json:"botAdded,omitempty"`
	// Which teams are connected to the channel and settings for those teams.
	Teams []*SlackAsksTeamSettingsInput `json:"teams"`
	// Whether or not top-level messages in this channel should automatically create Asks.
	AutoCreateOnMessage *bool `json:"autoCreateOnMessage,omitempty"`
	// Whether or not using the :ticket: emoji in this channel should automatically create Asks.
	AutoCreateOnEmoji *bool `json:"autoCreateOnEmoji,omitempty"`
	// Whether or not @-mentioning the bot should automatically create an Ask with the message.
	AutoCreateOnBotMention *bool `json:"autoCreateOnBotMention,omitempty"`
	// The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
	AutoCreateTemplateID *string `json:"autoCreateTemplateId,omitempty"`
	// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
	PostCancellationUpdates *bool `json:"postCancellationUpdates,omitempty"`
	// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
	PostCompletionUpdates *bool `json:"postCompletionUpdates,omitempty"`
	// Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
	PostAcceptedFromTriageUpdates *bool `json:"postAcceptedFromTriageUpdates,omitempty"`
}

// Slack notification specific settings.
type SlackPostSettings struct {
	Channel          string            `json:"channel"`
	ChannelID        string            `json:"channelId"`
	ConfigurationURL string            `json:"configurationUrl"`
	ChannelType      *SlackChannelType `json:"channelType,omitempty"`
}

type SlackPostSettingsInput struct {
	Channel          string            `json:"channel"`
	ChannelID        string            `json:"channelId"`
	ConfigurationURL string            `json:"configurationUrl"`
	ChannelType      *SlackChannelType `json:"channelType,omitempty"`
}

// Settings for the regular Slack integration.
type SlackSettings struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
	// Whether Linear should automatically respond with issue unfurls when an issue identifier is mentioned in a Slack message.
	LinkOnIssueIDMention bool `json:"linkOnIssueIdMention"`
}

type SlackSettingsInput struct {
	// Slack workspace name
	TeamName *string `json:"teamName,omitempty"`
	// Slack workspace id
	TeamID *string `json:"teamId,omitempty"`
	// Enterprise name of the connected Slack enterprise
	EnterpriseName *string `json:"enterpriseName,omitempty"`
	// Enterprise id of the connected Slack enterprise
	EnterpriseID *string `json:"enterpriseId,omitempty"`
	// Whether to show unfurl previews in Slack
	ShouldUnfurl *bool `json:"shouldUnfurl,omitempty"`
	// Whether Linear should automatically respond with issue unfurls when an issue identifier is mentioned in a Slack message.
	LinkOnIssueIDMention bool `json:"linkOnIssueIdMention"`
}

// Comparator for issue source type.
type SourceMetadataComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
	// Compound filters, all of which need to be matched by the sub type.
	SubType *SubTypeComparator `json:"subType,omitempty"`
}

// Comparator for `sourceType` field.
type SourceTypeComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
	// Starts with case insensitive constraint. Matches any values that start with the given string.
	StartsWithIgnoreCase *string `json:"startsWithIgnoreCase,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
}

type SsoURLFromEmailResponse struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
	// SAML SSO sign-in URL.
	SamlSsoURL string `json:"samlSsoUrl"`
}

// Comparator for strings.
type StringArrayComparator struct {
	// Length of the array. Matches any values that have the given length.
	Length *NumberComparator `json:"length,omitempty"`
	// Compound filters, all of which need to be matched.
	Every []*StringItemComparator `json:"every,omitempty"`
	// Compound filters, one of which needs to be matched.
	Some []*StringItemComparator `json:"some,omitempty"`
}

// Comparator for strings.
type StringComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
	// Starts with case insensitive constraint. Matches any values that start with the given string.
	StartsWithIgnoreCase *string `json:"startsWithIgnoreCase,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
}

// Comparator for strings in arrays.
type StringItemComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Equals case insensitive. Matches any values that matches the given string case insensitive.
	EqIgnoreCase *string `json:"eqIgnoreCase,omitempty"`
	// Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
	NeqIgnoreCase *string `json:"neqIgnoreCase,omitempty"`
	// Starts with constraint. Matches any values that start with the given string.
	StartsWith *string `json:"startsWith,omitempty"`
	// Starts with case insensitive constraint. Matches any values that start with the given string.
	StartsWithIgnoreCase *string `json:"startsWithIgnoreCase,omitempty"`
	// Doesn't start with constraint. Matches any values that don't start with the given string.
	NotStartsWith *string `json:"notStartsWith,omitempty"`
	// Ends with constraint. Matches any values that end with the given string.
	EndsWith *string `json:"endsWith,omitempty"`
	// Doesn't end with constraint. Matches any values that don't end with the given string.
	NotEndsWith *string `json:"notEndsWith,omitempty"`
	// Contains constraint. Matches any values that contain the given string.
	Contains *string `json:"contains,omitempty"`
	// Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
	ContainsIgnoreCase *string `json:"containsIgnoreCase,omitempty"`
	// Doesn't contain constraint. Matches any values that don't contain the given string.
	NotContains *string `json:"notContains,omitempty"`
	// Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
	NotContainsIgnoreCase *string `json:"notContainsIgnoreCase,omitempty"`
}

// Comparator for source type.
type SubTypeComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
	Null *bool `json:"null,omitempty"`
}

type SuccessPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type SummaryPayload struct {
	// Summary for project updates.
	Summary string `json:"summary"`
}

type SynchronizedPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
}

// An organizational unit that contains issues.
type Team struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The team's name.
	Name string `json:"name"`
	// The team's unique key. The key is used in URLs.
	Key string `json:"key"`
	// The team's description.
	Description *string `json:"description,omitempty"`
	// The icon of the team.
	Icon *string `json:"icon,omitempty"`
	// The team's color.
	Color *string `json:"color,omitempty"`
	// The organization that the team is associated with.
	Organization *Organization `json:"organization"`
	// Whether the team uses cycles.
	CyclesEnabled bool `json:"cyclesEnabled"`
	// The day of the week that a new cycle starts.
	CycleStartDay float64 `json:"cycleStartDay"`
	// The duration of a cycle in weeks.
	CycleDuration float64 `json:"cycleDuration"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime float64 `json:"cycleCooldownTime"`
	// Auto assign started issues to current cycle.
	CycleIssueAutoAssignStarted bool `json:"cycleIssueAutoAssignStarted"`
	// Auto assign completed issues to current cycle.
	CycleIssueAutoAssignCompleted bool `json:"cycleIssueAutoAssignCompleted"`
	// Auto assign issues to current cycle if in active status.
	CycleLockToActive bool `json:"cycleLockToActive"`
	// How many upcoming cycles to create.
	UpcomingCycleCount float64 `json:"upcomingCycleCount"`
	// The timezone of the team. Defaults to "America/Los_Angeles"
	Timezone string `json:"timezone"`
	// Unique hash for the team to be used in invite URLs.
	InviteHash string `json:"inviteHash"`
	// The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
	IssueEstimationType string `json:"issueEstimationType"`
	// [DEPRECATED] Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst bool `json:"issueOrderingNoPriorityFirst"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero bool `json:"issueEstimationAllowZero"`
	// Where to move issues when changing state.
	SetIssueSortOrderOnStateChange string `json:"setIssueSortOrderOnStateChange"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended bool `json:"issueEstimationExtended"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate float64 `json:"defaultIssueEstimate"`
	// Whether triage mode is enabled for the team or not.
	TriageEnabled bool `json:"triageEnabled"`
	// Whether an issue needs to have a priority set before leaving triage.
	RequirePriorityToLeaveTriage bool `json:"requirePriorityToLeaveTriage"`
	// The default workflow state into which issues are set when they are opened by team members.
	DefaultIssueState *WorkflowState `json:"defaultIssueState,omitempty"`
	// The default template to use for new issues created by members of the team.
	DefaultTemplateForMembers *Template `json:"defaultTemplateForMembers,omitempty"`
	// The id of the default template to use for new issues created by members of the team.
	DefaultTemplateForMembersID *string `json:"defaultTemplateForMembersId,omitempty"`
	// The default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembers *Template `json:"defaultTemplateForNonMembers,omitempty"`
	// The id of the default template to use for new issues created by non-members of the team.
	DefaultTemplateForNonMembersID *string `json:"defaultTemplateForNonMembersId,omitempty"`
	// The default template to use for new projects created for the team.
	DefaultProjectTemplate *Template `json:"defaultProjectTemplate,omitempty"`
	// The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
	TriageIssueState *WorkflowState `json:"triageIssueState,omitempty"`
	// Whether the team is private or not.
	Private bool `json:"private"`
	// Whether the team is managed by SCIM integration.
	ScimManaged bool `json:"scimManaged"`
	// The SCIM group name for the team.
	ScimGroupName *string `json:"scimGroupName,omitempty"`
	// [Internal] The progress history of the team.
	ProgressHistory string `json:"progressHistory"`
	// [Internal] The current progress of the team.
	CurrentProgress string `json:"currentProgress"`
	// The workflow state into which issues are moved when a PR has been opened as draft.
	DraftWorkflowState *WorkflowState `json:"draftWorkflowState,omitempty"`
	// The workflow state into which issues are moved when a PR has been opened.
	StartWorkflowState *WorkflowState `json:"startWorkflowState,omitempty"`
	// The workflow state into which issues are moved when a review has been requested for the PR.
	ReviewWorkflowState *WorkflowState `json:"reviewWorkflowState,omitempty"`
	// The workflow state into which issues are moved when a PR is ready to be merged.
	MergeableWorkflowState *WorkflowState `json:"mergeableWorkflowState,omitempty"`
	// The workflow state into which issues are moved when a PR has been merged.
	MergeWorkflowState *WorkflowState `json:"mergeWorkflowState,omitempty"`
	// Whether to group recent issue history entries.
	GroupIssueHistory bool `json:"groupIssueHistory"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue bool `json:"slackNewIssue"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments bool `json:"slackIssueComments"`
	// Whether to send new issue status updates to Slack.
	SlackIssueStatuses bool `json:"slackIssueStatuses"`
	// Period after which issues are automatically closed in months. Null/undefined means disabled.
	AutoClosePeriod *float64 `json:"autoClosePeriod,omitempty"`
	// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
	AutoCloseStateID *string `json:"autoCloseStateId,omitempty"`
	// Period after which automatically closed and completed issues are automatically archived in months.
	AutoArchivePeriod float64 `json:"autoArchivePeriod"`
	// Whether parent issues should automatically close when all child issues are closed
	AutoCloseParentIssues *bool `json:"autoCloseParentIssues,omitempty"`
	// Whether child issues should automatically close when their parent issue is closed
	AutoCloseChildIssues *bool `json:"autoCloseChildIssues,omitempty"`
	// The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
	MarkedAsDuplicateWorkflowState *WorkflowState `json:"markedAsDuplicateWorkflowState,omitempty"`
	// [INTERNAL] Whether new users should join this team by default.
	JoinByDefault *bool `json:"joinByDefault,omitempty"`
	// Calendar feed URL (iCal) for cycles.
	CycleCalenderURL string `json:"cycleCalenderUrl"`
	// Issues associated with the team.
	Issues *IssueConnection `json:"issues"`
	// Number of issues in the team.
	IssueCount int64 `json:"issueCount"`
	// Cycles associated with the team.
	Cycles *CycleConnection `json:"cycles"`
	// Team's currently active cycle.
	ActiveCycle *Cycle `json:"activeCycle,omitempty"`
	// Team's triage responsibility.
	TriageResponsibility *TriageResponsibility `json:"triageResponsibility,omitempty"`
	// Users who are members of this team.
	Members *UserConnection `json:"members"`
	// [ALPHA] The membership of the given user in the team.
	Membership *TeamMembership `json:"membership,omitempty"`
	// Memberships associated with the team. For easier access of the same data, use `members` query.
	Memberships *TeamMembershipConnection `json:"memberships"`
	// Projects associated with the team.
	Projects *ProjectConnection `json:"projects"`
	// The states that define the workflow associated with the team.
	States *WorkflowStateConnection `json:"states"`
	// The Git automation states for the team.
	GitAutomationStates *GitAutomationStateConnection `json:"gitAutomationStates"`
	// Templates associated with the team.
	Templates *TemplateConnection `json:"templates"`
	// Labels associated with the team.
	Labels *IssueLabelConnection `json:"labels"`
	// Webhooks associated with the team.
	Webhooks *WebhookConnection `json:"webhooks"`
	// Settings for all integrations associated with that team.
	IntegrationsSettings *IntegrationsSettings `json:"integrationsSettings,omitempty"`
	// [DEPRECATED] Whether to move issues to bottom of the column when changing state.
	IssueSortOrderDefaultToBottom bool `json:"issueSortOrderDefaultToBottom"`
}

func (Team) IsNode() {}

// The unique identifier of the entity.
func (this Team) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type TeamArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *Team `json:"entity,omitempty"`
}

func (TeamArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this TeamArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this TeamArchivePayload) GetSuccess() bool { return this.Success }

// Roadmap collection filtering options.
type TeamCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Compound filters, all of which need to be matched by the roadmap.
	And []*TeamCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the roadmap.
	Or []*TeamCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some roadmaps.
	Some *TeamFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all roadmaps.
	Every *TeamFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type TeamConnection struct {
	Edges    []*TeamEdge `json:"edges"`
	Nodes    []*Team     `json:"nodes"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type TeamCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the team.
	Name string `json:"name"`
	// The description of the team.
	Description *string `json:"description,omitempty"`
	// The key of the team. If not given, the key will be generated based on the name of the team.
	Key *string `json:"key,omitempty"`
	// The icon of the team.
	Icon *string `json:"icon,omitempty"`
	// The color of the team.
	Color *string `json:"color,omitempty"`
	// The organization associated with the team.
	OrganizationID *string `json:"organizationId,omitempty"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled,omitempty"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay,omitempty"`
	// The duration of each cycle in weeks.
	CycleDuration *int64 `json:"cycleDuration,omitempty"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *int64 `json:"cycleCooldownTime,omitempty"`
	// Auto assign started issues to current active cycle setting.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted,omitempty"`
	// Auto assign completed issues to current active cycle setting.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted,omitempty"`
	// Only allow issues issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive,omitempty"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount,omitempty"`
	// Whether triage mode is enabled for the team.
	TriageEnabled *bool `json:"triageEnabled,omitempty"`
	// Whether an issue needs to have a priority set before leaving triage.
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage,omitempty"`
	// The timezone of the team.
	Timezone *string `json:"timezone,omitempty"`
	// [DEPRECATED] Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst,omitempty"`
	// The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
	IssueEstimationType *string `json:"issueEstimationType,omitempty"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero,omitempty"`
	// Whether to move issues to bottom of the column when changing state.
	SetIssueSortOrderOnStateChange *string `json:"setIssueSortOrderOnStateChange,omitempty"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended,omitempty"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate,omitempty"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory,omitempty"`
	// The identifier of the default template for members of this team.
	DefaultTemplateForMembersID *string `json:"defaultTemplateForMembersId,omitempty"`
	// The identifier of the default template for non-members of this team.
	DefaultTemplateForNonMembersID *string `json:"defaultTemplateForNonMembersId,omitempty"`
	// The identifier of the default project template of this team.
	DefaultProjectTemplateID *string `json:"defaultProjectTemplateId,omitempty"`
	// Internal. Whether the team is private or not.
	Private *bool `json:"private,omitempty"`
	// Period after which issues are automatically closed, in months.
	AutoClosePeriod *float64 `json:"autoClosePeriod,omitempty"`
	// The canceled workflow state which auto closed issues will be set to.
	AutoCloseStateID *string `json:"autoCloseStateId,omitempty"`
	// Period after which closed and completed issues are automatically archived, in months. 0 means disabled.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod,omitempty"`
	// The workflow state into which issues are moved when they are marked as a duplicate of another issue.
	MarkedAsDuplicateWorkflowStateID *string `json:"markedAsDuplicateWorkflowStateId,omitempty"`
	// The parent team ID.
	ParentID *string `json:"parentId,omitempty"`
}

type TeamEdge struct {
	Node *Team `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Team filtering options.
type TeamFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the team name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the team key.
	Key *StringComparator `json:"key,omitempty"`
	// Comparator for the team description.
	Description *NullableStringComparator `json:"description,omitempty"`
	// Filters that the teams issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Compound filters, all of which need to be matched by the team.
	And []*TeamFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the team.
	Or []*TeamFilter `json:"or,omitempty"`
}

// Defines the membership of a user to a team.
type TeamMembership struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that the membership is associated with.
	User *User `json:"user"`
	// The team that the membership is associated with.
	Team *Team `json:"team"`
	// Whether the user is the owner of the team.
	Owner bool `json:"owner"`
	// The order of the item in the users team list.
	SortOrder float64 `json:"sortOrder"`
}

func (TeamMembership) IsNode() {}

// The unique identifier of the entity.
func (this TeamMembership) GetID() string { return this.ID }

type TeamMembershipConnection struct {
	Edges    []*TeamMembershipEdge `json:"edges"`
	Nodes    []*TeamMembership     `json:"nodes"`
	PageInfo *PageInfo             `json:"pageInfo"`
}

type TeamMembershipCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the user associated with the membership.
	UserID string `json:"userId"`
	// The identifier of the team associated with the membership.
	TeamID string `json:"teamId"`
	// Internal. Whether the user is the owner of the team.
	Owner *bool `json:"owner,omitempty"`
	// The position of the item in the users list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type TeamMembershipEdge struct {
	Node *TeamMembership `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type TeamMembershipPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The team membership that was created or updated.
	TeamMembership *TeamMembership `json:"teamMembership,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type TeamMembershipUpdateInput struct {
	// Internal. Whether the user is the owner of the team.
	Owner *bool `json:"owner,omitempty"`
	// The position of the item in the users list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

// A team notification subscription.
type TeamNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team subscribed to.
	Team *Team `json:"team"`
	// The user view associated with the notification subscription.
	User *User `json:"user,omitempty"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (TeamNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this TeamNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this TeamNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this TeamNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this TeamNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (TeamNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (TeamNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this TeamNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this TeamNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this TeamNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this TeamNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this TeamNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this TeamNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this TeamNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this TeamNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this TeamNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this TeamNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this TeamNotificationSubscription) GetActive() bool { return this.Active }

type TeamPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The team that was created or updated.
	Team *Team `json:"team,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Issue team sorting options.
type TeamSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type TeamUpdateInput struct {
	// The name of the team.
	Name *string `json:"name,omitempty"`
	// The description of the team.
	Description *string `json:"description,omitempty"`
	// The key of the team.
	Key *string `json:"key,omitempty"`
	// The icon of the team.
	Icon *string `json:"icon,omitempty"`
	// The color of the team.
	Color *string `json:"color,omitempty"`
	// Whether the team uses cycles.
	CyclesEnabled *bool `json:"cyclesEnabled,omitempty"`
	// The day of the week that a new cycle starts.
	CycleStartDay *float64 `json:"cycleStartDay,omitempty"`
	// The duration of each cycle in weeks.
	CycleDuration *int64 `json:"cycleDuration,omitempty"`
	// The cooldown time after each cycle in weeks.
	CycleCooldownTime *int64 `json:"cycleCooldownTime,omitempty"`
	// Auto assign started issues to current active cycle setting.
	CycleIssueAutoAssignStarted *bool `json:"cycleIssueAutoAssignStarted,omitempty"`
	// Auto assign completed issues to current active cycle setting.
	CycleIssueAutoAssignCompleted *bool `json:"cycleIssueAutoAssignCompleted,omitempty"`
	// Only allow issues with cycles in Active Issues.
	CycleLockToActive *bool `json:"cycleLockToActive,omitempty"`
	// [DEPRECATED] Whether the first cycle should start in the current or the next week.
	CycleEnabledStartWeek *string `json:"cycleEnabledStartWeek,omitempty"`
	// The date to begin cycles on.
	CycleEnabledStartDate *string `json:"cycleEnabledStartDate,omitempty"`
	// How many upcoming cycles to create.
	UpcomingCycleCount *float64 `json:"upcomingCycleCount,omitempty"`
	// The timezone of the team.
	Timezone *string `json:"timezone,omitempty"`
	// [DEPRECATED] Whether issues without priority should be sorted first.
	IssueOrderingNoPriorityFirst *bool `json:"issueOrderingNoPriorityFirst,omitempty"`
	// The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
	IssueEstimationType *string `json:"issueEstimationType,omitempty"`
	// Whether to allow zeros in issues estimates.
	IssueEstimationAllowZero *bool `json:"issueEstimationAllowZero,omitempty"`
	// Whether to move issues to bottom of the column when changing state.
	SetIssueSortOrderOnStateChange *string `json:"setIssueSortOrderOnStateChange,omitempty"`
	// Whether to add additional points to the estimate scale.
	IssueEstimationExtended *bool `json:"issueEstimationExtended,omitempty"`
	// What to use as an default estimate for unestimated issues.
	DefaultIssueEstimate *float64 `json:"defaultIssueEstimate,omitempty"`
	// The workflow state into which issues are moved when a draft PR has been opened.
	DraftWorkflowStateID *string `json:"draftWorkflowStateId,omitempty"`
	// The workflow state into which issues are moved when a PR has been opened.
	StartWorkflowStateID *string `json:"startWorkflowStateId,omitempty"`
	// The workflow state into which issues are moved when a review has been requested for the PR.
	ReviewWorkflowStateID *string `json:"reviewWorkflowStateId,omitempty"`
	// The workflow state into which issues are moved when a PR is ready to be merged.
	MergeableWorkflowStateID *string `json:"mergeableWorkflowStateId,omitempty"`
	// The workflow state into which issues are moved when a PR has been merged.
	MergeWorkflowStateID *string `json:"mergeWorkflowStateId,omitempty"`
	// Whether to send new issue notifications to Slack.
	SlackNewIssue *bool `json:"slackNewIssue,omitempty"`
	// Whether to send new issue comment notifications to Slack.
	SlackIssueComments *bool `json:"slackIssueComments,omitempty"`
	// Whether to send issue status update notifications to Slack.
	SlackIssueStatuses *bool `json:"slackIssueStatuses,omitempty"`
	// Whether to group recent issue history entries.
	GroupIssueHistory *bool `json:"groupIssueHistory,omitempty"`
	// The identifier of the default template for members of this team.
	DefaultTemplateForMembersID *string `json:"defaultTemplateForMembersId,omitempty"`
	// The identifier of the default template for non-members of this team.
	DefaultTemplateForNonMembersID *string `json:"defaultTemplateForNonMembersId,omitempty"`
	// The identifier of the default project template of this team.
	DefaultProjectTemplateID *string `json:"defaultProjectTemplateId,omitempty"`
	// Whether the team is private or not.
	Private *bool `json:"private,omitempty"`
	// Whether triage mode is enabled for the team.
	TriageEnabled *bool `json:"triageEnabled,omitempty"`
	// Whether an issue needs to have a priority set before leaving triage.
	RequirePriorityToLeaveTriage *bool `json:"requirePriorityToLeaveTriage,omitempty"`
	// Default status for newly created issues.
	DefaultIssueStateID *string `json:"defaultIssueStateId,omitempty"`
	// Period after which issues are automatically closed, in months.
	AutoClosePeriod *float64 `json:"autoClosePeriod,omitempty"`
	// The canceled workflow state which auto closed issues will be set to.
	AutoCloseStateID *string `json:"autoCloseStateId,omitempty"`
	// [INTERNAL] Whether to automatically close a parent issue in this team if all its sub-issues are closed.
	AutoCloseParentIssues *bool `json:"autoCloseParentIssues,omitempty"`
	// [INTERNAL] Whether to automatically close all sub-issues when a parent issue in this team is closed.
	AutoCloseChildIssues *bool `json:"autoCloseChildIssues,omitempty"`
	// Period after which closed and completed issues are automatically archived, in months.
	AutoArchivePeriod *float64 `json:"autoArchivePeriod,omitempty"`
	// The workflow state into which issues are moved when they are marked as a duplicate of another issue.
	MarkedAsDuplicateWorkflowStateID *string `json:"markedAsDuplicateWorkflowStateId,omitempty"`
	// Whether new users should join this team by default. Mutation restricted to workspace admins!
	JoinByDefault *bool `json:"joinByDefault,omitempty"`
	// Whether the team is managed by SCIM integration. Mutation restricted to workspace admins and only unsetting is allowed!
	ScimManaged *bool `json:"scimManaged,omitempty"`
	// The parent team ID.
	ParentID *string `json:"parentId,omitempty"`
}

// A template object used for creating entities faster.
type Template struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The entity type this template is for.
	Type string `json:"type"`
	// The name of the template.
	Name string `json:"name"`
	// Template description.
	Description *string `json:"description,omitempty"`
	// Template data.
	TemplateData string `json:"templateData"`
	// The sort order of the template.
	SortOrder float64 `json:"sortOrder"`
	// The organization that the template is associated with. If null, the template is associated with a particular team.
	Organization *Organization `json:"organization,omitempty"`
	// The team that the template is associated with. If null, the template is global to the workspace.
	Team *Team `json:"team,omitempty"`
	// The user who created the template.
	Creator *User `json:"creator,omitempty"`
	// The user who last updated the template.
	LastUpdatedBy *User `json:"lastUpdatedBy,omitempty"`
}

func (Template) IsNode() {}

// The unique identifier of the entity.
func (this Template) GetID() string { return this.ID }

type TemplateConnection struct {
	Edges    []*TemplateEdge `json:"edges"`
	Nodes    []*Template     `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type TemplateCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The template type, e.g. 'issue'.
	Type string `json:"type"`
	// The identifier or key of the team associated with the template. If not given, the template will be shared across all teams.
	TeamID *string `json:"teamId,omitempty"`
	// The template name.
	Name string `json:"name"`
	// The template description.
	Description *string `json:"description,omitempty"`
	// The template data as JSON encoded attributes of the type of entity, such as an issue.
	TemplateData string `json:"templateData"`
	// The position of the template in the templates list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

type TemplateEdge struct {
	Node *Template `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type TemplatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The template that was created or updated.
	Template *Template `json:"template"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type TemplateUpdateInput struct {
	// The template name.
	Name *string `json:"name,omitempty"`
	// The template description.
	Description *string `json:"description,omitempty"`
	// The identifier or key of the team associated with the template. If set to null, the template will be shared across all teams.
	TeamID *string `json:"teamId,omitempty"`
	// The template data as JSON encoded attributes of the type of entity, such as an issue.
	TemplateData *string `json:"templateData,omitempty"`
	// The position of the template in the templates list.
	SortOrder *float64 `json:"sortOrder,omitempty"`
}

// Customer tier sorting options.
type TierSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// A time schedule.
type TimeSchedule struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the schedule.
	Name string `json:"name"`
	// The schedule entries.
	Entries []*TimeScheduleEntry `json:"entries,omitempty"`
	// The identifier of the external schedule.
	ExternalID *string `json:"externalId,omitempty"`
	// The URL to the external schedule.
	ExternalURL *string `json:"externalUrl,omitempty"`
	// The organization of the schedule.
	Organization *Organization `json:"organization"`
	// The identifier of the Linear integration populating the schedule.
	Integration *Integration `json:"integration,omitempty"`
}

func (TimeSchedule) IsNode() {}

// The unique identifier of the entity.
func (this TimeSchedule) GetID() string { return this.ID }

type TimeScheduleConnection struct {
	Edges    []*TimeScheduleEdge `json:"edges"`
	Nodes    []*TimeSchedule     `json:"nodes"`
	PageInfo *PageInfo           `json:"pageInfo"`
}

type TimeScheduleCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The name of the schedule.
	Name string `json:"name"`
	// The schedule entries.
	Entries []*TimeScheduleEntryInput `json:"entries"`
	// The unique identifier of the external schedule.
	ExternalID *string `json:"externalId,omitempty"`
	// The URL to the external schedule.
	ExternalURL *string `json:"externalUrl,omitempty"`
}

type TimeScheduleEdge struct {
	Node *TimeSchedule `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type TimeScheduleEntry struct {
	// The start date of the schedule in ISO 8601 date-time format.
	StartsAt string `json:"startsAt"`
	// The end date of the schedule in ISO 8601 date-time format.
	EndsAt string `json:"endsAt"`
	// The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
	UserID *string `json:"userId,omitempty"`
	// The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
	UserEmail *string `json:"userEmail,omitempty"`
}

type TimeScheduleEntryInput struct {
	// The start date of the schedule in ISO 8601 date-time format.
	StartsAt string `json:"startsAt"`
	// The end date of the schedule in ISO 8601 date-time format.
	EndsAt string `json:"endsAt"`
	// The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
	UserID *string `json:"userId,omitempty"`
	// The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
	UserEmail *string `json:"userEmail,omitempty"`
}

type TimeSchedulePayload struct {
	// The identifier of the last sync operation.
	LastSyncID   float64       `json:"lastSyncId"`
	TimeSchedule *TimeSchedule `json:"timeSchedule"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type TimeScheduleUpdateInput struct {
	// The name of the schedule.
	Name *string `json:"name,omitempty"`
	// The schedule entries.
	Entries []*TimeScheduleEntryInput `json:"entries,omitempty"`
	// The unique identifier of the external schedule.
	ExternalID *string `json:"externalId,omitempty"`
	// The URL to the external schedule.
	ExternalURL *string `json:"externalUrl,omitempty"`
}

// Comparator for timeless dates.
type TimelessDateComparator struct {
	// Equals constraint.
	Eq *string `json:"eq,omitempty"`
	// Not-equals constraint.
	Neq *string `json:"neq,omitempty"`
	// In-array constraint.
	In []string `json:"in,omitempty"`
	// Not-in-array constraint.
	Nin []string `json:"nin,omitempty"`
	// Less-than constraint. Matches any values that are less than the given value.
	Lt *string `json:"lt,omitempty"`
	// Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
	Lte *string `json:"lte,omitempty"`
	// Greater-than constraint. Matches any values that are greater than the given value.
	Gt *string `json:"gt,omitempty"`
	// Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
	Gte *string `json:"gte,omitempty"`
}

// Issue title sorting options.
type TitleSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type TokenUserAccountAuthInput struct {
	// The email which to login via the magic login code.
	Email string `json:"email"`
	// The magic login code.
	Token string `json:"token"`
	// The timezone of the user's browser.
	Timezone string `json:"timezone"`
	// The identifiers of the teams to auto-join.
	TeamIdsToJoin []string `json:"teamIdsToJoin,omitempty"`
	// An optional invite link for an organization.
	InviteLink *string `json:"inviteLink,omitempty"`
}

// A team's triage responsibility.
type TriageResponsibility struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The action to take when an issue is added to triage.
	Action TriageResponsibilityAction `json:"action"`
	// Set of users used for triage responsibility.
	ManualSelection *TriageResponsibilityManualSelection `json:"manualSelection,omitempty"`
	// The team to which the triage responsibility belongs to.
	Team *Team `json:"team"`
	// The time schedule used for scheduling.
	TimeSchedule *TimeSchedule `json:"timeSchedule,omitempty"`
	// The user currently responsible for triage.
	CurrentUser *User `json:"currentUser,omitempty"`
}

func (TriageResponsibility) IsNode() {}

// The unique identifier of the entity.
func (this TriageResponsibility) GetID() string { return this.ID }

type TriageResponsibilityConnection struct {
	Edges    []*TriageResponsibilityEdge `json:"edges"`
	Nodes    []*TriageResponsibility     `json:"nodes"`
	PageInfo *PageInfo                   `json:"pageInfo"`
}

type TriageResponsibilityCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The identifier of the team associated with the triage responsibility.
	TeamID string `json:"teamId"`
	// The action to take when an issue is added to triage.
	Action string `json:"action"`
	// The manual selection of users responsible for triage.
	ManualSelection *TriageResponsibilityManualSelectionInput `json:"manualSelection,omitempty"`
	// The identifier of the time schedule used for scheduling triage responsibility
	TimeScheduleID *string `json:"timeScheduleId,omitempty"`
}

type TriageResponsibilityEdge struct {
	Node *TriageResponsibility `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type TriageResponsibilityManualSelection struct {
	// The set of users responsible for triage.
	UserIds []string `json:"userIds"`
	// [INTERNAL] The index of the current userId used for the assign action when having more than one user.
	AssignmentIndex *int64 `json:"assignmentIndex,omitempty"`
}

// Manual triage responsibility using a set of users.
type TriageResponsibilityManualSelectionInput struct {
	// The set of users responsible for triage.
	UserIds []string `json:"userIds"`
	// [INTERNAL] The index of the current userId used for the assign action when having more than one user.
	AssignmentIndex *int64 `json:"assignmentIndex,omitempty"`
}

type TriageResponsibilityPayload struct {
	// The identifier of the last sync operation.
	LastSyncID           float64               `json:"lastSyncId"`
	TriageResponsibility *TriageResponsibility `json:"triageResponsibility"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type TriageResponsibilityUpdateInput struct {
	// The action to take when an issue is added to triage.
	Action *string `json:"action,omitempty"`
	// The manual selection of users responsible for triage.
	ManualSelection *TriageResponsibilityManualSelectionInput `json:"manualSelection,omitempty"`
	// The identifier of the time schedule used for scheduling triage responsibility.
	TimeScheduleID *string `json:"timeScheduleId,omitempty"`
}

// Issue update date sorting options.
type UpdatedAtSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

// Object representing Google Cloud upload policy, plus additional data.
type UploadFile struct {
	// The filename.
	Filename string `json:"filename"`
	// The content type.
	ContentType string `json:"contentType"`
	// The size of the uploaded file.
	Size int64 `json:"size"`
	// The signed URL the for the uploaded file. (assigned automatically).
	UploadURL string `json:"uploadUrl"`
	// The asset URL for the uploaded file. (assigned automatically).
	AssetURL string              `json:"assetUrl"`
	MetaData *string             `json:"metaData,omitempty"`
	Headers  []*UploadFileHeader `json:"headers"`
}

type UploadFileHeader struct {
	// Upload file header key.
	Key string `json:"key"`
	// Upload file header value.
	Value string `json:"value"`
}

type UploadPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Object describing the file to be uploaded.
	UploadFile *UploadFile `json:"uploadFile,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// A user that has access to the the resources of an organization.
type User struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user's full name.
	Name string `json:"name"`
	// The user's display (nick) name. Unique within each organization.
	DisplayName string `json:"displayName"`
	// The user's email address.
	Email string `json:"email"`
	// An URL to the user's avatar image.
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Reason why is the account disabled.
	DisableReason *string `json:"disableReason,omitempty"`
	// Unique hash for the user to be used in invite URLs.
	InviteHash string `json:"inviteHash"`
	// [DEPRECATED] Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash,omitempty"`
	// A short description of the user, either its title or bio.
	Description *string `json:"description,omitempty"`
	// The emoji to represent the user current status.
	StatusEmoji *string `json:"statusEmoji,omitempty"`
	// The label of the user current status.
	StatusLabel *string `json:"statusLabel,omitempty"`
	// A date at which the user current status should be cleared.
	StatusUntilAt *string `json:"statusUntilAt,omitempty"`
	// The local timezone of the user.
	Timezone *string `json:"timezone,omitempty"`
	// Organization the user belongs to.
	Organization *Organization `json:"organization"`
	// The last time the user was seen online. If null, the user is currently online.
	LastSeen *string `json:"lastSeen,omitempty"`
	// The initials of the user.
	Initials string `json:"initials"`
	// The background color of the avatar for users without set avatar.
	AvatarBackgroundColor string `json:"avatarBackgroundColor"`
	// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
	Guest bool `json:"guest"`
	// Whether the user account is active or disabled (suspended).
	Active bool `json:"active"`
	// The user's issue drafts
	IssueDrafts *IssueDraftConnection `json:"issueDrafts"`
	// User's profile URL.
	URL string `json:"url"`
	// Issues assigned to the user.
	AssignedIssues *IssueConnection `json:"assignedIssues"`
	// Issues created by the user.
	CreatedIssues *IssueConnection `json:"createdIssues"`
	// Number of issues created.
	CreatedIssueCount int64 `json:"createdIssueCount"`
	// Teams the user is part of.
	Teams *TeamConnection `json:"teams"`
	// Memberships associated with the user. For easier access of the same data, use `teams` query.
	TeamMemberships *TeamMembershipConnection `json:"teamMemberships"`
	// Whether the user is the currently authenticated user.
	IsMe bool `json:"isMe"`
	// Whether the user is an organization administrator.
	Admin bool `json:"admin"`
}

func (User) IsNode() {}

// The unique identifier of the entity.
func (this User) GetID() string { return this.ID }

// A user account.
type UserAccount struct {
	// The models identifier.
	ID string `json:"id"`
	// The time at which the model was created.
	CreatedAt string `json:"createdAt"`
	// The time at which the model was updated.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the model was archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user's name.
	Name *string `json:"name,omitempty"`
	// The user's email address.
	Email string `json:"email"`
	// The authentication service used to create the account.
	Service string `json:"service"`
	// Whether not to send email auth links in the email auth emails.
	AuthTokenLinkDisabled bool `json:"authTokenLinkDisabled"`
}

// [INTERNAL] An email change verification challenge.
type UserAccountEmailChange struct {
	// The model's identifier.
	ID string `json:"id"`
	// The time at which the model was updated.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the model was archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user account's current email.
	OldEmail string `json:"oldEmail"`
	// The timestamp the old email was verified at.
	OldEmailVerifiedAt *string `json:"oldEmailVerifiedAt,omitempty"`
	// The new email the user account wants to change to.
	NewEmail string `json:"newEmail"`
	// The timestamp the new email was verified at.
	NewEmailVerifiedAt *string `json:"newEmailVerifiedAt,omitempty"`
	// The timestamp the verification codes expire at.
	ExpiresAt string `json:"expiresAt"`
	// The timestamp this verification challenge was canceled at.
	CanceledAt *string `json:"canceledAt,omitempty"`
}

type UserAdminPayload struct {
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
type UserAuthorizedApplication struct {
	// OAuth application's ID.
	ID string `json:"id"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// Application name.
	Name string `json:"name"`
	// Information about the application.
	Description *string `json:"description,omitempty"`
	// Name of the developer.
	Developer string `json:"developer"`
	// Url of the developer (homepage or docs).
	DeveloperURL string `json:"developerUrl"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Whether the user has authorized the application for the given scopes.
	IsAuthorized bool `json:"isAuthorized"`
	// Whether the application was created by Linear.
	CreatedByLinear bool `json:"createdByLinear"`
	// Whether or not webhooks are enabled for the application.
	WebhooksEnabled bool `json:"webhooksEnabled"`
	// Error associated with the application needing to be requested for approval in the workspace.
	ApprovalErrorCode *string `json:"approvalErrorCode,omitempty"`
}

// User filtering options.
type UserCollectionFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*UserCollectionFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*UserCollectionFilter `json:"or,omitempty"`
	// Filters that needs to be matched by some users.
	Some *UserFilter `json:"some,omitempty"`
	// Filters that needs to be matched by all users.
	Every *UserFilter `json:"every,omitempty"`
	// Comparator for the collection length.
	Length *NumberComparator `json:"length,omitempty"`
}

type UserConnection struct {
	Edges    []*UserEdge `json:"edges"`
	Nodes    []*User     `json:"nodes"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type UserEdge struct {
	Node *User `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// User filtering options.
type UserFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the user's name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the user's display name.
	DisplayName *StringComparator `json:"displayName,omitempty"`
	// Comparator for the user's email.
	Email *StringComparator `json:"email,omitempty"`
	// Comparator for the user's activity status.
	Active *BooleanComparator `json:"active,omitempty"`
	// Filters that the users assigned issues must satisfy.
	AssignedIssues *IssueCollectionFilter `json:"assignedIssues,omitempty"`
	// Comparator for the user's admin status.
	Admin *BooleanComparator `json:"admin,omitempty"`
	// Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
	IsMe *BooleanComparator `json:"isMe,omitempty"`
	// Compound filters, all of which need to be matched by the user.
	And []*UserFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the user.
	Or []*UserFilter `json:"or,omitempty"`
}

// A user notification subscription.
type UserNotificationSubscription struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The user that subscribed to receive notifications.
	Subscriber *User `json:"subscriber"`
	// The contextual custom view associated with the notification subscription.
	CustomView *CustomView `json:"customView,omitempty"`
	// The contextual cycle view associated with the notification subscription.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual label view associated with the notification subscription.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual project view associated with the notification subscription.
	Project *Project `json:"project,omitempty"`
	// The contextual initiative view associated with the notification subscription.
	Initiative *Initiative `json:"initiative,omitempty"`
	// The team associated with the notification subscription.
	Team *Team `json:"team,omitempty"`
	// The user subscribed to.
	User *User `json:"user"`
	// The type of view to which the notification subscription context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which the notification subscription context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
	// Whether the subscription is active or not.
	Active bool `json:"active"`
	// The type of subscription.
	NotificationSubscriptionTypes []string `json:"notificationSubscriptionTypes"`
}

func (UserNotificationSubscription) IsEntity() {}

// The unique identifier of the entity.
func (this UserNotificationSubscription) GetID() string { return this.ID }

// The time at which the entity was created.
func (this UserNotificationSubscription) GetCreatedAt() string { return this.CreatedAt }

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//
//	been updated after creation.
func (this UserNotificationSubscription) GetUpdatedAt() string { return this.UpdatedAt }

// The time at which the entity was archived. Null if the entity has not been archived.
func (this UserNotificationSubscription) GetArchivedAt() *string { return this.ArchivedAt }

func (UserNotificationSubscription) IsNode() {}

// The unique identifier of the entity.

func (UserNotificationSubscription) IsNotificationSubscription() {}

// The unique identifier of the entity.

// The time at which the entity was created.

// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
//     been updated after creation.

// The time at which the entity was archived. Null if the entity has not been archived.

// The user that subscribed to receive notifications.
func (this UserNotificationSubscription) GetSubscriber() *User { return this.Subscriber }

// The contextual custom view associated with the notification subscription.
func (this UserNotificationSubscription) GetCustomView() *CustomView { return this.CustomView }

// The contextual cycle view associated with the notification subscription.
func (this UserNotificationSubscription) GetCycle() *Cycle { return this.Cycle }

// The contextual label view associated with the notification subscription.
func (this UserNotificationSubscription) GetLabel() *IssueLabel { return this.Label }

// The contextual project view associated with the notification subscription.
func (this UserNotificationSubscription) GetProject() *Project { return this.Project }

// The contextual initiative view associated with the notification subscription.
func (this UserNotificationSubscription) GetInitiative() *Initiative { return this.Initiative }

// The team associated with the notification subscription.
func (this UserNotificationSubscription) GetTeam() *Team { return this.Team }

// The user view associated with the notification subscription.
func (this UserNotificationSubscription) GetUser() *User { return this.User }

// The type of view to which the notification subscription context is associated with.
func (this UserNotificationSubscription) GetContextViewType() *ContextViewType {
	return this.ContextViewType
}

// The type of user view to which the notification subscription context is associated with.
func (this UserNotificationSubscription) GetUserContextViewType() *UserContextViewType {
	return this.UserContextViewType
}

// Whether the subscription is active or not.
func (this UserNotificationSubscription) GetActive() bool { return this.Active }

type UserPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The user that was created or updated.
	User *User `json:"user,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// The settings of a user as a JSON object.
type UserSettings struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The notification channel settings the user has selected.
	NotificationPreferences string `json:"notificationPreferences"`
	// The notification delivery preferences for the user.
	NotificationDeliveryPreferences *NotificationDeliveryPreferences `json:"notificationDeliveryPreferences"`
	// The email types the user has unsubscribed from.
	UnsubscribedFrom []string `json:"unsubscribedFrom"`
	// The user associated with these settings.
	User *User `json:"user"`
	// Hash for the user to be used in calendar URLs.
	CalendarHash *string `json:"calendarHash,omitempty"`
	// Whether this user is subscribed to changelog email or not.
	SubscribedToChangelog bool `json:"subscribedToChangelog"`
	// Whether this user is subscribed to DPA emails or not.
	SubscribedToDpa bool `json:"subscribedToDPA"`
	// Whether this user is subscribed to invite accepted emails or not.
	SubscribedToInviteAccepted bool `json:"subscribedToInviteAccepted"`
	// Whether this user is subscribed to privacy and legal update emails or not.
	SubscribedToPrivacyLegalUpdates bool `json:"subscribedToPrivacyLegalUpdates"`
	// Whether this user is subscribed to unread notifications reminder emails or not.
	SubscribedToUnreadNotificationsReminder bool `json:"subscribedToUnreadNotificationsReminder"`
	// Whether to show full user names instead of display names.
	ShowFullUserNames bool `json:"showFullUserNames"`
}

func (UserSettings) IsNode() {}

// The unique identifier of the entity.
func (this UserSettings) GetID() string { return this.ID }

type UserSettingsFlagPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The flag key which was updated.
	Flag *string `json:"flag,omitempty"`
	// The flag value after update.
	Value *int64 `json:"value,omitempty"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type UserSettingsFlagsResetPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type UserSettingsPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The user's settings.
	UserSettings *UserSettings `json:"userSettings"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type UserSettingsUpdateInput struct {
	// The user's settings.
	Settings *string `json:"settings,omitempty"`
	// The types of emails the user has unsubscribed from.
	UnsubscribedFrom []string `json:"unsubscribedFrom,omitempty"`
	// Whether this user is subscribed to changelog email or not.
	SubscribedToChangelog *bool `json:"subscribedToChangelog,omitempty"`
	// Whether this user is subscribed to DPA emails or not.
	SubscribedToDpa *bool `json:"subscribedToDPA,omitempty"`
	// Whether this user is subscribed to invite accepted emails or not.
	SubscribedToInviteAccepted *bool `json:"subscribedToInviteAccepted,omitempty"`
	// Whether this user is subscribed to privacy and legal update emails or not.
	SubscribedToPrivacyLegalUpdates *bool `json:"subscribedToPrivacyLegalUpdates,omitempty"`
	// Whether this user is subscribed to email notifications reminder or not.
	SubscribedToUnreadNotificationsReminder *bool `json:"subscribedToUnreadNotificationsReminder,omitempty"`
	// The user's notification preferences.
	NotificationPreferences *string `json:"notificationPreferences,omitempty"`
	// The user's notification delivery preferences.
	NotificationDeliveryPreferences *NotificationDeliveryPreferencesInput `json:"notificationDeliveryPreferences,omitempty"`
	// [Internal] The user's usage warning history.
	UsageWarningHistory *string `json:"usageWarningHistory,omitempty"`
}

type UserUpdateInput struct {
	// The name of the user.
	Name *string `json:"name,omitempty"`
	// The display name of the user.
	DisplayName *string `json:"displayName,omitempty"`
	// The avatar image URL of the user.
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// Whether the user account is active.
	Active *bool `json:"active,omitempty"`
	// Reason for deactivation.
	DisableReason *string `json:"disableReason,omitempty"`
	// Whether the user account has admin privileges.
	Admin *bool `json:"admin,omitempty"`
	// The user description or a short bio.
	Description *string `json:"description,omitempty"`
	// The emoji part of the user status.
	StatusEmoji *string `json:"statusEmoji,omitempty"`
	// The label part of the user status.
	StatusLabel *string `json:"statusLabel,omitempty"`
	// When the user status should be cleared.
	StatusUntilAt *string `json:"statusUntilAt,omitempty"`
	// The local timezone of the user.
	Timezone *string `json:"timezone,omitempty"`
}

// View preferences.
type ViewPreferences struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The view preference type.
	Type string `json:"type"`
	// The view type.
	ViewType string `json:"viewType"`
	// The view preferences
	Preferences *ViewPreferencesValues `json:"preferences"`
}

func (ViewPreferences) IsNode() {}

// The unique identifier of the entity.
func (this ViewPreferences) GetID() string { return this.ID }

type ViewPreferencesCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The type of view preferences (either user or organization level preferences).
	Type ViewPreferencesType `json:"type"`
	// The view type of the view preferences are associated with.
	ViewType ViewType `json:"viewType"`
	// View preferences object.
	Preferences string `json:"preferences"`
	// The default parameters for the insight on that view.
	Insights *string `json:"insights,omitempty"`
	// The team these view preferences are associated with.
	TeamID *string `json:"teamId,omitempty"`
	// The project these view preferences are associated with.
	ProjectID *string `json:"projectId,omitempty"`
	// The roadmap these view preferences are associated with.
	RoadmapID *string `json:"roadmapId,omitempty"`
	// [Internal] The initiative these view preferences are associated with.
	InitiativeID *string `json:"initiativeId,omitempty"`
	// The label these view preferences are associated with.
	LabelID *string `json:"labelId,omitempty"`
	// The cycle these view preferences are associated with.
	CycleID *string `json:"cycleId,omitempty"`
	// The custom view these view preferences are associated with.
	CustomViewID *string `json:"customViewId,omitempty"`
	// The user profile these view preferences are associated with.
	UserID *string `json:"userId,omitempty"`
}

type ViewPreferencesPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The view preferences entity being mutated.
	ViewPreferences *ViewPreferences `json:"viewPreferences"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type ViewPreferencesUpdateInput struct {
	// View preferences.
	Preferences *string `json:"preferences,omitempty"`
	// The default parameters for the insight on that view.
	Insights *string `json:"insights,omitempty"`
}

type ViewPreferencesValues struct {
	// The issue ordering.
	ViewOrdering *string `json:"viewOrdering,omitempty"`
	// The issue grouping.
	IssueGrouping *string `json:"issueGrouping,omitempty"`
	// Whether to show completed issues.
	ShowCompletedIssues *string `json:"showCompletedIssues,omitempty"`
}

// A webhook used to send HTTP notifications over data updates.
type Webhook struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// Webhook label.
	Label *string `json:"label,omitempty"`
	// Webhook URL.
	URL *string `json:"url,omitempty"`
	// Whether the Webhook is enabled.
	Enabled bool `json:"enabled"`
	// The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization.
	Team *Team `json:"team,omitempty"`
	// Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
	AllPublicTeams bool `json:"allPublicTeams"`
	// The user who created the webhook.
	Creator *User `json:"creator,omitempty"`
	// Secret token for verifying the origin on the recipient side.
	Secret *string `json:"secret,omitempty"`
	// The resource types this webhook is subscribed to.
	ResourceTypes []string `json:"resourceTypes"`
}

func (Webhook) IsNode() {}

// The unique identifier of the entity.
func (this Webhook) GetID() string { return this.ID }

type WebhookConnection struct {
	Edges    []*WebhookEdge `json:"edges"`
	Nodes    []*Webhook     `json:"nodes"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

type WebhookCreateInput struct {
	// Label for the webhook.
	Label *string `json:"label,omitempty"`
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// Whether this webhook is enabled.
	Enabled *bool `json:"enabled,omitempty"`
	// A secret token used to sign the webhook payload.
	Secret *string `json:"secret,omitempty"`
	// The URL that will be called on data changes.
	URL string `json:"url"`
	// List of resources the webhook should subscribe to.
	ResourceTypes []string `json:"resourceTypes"`
	// The identifier or key of the team associated with the Webhook.
	TeamID *string `json:"teamId,omitempty"`
	// Whether this webhook is enabled for all public teams.
	AllPublicTeams *bool `json:"allPublicTeams,omitempty"`
}

type WebhookEdge struct {
	Node *Webhook `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Entity representing a webhook execution failure.
type WebhookFailureEvent struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The webhook that this failure event is associated with.
	Webhook *Webhook `json:"webhook"`
	// The URL that the webhook was trying to push to.
	URL string `json:"url"`
	// The HTTP status code returned by the recipient.
	HTTPStatus *float64 `json:"httpStatus,omitempty"`
	// The HTTP response body returned by the recipient or error occured.
	ResponseOrError *string `json:"responseOrError,omitempty"`
	// The unique execution ID of the webhook push. This is retained between retries of the same push.
	ExecutionID string `json:"executionId"`
}

type WebhookPayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The webhook entity being mutated.
	Webhook *Webhook `json:"webhook"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

type WebhookUpdateInput struct {
	// Label for the webhook.
	Label *string `json:"label,omitempty"`
	// A secret token used to sign the webhook payload.
	Secret *string `json:"secret,omitempty"`
	// Whether this webhook is enabled.
	Enabled *bool `json:"enabled,omitempty"`
	// The URL that will be called on data changes.
	URL *string `json:"url,omitempty"`
	// List of resources the webhook should subscribe to.
	ResourceTypes []string `json:"resourceTypes,omitempty"`
}

// A condition to match for the workflow to be triggered.
type WorkflowCondition struct {
	// Trigger the workflow when an issue matches the filter. Can only be used when the trigger type is `Issue`.
	IssueFilter *IssueFilter `json:"issueFilter,omitempty"`
	// Triggers the workflow when a project matches the filter. Can only be used when the trigger type is `Project`.
	ProjectFilter *ProjectFilter `json:"projectFilter,omitempty"`
}

type WorkflowCronJobDefinition struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the workflow cron job.
	Name string `json:"name"`
	// The description of the workflow cron job.
	Description *string `json:"description,omitempty"`
	Enabled     bool    `json:"enabled"`
	// The team associated with the workflow cron job.
	Team *Team `json:"team"`
	// The user who created the workflow cron job.
	Creator *User `json:"creator"`
	// Cron schedule which is used to execute the workflow cron job.
	Schedule string `json:"schedule"`
	// An array of activities that will be executed as part of the workflow cron job.
	Activities string `json:"activities"`
	// The sort order of the workflow cron job definition within its siblings.
	SortOrder string `json:"sortOrder"`
}

func (WorkflowCronJobDefinition) IsNode() {}

// The unique identifier of the entity.
func (this WorkflowCronJobDefinition) GetID() string { return this.ID }

type WorkflowCronJobDefinitionConnection struct {
	Edges    []*WorkflowCronJobDefinitionEdge `json:"edges"`
	Nodes    []*WorkflowCronJobDefinition     `json:"nodes"`
	PageInfo *PageInfo                        `json:"pageInfo"`
}

type WorkflowCronJobDefinitionEdge struct {
	Node *WorkflowCronJobDefinition `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

type WorkflowDefinition struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The name of the workflow.
	Name string `json:"name"`
	// The name of the group that the workflow belongs to.
	GroupName *string `json:"groupName,omitempty"`
	// The description of the workflow.
	Description *string `json:"description,omitempty"`
	// The type of the workflow.
	Type WorkflowType `json:"type"`
	// The type of the event that triggers off the workflow.
	Trigger WorkflowTrigger `json:"trigger"`
	// The object type (e.g. Issue) that triggers this workflow.
	TriggerType WorkflowTriggerType `json:"triggerType"`
	// The conditions that need to be match for the workflow to be triggered.
	Conditions *string `json:"conditions,omitempty"`
	Enabled    bool    `json:"enabled"`
	// The team associated with the workflow. If not set, the workflow is associated with the entire organization.
	Team *Team `json:"team,omitempty"`
	// The user who created the workflow.
	Creator *User `json:"creator"`
	// An array of activities that will be executed as part of the workflow.
	Activities string `json:"activities"`
	// The sort order of the workflow definition within its siblings.
	SortOrder string `json:"sortOrder"`
	// The contextual label view associated with the workflow.
	Label *IssueLabel `json:"label,omitempty"`
	// The contextual cycle view associated with the workflow.
	Cycle *Cycle `json:"cycle,omitempty"`
	// The contextual user view associated with the workflow.
	User *User `json:"user,omitempty"`
	// The contextual project view associated with the workflow.
	Project *Project `json:"project,omitempty"`
	// The context custom view associated with the workflow.
	CustomView *CustomView `json:"customView,omitempty"`
	// The type of view to which this workflow's context is associated with.
	ContextViewType *ContextViewType `json:"contextViewType,omitempty"`
	// The type of user view to which this workflow's context is associated with.
	UserContextViewType *UserContextViewType `json:"userContextViewType,omitempty"`
}

func (WorkflowDefinition) IsNode() {}

// The unique identifier of the entity.
func (this WorkflowDefinition) GetID() string { return this.ID }

type WorkflowDefinitionConnection struct {
	Edges    []*WorkflowDefinitionEdge `json:"edges"`
	Nodes    []*WorkflowDefinition     `json:"nodes"`
	PageInfo *PageInfo                 `json:"pageInfo"`
}

type WorkflowDefinitionEdge struct {
	Node *WorkflowDefinition `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// A state in a team workflow.
type WorkflowState struct {
	// The unique identifier of the entity.
	ID string `json:"id"`
	// The time at which the entity was created.
	CreatedAt string `json:"createdAt"`
	// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
	//     been updated after creation.
	UpdatedAt string `json:"updatedAt"`
	// The time at which the entity was archived. Null if the entity has not been archived.
	ArchivedAt *string `json:"archivedAt,omitempty"`
	// The state's name.
	Name string `json:"name"`
	// The state's UI color as a HEX string.
	Color string `json:"color"`
	// Description of the state.
	Description *string `json:"description,omitempty"`
	// The position of the state in the team flow.
	Position float64 `json:"position"`
	// The type of the state. One of "triage", "backlog", "unstarted", "started", "completed", "canceled".
	Type string `json:"type"`
	// The team to which this state belongs to.
	Team *Team `json:"team"`
	// Issues belonging in this state.
	Issues *IssueConnection `json:"issues"`
}

func (WorkflowState) IsNode() {}

// The unique identifier of the entity.
func (this WorkflowState) GetID() string { return this.ID }

// A generic payload return from entity archive mutations.
type WorkflowStateArchivePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// Whether the operation was successful.
	Success bool `json:"success"`
	// The archived/unarchived entity. Null if entity was deleted.
	Entity *WorkflowState `json:"entity,omitempty"`
}

func (WorkflowStateArchivePayload) IsArchivePayload() {}

// The identifier of the last sync operation.
func (this WorkflowStateArchivePayload) GetLastSyncID() float64 { return this.LastSyncID }

// Whether the operation was successful.
func (this WorkflowStateArchivePayload) GetSuccess() bool { return this.Success }

type WorkflowStateConnection struct {
	Edges    []*WorkflowStateEdge `json:"edges"`
	Nodes    []*WorkflowState     `json:"nodes"`
	PageInfo *PageInfo            `json:"pageInfo"`
}

type WorkflowStateCreateInput struct {
	// The identifier in UUID v4 format. If none is provided, the backend will generate one.
	ID *string `json:"id,omitempty"`
	// The workflow type.
	Type string `json:"type"`
	// The name of the state.
	Name string `json:"name"`
	// The color of the state.
	Color string `json:"color"`
	// The description of the state.
	Description *string `json:"description,omitempty"`
	// The position of the state.
	Position *float64 `json:"position,omitempty"`
	// The team associated with the state.
	TeamID string `json:"teamId"`
}

type WorkflowStateEdge struct {
	Node *WorkflowState `json:"node"`
	// Used in `before` and `after` args
	Cursor string `json:"cursor"`
}

// Workflow state filtering options.
type WorkflowStateFilter struct {
	// Comparator for the identifier.
	ID *IDComparator `json:"id,omitempty"`
	// Comparator for the created at date.
	CreatedAt *DateComparator `json:"createdAt,omitempty"`
	// Comparator for the updated at date.
	UpdatedAt *DateComparator `json:"updatedAt,omitempty"`
	// Comparator for the workflow state name.
	Name *StringComparator `json:"name,omitempty"`
	// Comparator for the workflow state description.
	Description *StringComparator `json:"description,omitempty"`
	// Comparator for the workflow state position.
	Position *NumberComparator `json:"position,omitempty"`
	// Comparator for the workflow state type.
	Type *StringComparator `json:"type,omitempty"`
	// Filters that the workflow states team must satisfy.
	Team *TeamFilter `json:"team,omitempty"`
	// Filters that the workflow states issues must satisfy.
	Issues *IssueCollectionFilter `json:"issues,omitempty"`
	// Compound filters, all of which need to be matched by the workflow state.
	And []*WorkflowStateFilter `json:"and,omitempty"`
	// Compound filters, one of which need to be matched by the workflow state.
	Or []*WorkflowStateFilter `json:"or,omitempty"`
}

type WorkflowStatePayload struct {
	// The identifier of the last sync operation.
	LastSyncID float64 `json:"lastSyncId"`
	// The state that was created or updated.
	WorkflowState *WorkflowState `json:"workflowState"`
	// Whether the operation was successful.
	Success bool `json:"success"`
}

// Issue workflow state sorting options.
type WorkflowStateSort struct {
	// Whether nulls should be sorted first or last
	Nulls *PaginationNulls `json:"nulls,omitempty"`
	// The order for the individual sort
	Order *PaginationSortOrder `json:"order,omitempty"`
}

type WorkflowStateUpdateInput struct {
	// The name of the state.
	Name *string `json:"name,omitempty"`
	// The color of the state.
	Color *string `json:"color,omitempty"`
	// The description of the state.
	Description *string `json:"description,omitempty"`
	// The position of the state.
	Position *float64 `json:"position,omitempty"`
}

// [INTERNAL] Public information of the OAuth application, plus the userIds and scopes for those users.
type WorkspaceAuthorizedApplication struct {
	// Application name.
	Name string `json:"name"`
	// Image of the application.
	ImageURL *string `json:"imageUrl,omitempty"`
	// Scopes that are authorized for this application for a given user.
	Scope []string `json:"scope"`
	// OAuth application's ID.
	AppID string `json:"appId"`
	// OAuth application's client ID.
	ClientID string `json:"clientId"`
	// Whether or not webhooks are enabled for the application.
	WebhooksEnabled bool `json:"webhooksEnabled"`
	// Total number of members that authorized the application.
	TotalMembers float64 `json:"totalMembers"`
	// UserIds and membership dates of everyone who has authorized the application with the set of scopes.
	Memberships []*AuthMembership `json:"memberships"`
}

// Zendesk specific settings.
type ZendeskSettings struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
	// The subdomain of the Zendesk organization being connected.
	Subdomain string `json:"subdomain"`
	// The URL of the connected Zendesk organization.
	URL string `json:"url"`
	// The ID of the Linear bot user.
	BotUserID *string `json:"botUserId,omitempty"`
}

type ZendeskSettingsInput struct {
	// Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
	SendNoteOnStatusChange *bool `json:"sendNoteOnStatusChange,omitempty"`
	// Whether an internal message should be added when someone comments on an issue.
	SendNoteOnComment *bool `json:"sendNoteOnComment,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is completed.
	AutomateTicketReopeningOnCompletion *bool `json:"automateTicketReopeningOnCompletion,omitempty"`
	// Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
	AutomateTicketReopeningOnCancellation *bool `json:"automateTicketReopeningOnCancellation,omitempty"`
	// Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
	AutomateTicketReopeningOnComment *bool `json:"automateTicketReopeningOnComment,omitempty"`
	// The subdomain of the Zendesk organization being connected.
	Subdomain string `json:"subdomain"`
	// The URL of the connected Zendesk organization.
	URL string `json:"url"`
	// The ID of the Linear bot user.
	BotUserID *string `json:"botUserId,omitempty"`
}

type AuthenticationSessionType string

const (
	AuthenticationSessionTypeWeb     AuthenticationSessionType = "web"
	AuthenticationSessionTypeDesktop AuthenticationSessionType = "desktop"
	AuthenticationSessionTypeIos     AuthenticationSessionType = "ios"
	AuthenticationSessionTypeAndroid AuthenticationSessionType = "android"
)

var AllAuthenticationSessionType = []AuthenticationSessionType{
	AuthenticationSessionTypeWeb,
	AuthenticationSessionTypeDesktop,
	AuthenticationSessionTypeIos,
	AuthenticationSessionTypeAndroid,
}

func (e AuthenticationSessionType) IsValid() bool {
	switch e {
	case AuthenticationSessionTypeWeb, AuthenticationSessionTypeDesktop, AuthenticationSessionTypeIos, AuthenticationSessionTypeAndroid:
		return true
	}
	return false
}

func (e AuthenticationSessionType) String() string {
	return string(e)
}

func (e *AuthenticationSessionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthenticationSessionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthenticationSessionType", str)
	}
	return nil
}

func (e AuthenticationSessionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContextViewType string

const (
	ContextViewTypeActiveIssues  ContextViewType = "activeIssues"
	ContextViewTypeActiveCycle   ContextViewType = "activeCycle"
	ContextViewTypeUpcomingCycle ContextViewType = "upcomingCycle"
	ContextViewTypeBacklog       ContextViewType = "backlog"
	ContextViewTypeTriage        ContextViewType = "triage"
)

var AllContextViewType = []ContextViewType{
	ContextViewTypeActiveIssues,
	ContextViewTypeActiveCycle,
	ContextViewTypeUpcomingCycle,
	ContextViewTypeBacklog,
	ContextViewTypeTriage,
}

func (e ContextViewType) IsValid() bool {
	switch e {
	case ContextViewTypeActiveIssues, ContextViewTypeActiveCycle, ContextViewTypeUpcomingCycle, ContextViewTypeBacklog, ContextViewTypeTriage:
		return true
	}
	return false
}

func (e ContextViewType) String() string {
	return string(e)
}

func (e *ContextViewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContextViewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContextViewType", str)
	}
	return nil
}

func (e ContextViewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A type of customer status.
type CustomerStatusType string

const (
	CustomerStatusTypeActive   CustomerStatusType = "active"
	CustomerStatusTypeInactive CustomerStatusType = "inactive"
)

var AllCustomerStatusType = []CustomerStatusType{
	CustomerStatusTypeActive,
	CustomerStatusTypeInactive,
}

func (e CustomerStatusType) IsValid() bool {
	switch e {
	case CustomerStatusTypeActive, CustomerStatusTypeInactive:
		return true
	}
	return false
}

func (e CustomerStatusType) String() string {
	return string(e)
}

func (e *CustomerStatusType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerStatusType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerStatusType", str)
	}
	return nil
}

func (e CustomerStatusType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// [INTERNAL] By which resolution is a date defined.
type DateResolutionType string

const (
	DateResolutionTypeMonth    DateResolutionType = "month"
	DateResolutionTypeQuarter  DateResolutionType = "quarter"
	DateResolutionTypeHalfYear DateResolutionType = "halfYear"
	DateResolutionTypeYear     DateResolutionType = "year"
)

var AllDateResolutionType = []DateResolutionType{
	DateResolutionTypeMonth,
	DateResolutionTypeQuarter,
	DateResolutionTypeHalfYear,
	DateResolutionTypeYear,
}

func (e DateResolutionType) IsValid() bool {
	switch e {
	case DateResolutionTypeMonth, DateResolutionTypeQuarter, DateResolutionTypeHalfYear, DateResolutionTypeYear:
		return true
	}
	return false
}

func (e DateResolutionType) String() string {
	return string(e)
}

func (e *DateResolutionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateResolutionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateResolutionType", str)
	}
	return nil
}

func (e DateResolutionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The day of the week.
type Day string

const (
	DaySunday    Day = "Sunday"
	DayMonday    Day = "Monday"
	DayTuesday   Day = "Tuesday"
	DayWednesday Day = "Wednesday"
	DayThursday  Day = "Thursday"
	DayFriday    Day = "Friday"
	DaySaturday  Day = "Saturday"
)

var AllDay = []Day{
	DaySunday,
	DayMonday,
	DayTuesday,
	DayWednesday,
	DayThursday,
	DayFriday,
	DaySaturday,
}

func (e Day) IsValid() bool {
	switch e {
	case DaySunday, DayMonday, DayTuesday, DayWednesday, DayThursday, DayFriday, DaySaturday:
		return true
	}
	return false
}

func (e Day) String() string {
	return string(e)
}

func (e *Day) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Day(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Day", str)
	}
	return nil
}

func (e Day) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FacetPageSource string

const (
	FacetPageSourceProjects FacetPageSource = "projects"
)

var AllFacetPageSource = []FacetPageSource{
	FacetPageSourceProjects,
}

func (e FacetPageSource) IsValid() bool {
	switch e {
	case FacetPageSourceProjects:
		return true
	}
	return false
}

func (e FacetPageSource) String() string {
	return string(e)
}

func (e *FacetPageSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FacetPageSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FacetPageSource", str)
	}
	return nil
}

func (e FacetPageSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of a feature flag rollout stage.
type FeatureFlagRolloutStageType string

const (
	FeatureFlagRolloutStageTypeDev      FeatureFlagRolloutStageType = "dev"
	FeatureFlagRolloutStageTypeInternal FeatureFlagRolloutStageType = "internal"
	FeatureFlagRolloutStageTypePartial  FeatureFlagRolloutStageType = "partial"
	FeatureFlagRolloutStageTypeFull     FeatureFlagRolloutStageType = "full"
)

var AllFeatureFlagRolloutStageType = []FeatureFlagRolloutStageType{
	FeatureFlagRolloutStageTypeDev,
	FeatureFlagRolloutStageTypeInternal,
	FeatureFlagRolloutStageTypePartial,
	FeatureFlagRolloutStageTypeFull,
}

func (e FeatureFlagRolloutStageType) IsValid() bool {
	switch e {
	case FeatureFlagRolloutStageTypeDev, FeatureFlagRolloutStageTypeInternal, FeatureFlagRolloutStageTypePartial, FeatureFlagRolloutStageTypeFull:
		return true
	}
	return false
}

func (e FeatureFlagRolloutStageType) String() string {
	return string(e)
}

func (e *FeatureFlagRolloutStageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureFlagRolloutStageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureFlagRolloutStageType", str)
	}
	return nil
}

func (e FeatureFlagRolloutStageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The various states of a pull/merge request.
type GitAutomationStates string

const (
	GitAutomationStatesDraft     GitAutomationStates = "draft"
	GitAutomationStatesStart     GitAutomationStates = "start"
	GitAutomationStatesReview    GitAutomationStates = "review"
	GitAutomationStatesMergeable GitAutomationStates = "mergeable"
	GitAutomationStatesMerge     GitAutomationStates = "merge"
)

var AllGitAutomationStates = []GitAutomationStates{
	GitAutomationStatesDraft,
	GitAutomationStatesStart,
	GitAutomationStatesReview,
	GitAutomationStatesMergeable,
	GitAutomationStatesMerge,
}

func (e GitAutomationStates) IsValid() bool {
	switch e {
	case GitAutomationStatesDraft, GitAutomationStatesStart, GitAutomationStatesReview, GitAutomationStatesMergeable, GitAutomationStatesMerge:
		return true
	}
	return false
}

func (e GitAutomationStates) String() string {
	return string(e)
}

func (e *GitAutomationStates) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitAutomationStates(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitAutomationStates", str)
	}
	return nil
}

func (e GitAutomationStates) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GithubOrgType string

const (
	GithubOrgTypeUser         GithubOrgType = "user"
	GithubOrgTypeOrganization GithubOrgType = "organization"
)

var AllGithubOrgType = []GithubOrgType{
	GithubOrgTypeUser,
	GithubOrgTypeOrganization,
}

func (e GithubOrgType) IsValid() bool {
	switch e {
	case GithubOrgTypeUser, GithubOrgTypeOrganization:
		return true
	}
	return false
}

func (e GithubOrgType) String() string {
	return string(e)
}

func (e *GithubOrgType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GithubOrgType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GithubOrgType", str)
	}
	return nil
}

func (e GithubOrgType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InitiativeStatus string

const (
	InitiativeStatusPlanned   InitiativeStatus = "Planned"
	InitiativeStatusActive    InitiativeStatus = "Active"
	InitiativeStatusCompleted InitiativeStatus = "Completed"
)

var AllInitiativeStatus = []InitiativeStatus{
	InitiativeStatusPlanned,
	InitiativeStatusActive,
	InitiativeStatusCompleted,
}

func (e InitiativeStatus) IsValid() bool {
	switch e {
	case InitiativeStatusPlanned, InitiativeStatusActive, InitiativeStatusCompleted:
		return true
	}
	return false
}

func (e InitiativeStatus) String() string {
	return string(e)
}

func (e *InitiativeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InitiativeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InitiativeStatus", str)
	}
	return nil
}

func (e InitiativeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different tabs available inside an initiative.
type InitiativeTab string

const (
	InitiativeTabOverview InitiativeTab = "overview"
	InitiativeTabProjects InitiativeTab = "projects"
)

var AllInitiativeTab = []InitiativeTab{
	InitiativeTabOverview,
	InitiativeTabProjects,
}

func (e InitiativeTab) IsValid() bool {
	switch e {
	case InitiativeTabOverview, InitiativeTabProjects:
		return true
	}
	return false
}

func (e InitiativeTab) String() string {
	return string(e)
}

func (e *InitiativeTab) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InitiativeTab(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InitiativeTab", str)
	}
	return nil
}

func (e InitiativeTab) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Linear supported integration services.
type IntegrationService string

const (
	IntegrationServiceAirbyte                      IntegrationService = "airbyte"
	IntegrationServiceDiscord                      IntegrationService = "discord"
	IntegrationServiceFigma                        IntegrationService = "figma"
	IntegrationServiceFigmaPlugin                  IntegrationService = "figmaPlugin"
	IntegrationServiceFront                        IntegrationService = "front"
	IntegrationServiceGithub                       IntegrationService = "github"
	IntegrationServiceGithubEnterpriseServer       IntegrationService = "githubEnterpriseServer"
	IntegrationServiceGithubCommit                 IntegrationService = "githubCommit"
	IntegrationServiceGithubImport                 IntegrationService = "githubImport"
	IntegrationServiceGithubPersonal               IntegrationService = "githubPersonal"
	IntegrationServiceGitlab                       IntegrationService = "gitlab"
	IntegrationServiceGoogleCalendarPersonal       IntegrationService = "googleCalendarPersonal"
	IntegrationServiceGoogleSheets                 IntegrationService = "googleSheets"
	IntegrationServiceIntercom                     IntegrationService = "intercom"
	IntegrationServiceJira                         IntegrationService = "jira"
	IntegrationServiceJiraPersonal                 IntegrationService = "jiraPersonal"
	IntegrationServiceLaunchDarkly                 IntegrationService = "launchDarkly"
	IntegrationServiceLoom                         IntegrationService = "loom"
	IntegrationServiceNotion                       IntegrationService = "notion"
	IntegrationServiceOpsgenie                     IntegrationService = "opsgenie"
	IntegrationServicePagerDuty                    IntegrationService = "pagerDuty"
	IntegrationServiceSlack                        IntegrationService = "slack"
	IntegrationServiceSlackAsks                    IntegrationService = "slackAsks"
	IntegrationServiceSlackCustomViewNotifications IntegrationService = "slackCustomViewNotifications"
	IntegrationServiceSlackOrgProjectUpdatesPost   IntegrationService = "slackOrgProjectUpdatesPost"
	IntegrationServiceSlackPersonal                IntegrationService = "slackPersonal"
	IntegrationServiceSlackPost                    IntegrationService = "slackPost"
	IntegrationServiceSlackProjectPost             IntegrationService = "slackProjectPost"
	IntegrationServiceSlackProjectUpdatesPost      IntegrationService = "slackProjectUpdatesPost"
	IntegrationServiceSentry                       IntegrationService = "sentry"
	IntegrationServiceZendesk                      IntegrationService = "zendesk"
	IntegrationServiceEmail                        IntegrationService = "email"
)

var AllIntegrationService = []IntegrationService{
	IntegrationServiceAirbyte,
	IntegrationServiceDiscord,
	IntegrationServiceFigma,
	IntegrationServiceFigmaPlugin,
	IntegrationServiceFront,
	IntegrationServiceGithub,
	IntegrationServiceGithubEnterpriseServer,
	IntegrationServiceGithubCommit,
	IntegrationServiceGithubImport,
	IntegrationServiceGithubPersonal,
	IntegrationServiceGitlab,
	IntegrationServiceGoogleCalendarPersonal,
	IntegrationServiceGoogleSheets,
	IntegrationServiceIntercom,
	IntegrationServiceJira,
	IntegrationServiceJiraPersonal,
	IntegrationServiceLaunchDarkly,
	IntegrationServiceLoom,
	IntegrationServiceNotion,
	IntegrationServiceOpsgenie,
	IntegrationServicePagerDuty,
	IntegrationServiceSlack,
	IntegrationServiceSlackAsks,
	IntegrationServiceSlackCustomViewNotifications,
	IntegrationServiceSlackOrgProjectUpdatesPost,
	IntegrationServiceSlackPersonal,
	IntegrationServiceSlackPost,
	IntegrationServiceSlackProjectPost,
	IntegrationServiceSlackProjectUpdatesPost,
	IntegrationServiceSentry,
	IntegrationServiceZendesk,
	IntegrationServiceEmail,
}

func (e IntegrationService) IsValid() bool {
	switch e {
	case IntegrationServiceAirbyte, IntegrationServiceDiscord, IntegrationServiceFigma, IntegrationServiceFigmaPlugin, IntegrationServiceFront, IntegrationServiceGithub, IntegrationServiceGithubEnterpriseServer, IntegrationServiceGithubCommit, IntegrationServiceGithubImport, IntegrationServiceGithubPersonal, IntegrationServiceGitlab, IntegrationServiceGoogleCalendarPersonal, IntegrationServiceGoogleSheets, IntegrationServiceIntercom, IntegrationServiceJira, IntegrationServiceJiraPersonal, IntegrationServiceLaunchDarkly, IntegrationServiceLoom, IntegrationServiceNotion, IntegrationServiceOpsgenie, IntegrationServicePagerDuty, IntegrationServiceSlack, IntegrationServiceSlackAsks, IntegrationServiceSlackCustomViewNotifications, IntegrationServiceSlackOrgProjectUpdatesPost, IntegrationServiceSlackPersonal, IntegrationServiceSlackPost, IntegrationServiceSlackProjectPost, IntegrationServiceSlackProjectUpdatesPost, IntegrationServiceSentry, IntegrationServiceZendesk, IntegrationServiceEmail:
		return true
	}
	return false
}

func (e IntegrationService) String() string {
	return string(e)
}

func (e *IntegrationService) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationService(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationService", str)
	}
	return nil
}

func (e IntegrationService) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of the issue relation.
type IssueRelationType string

const (
	IssueRelationTypeBlocks    IssueRelationType = "blocks"
	IssueRelationTypeDuplicate IssueRelationType = "duplicate"
	IssueRelationTypeRelated   IssueRelationType = "related"
)

var AllIssueRelationType = []IssueRelationType{
	IssueRelationTypeBlocks,
	IssueRelationTypeDuplicate,
	IssueRelationTypeRelated,
}

func (e IssueRelationType) IsValid() bool {
	switch e {
	case IssueRelationTypeBlocks, IssueRelationTypeDuplicate, IssueRelationTypeRelated:
		return true
	}
	return false
}

func (e IssueRelationType) String() string {
	return string(e)
}

func (e *IssueRelationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IssueRelationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IssueRelationType", str)
	}
	return nil
}

func (e IssueRelationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different requests statuses possible for an OAuth client approval request.
type OAuthClientApprovalStatus string

const (
	OAuthClientApprovalStatusRequested OAuthClientApprovalStatus = "requested"
	OAuthClientApprovalStatusApproved  OAuthClientApprovalStatus = "approved"
	OAuthClientApprovalStatusDenied    OAuthClientApprovalStatus = "denied"
)

var AllOAuthClientApprovalStatus = []OAuthClientApprovalStatus{
	OAuthClientApprovalStatusRequested,
	OAuthClientApprovalStatusApproved,
	OAuthClientApprovalStatusDenied,
}

func (e OAuthClientApprovalStatus) IsValid() bool {
	switch e {
	case OAuthClientApprovalStatusRequested, OAuthClientApprovalStatusApproved, OAuthClientApprovalStatusDenied:
		return true
	}
	return false
}

func (e OAuthClientApprovalStatus) String() string {
	return string(e)
}

func (e *OAuthClientApprovalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OAuthClientApprovalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OAuthClientApprovalStatus", str)
	}
	return nil
}

func (e OAuthClientApprovalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// What type of auth is the domain used for.
type OrganizationDomainAuthType string

const (
	OrganizationDomainAuthTypeSaml    OrganizationDomainAuthType = "saml"
	OrganizationDomainAuthTypeGeneral OrganizationDomainAuthType = "general"
)

var AllOrganizationDomainAuthType = []OrganizationDomainAuthType{
	OrganizationDomainAuthTypeSaml,
	OrganizationDomainAuthTypeGeneral,
}

func (e OrganizationDomainAuthType) IsValid() bool {
	switch e {
	case OrganizationDomainAuthTypeSaml, OrganizationDomainAuthTypeGeneral:
		return true
	}
	return false
}

func (e OrganizationDomainAuthType) String() string {
	return string(e)
}

func (e *OrganizationDomainAuthType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationDomainAuthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationDomainAuthType", str)
	}
	return nil
}

func (e OrganizationDomainAuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different statuses possible for an organization invite.
type OrganizationInviteStatus string

const (
	OrganizationInviteStatusPending  OrganizationInviteStatus = "pending"
	OrganizationInviteStatusAccepted OrganizationInviteStatus = "accepted"
	OrganizationInviteStatusExpired  OrganizationInviteStatus = "expired"
)

var AllOrganizationInviteStatus = []OrganizationInviteStatus{
	OrganizationInviteStatusPending,
	OrganizationInviteStatusAccepted,
	OrganizationInviteStatusExpired,
}

func (e OrganizationInviteStatus) IsValid() bool {
	switch e {
	case OrganizationInviteStatusPending, OrganizationInviteStatusAccepted, OrganizationInviteStatusExpired:
		return true
	}
	return false
}

func (e OrganizationInviteStatus) String() string {
	return string(e)
}

func (e *OrganizationInviteStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationInviteStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationInviteStatus", str)
	}
	return nil
}

func (e OrganizationInviteStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// How to treat NULL values, whether they should appear first or last
type PaginationNulls string

const (
	PaginationNullsFirst PaginationNulls = "first"
	PaginationNullsLast  PaginationNulls = "last"
)

var AllPaginationNulls = []PaginationNulls{
	PaginationNullsFirst,
	PaginationNullsLast,
}

func (e PaginationNulls) IsValid() bool {
	switch e {
	case PaginationNullsFirst, PaginationNullsLast:
		return true
	}
	return false
}

func (e PaginationNulls) String() string {
	return string(e)
}

func (e *PaginationNulls) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaginationNulls(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaginationNulls", str)
	}
	return nil
}

func (e PaginationNulls) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// By which field should the pagination order by
type PaginationOrderBy string

const (
	PaginationOrderByCreatedAt PaginationOrderBy = "createdAt"
	PaginationOrderByUpdatedAt PaginationOrderBy = "updatedAt"
)

var AllPaginationOrderBy = []PaginationOrderBy{
	PaginationOrderByCreatedAt,
	PaginationOrderByUpdatedAt,
}

func (e PaginationOrderBy) IsValid() bool {
	switch e {
	case PaginationOrderByCreatedAt, PaginationOrderByUpdatedAt:
		return true
	}
	return false
}

func (e PaginationOrderBy) String() string {
	return string(e)
}

func (e *PaginationOrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaginationOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaginationOrderBy", str)
	}
	return nil
}

func (e PaginationOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Whether to sort in ascending or descending order
type PaginationSortOrder string

const (
	PaginationSortOrderAscending  PaginationSortOrder = "Ascending"
	PaginationSortOrderDescending PaginationSortOrder = "Descending"
)

var AllPaginationSortOrder = []PaginationSortOrder{
	PaginationSortOrderAscending,
	PaginationSortOrderDescending,
}

func (e PaginationSortOrder) IsValid() bool {
	switch e {
	case PaginationSortOrderAscending, PaginationSortOrderDescending:
		return true
	}
	return false
}

func (e PaginationSortOrder) String() string {
	return string(e)
}

func (e *PaginationSortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaginationSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaginationSortOrder", str)
	}
	return nil
}

func (e PaginationSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A type of project status.
type ProjectStatusType string

const (
	ProjectStatusTypeBacklog   ProjectStatusType = "backlog"
	ProjectStatusTypePlanned   ProjectStatusType = "planned"
	ProjectStatusTypeStarted   ProjectStatusType = "started"
	ProjectStatusTypePaused    ProjectStatusType = "paused"
	ProjectStatusTypeCompleted ProjectStatusType = "completed"
	ProjectStatusTypeCanceled  ProjectStatusType = "canceled"
)

var AllProjectStatusType = []ProjectStatusType{
	ProjectStatusTypeBacklog,
	ProjectStatusTypePlanned,
	ProjectStatusTypeStarted,
	ProjectStatusTypePaused,
	ProjectStatusTypeCompleted,
	ProjectStatusTypeCanceled,
}

func (e ProjectStatusType) IsValid() bool {
	switch e {
	case ProjectStatusTypeBacklog, ProjectStatusTypePlanned, ProjectStatusTypeStarted, ProjectStatusTypePaused, ProjectStatusTypeCompleted, ProjectStatusTypeCanceled:
		return true
	}
	return false
}

func (e ProjectStatusType) String() string {
	return string(e)
}

func (e *ProjectStatusType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectStatusType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectStatusType", str)
	}
	return nil
}

func (e ProjectStatusType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different tabs available inside a project.
type ProjectTab string

const (
	ProjectTabDocuments ProjectTab = "documents"
	ProjectTabIssues    ProjectTab = "issues"
)

var AllProjectTab = []ProjectTab{
	ProjectTabDocuments,
	ProjectTabIssues,
}

func (e ProjectTab) IsValid() bool {
	switch e {
	case ProjectTabDocuments, ProjectTabIssues:
		return true
	}
	return false
}

func (e ProjectTab) String() string {
	return string(e)
}

func (e *ProjectTab) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectTab(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectTab", str)
	}
	return nil
}

func (e ProjectTab) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The health type of a project when the update is created.
type ProjectUpdateHealthType string

const (
	ProjectUpdateHealthTypeOnTrack  ProjectUpdateHealthType = "onTrack"
	ProjectUpdateHealthTypeAtRisk   ProjectUpdateHealthType = "atRisk"
	ProjectUpdateHealthTypeOffTrack ProjectUpdateHealthType = "offTrack"
)

var AllProjectUpdateHealthType = []ProjectUpdateHealthType{
	ProjectUpdateHealthTypeOnTrack,
	ProjectUpdateHealthTypeAtRisk,
	ProjectUpdateHealthTypeOffTrack,
}

func (e ProjectUpdateHealthType) IsValid() bool {
	switch e {
	case ProjectUpdateHealthTypeOnTrack, ProjectUpdateHealthTypeAtRisk, ProjectUpdateHealthTypeOffTrack:
		return true
	}
	return false
}

func (e ProjectUpdateHealthType) String() string {
	return string(e)
}

func (e *ProjectUpdateHealthType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectUpdateHealthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectUpdateHealthType", str)
	}
	return nil
}

func (e ProjectUpdateHealthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The frequency at which to send project update reminders.
type ProjectUpdateReminderFrequency string

const (
	ProjectUpdateReminderFrequencyWeek     ProjectUpdateReminderFrequency = "week"
	ProjectUpdateReminderFrequencyTwoWeeks ProjectUpdateReminderFrequency = "twoWeeks"
	ProjectUpdateReminderFrequencyMonth    ProjectUpdateReminderFrequency = "month"
	ProjectUpdateReminderFrequencyNever    ProjectUpdateReminderFrequency = "never"
)

var AllProjectUpdateReminderFrequency = []ProjectUpdateReminderFrequency{
	ProjectUpdateReminderFrequencyWeek,
	ProjectUpdateReminderFrequencyTwoWeeks,
	ProjectUpdateReminderFrequencyMonth,
	ProjectUpdateReminderFrequencyNever,
}

func (e ProjectUpdateReminderFrequency) IsValid() bool {
	switch e {
	case ProjectUpdateReminderFrequencyWeek, ProjectUpdateReminderFrequencyTwoWeeks, ProjectUpdateReminderFrequencyMonth, ProjectUpdateReminderFrequencyNever:
		return true
	}
	return false
}

func (e ProjectUpdateReminderFrequency) String() string {
	return string(e)
}

func (e *ProjectUpdateReminderFrequency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectUpdateReminderFrequency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectUpdateReminderFrequency", str)
	}
	return nil
}

func (e ProjectUpdateReminderFrequency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different push subscription types.
type PushSubscriptionType string

const (
	PushSubscriptionTypeWeb              PushSubscriptionType = "web"
	PushSubscriptionTypeApple            PushSubscriptionType = "apple"
	PushSubscriptionTypeAppleDevelopment PushSubscriptionType = "appleDevelopment"
	PushSubscriptionTypeFirebase         PushSubscriptionType = "firebase"
)

var AllPushSubscriptionType = []PushSubscriptionType{
	PushSubscriptionTypeWeb,
	PushSubscriptionTypeApple,
	PushSubscriptionTypeAppleDevelopment,
	PushSubscriptionTypeFirebase,
}

func (e PushSubscriptionType) IsValid() bool {
	switch e {
	case PushSubscriptionTypeWeb, PushSubscriptionTypeApple, PushSubscriptionTypeAppleDevelopment, PushSubscriptionTypeFirebase:
		return true
	}
	return false
}

func (e PushSubscriptionType) String() string {
	return string(e)
}

func (e *PushSubscriptionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PushSubscriptionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PushSubscriptionType", str)
	}
	return nil
}

func (e PushSubscriptionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Features release channel.
type ReleaseChannel string

const (
	ReleaseChannelInternal   ReleaseChannel = "internal"
	ReleaseChannelBeta       ReleaseChannel = "beta"
	ReleaseChannelPreRelease ReleaseChannel = "preRelease"
	ReleaseChannelPublic     ReleaseChannel = "public"
)

var AllReleaseChannel = []ReleaseChannel{
	ReleaseChannelInternal,
	ReleaseChannelBeta,
	ReleaseChannelPreRelease,
	ReleaseChannelPublic,
}

func (e ReleaseChannel) IsValid() bool {
	switch e {
	case ReleaseChannelInternal, ReleaseChannelBeta, ReleaseChannelPreRelease, ReleaseChannelPublic:
		return true
	}
	return false
}

func (e ReleaseChannel) String() string {
	return string(e)
}

func (e *ReleaseChannel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReleaseChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReleaseChannel", str)
	}
	return nil
}

func (e ReleaseChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which day count to use for SLA calculations.
type SLADayCountType string

const (
	SLADayCountTypeAll              SLADayCountType = "all"
	SLADayCountTypeOnlyBusinessDays SLADayCountType = "onlyBusinessDays"
)

var AllSLADayCountType = []SLADayCountType{
	SLADayCountTypeAll,
	SLADayCountTypeOnlyBusinessDays,
}

func (e SLADayCountType) IsValid() bool {
	switch e {
	case SLADayCountTypeAll, SLADayCountTypeOnlyBusinessDays:
		return true
	}
	return false
}

func (e SLADayCountType) String() string {
	return string(e)
}

func (e *SLADayCountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SLADayCountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SLADayCountType", str)
	}
	return nil
}

func (e SLADayCountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SchemaFieldType string

const (
	SchemaFieldTypeStringType  SchemaFieldType = "stringType"
	SchemaFieldTypeNumberType  SchemaFieldType = "numberType"
	SchemaFieldTypeBooleanType SchemaFieldType = "booleanType"
	SchemaFieldTypeDateType    SchemaFieldType = "dateType"
)

var AllSchemaFieldType = []SchemaFieldType{
	SchemaFieldTypeStringType,
	SchemaFieldTypeNumberType,
	SchemaFieldTypeBooleanType,
	SchemaFieldTypeDateType,
}

func (e SchemaFieldType) IsValid() bool {
	switch e {
	case SchemaFieldTypeStringType, SchemaFieldTypeNumberType, SchemaFieldTypeBooleanType, SchemaFieldTypeDateType:
		return true
	}
	return false
}

func (e SchemaFieldType) String() string {
	return string(e)
}

func (e *SchemaFieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SchemaFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SchemaFieldType", str)
	}
	return nil
}

func (e SchemaFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SendStrategy string

const (
	SendStrategyDesktopThenPush SendStrategy = "desktopThenPush"
	SendStrategyDesktopAndPush  SendStrategy = "desktopAndPush"
	SendStrategyDesktop         SendStrategy = "desktop"
	SendStrategyPush            SendStrategy = "push"
)

var AllSendStrategy = []SendStrategy{
	SendStrategyDesktopThenPush,
	SendStrategyDesktopAndPush,
	SendStrategyDesktop,
	SendStrategyPush,
}

func (e SendStrategy) IsValid() bool {
	switch e {
	case SendStrategyDesktopThenPush, SendStrategyDesktopAndPush, SendStrategyDesktop, SendStrategyPush:
		return true
	}
	return false
}

func (e SendStrategy) String() string {
	return string(e)
}

func (e *SendStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SendStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SendStrategy", str)
	}
	return nil
}

func (e SendStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SLAStatus string

const (
	SLAStatusBreached   SLAStatus = "Breached"
	SLAStatusHighRisk   SLAStatus = "HighRisk"
	SLAStatusMediumRisk SLAStatus = "MediumRisk"
	SLAStatusLowRisk    SLAStatus = "LowRisk"
	SLAStatusCompleted  SLAStatus = "Completed"
	SLAStatusFailed     SLAStatus = "Failed"
)

var AllSLAStatus = []SLAStatus{
	SLAStatusBreached,
	SLAStatusHighRisk,
	SLAStatusMediumRisk,
	SLAStatusLowRisk,
	SLAStatusCompleted,
	SLAStatusFailed,
}

func (e SLAStatus) IsValid() bool {
	switch e {
	case SLAStatusBreached, SLAStatusHighRisk, SLAStatusMediumRisk, SLAStatusLowRisk, SLAStatusCompleted, SLAStatusFailed:
		return true
	}
	return false
}

func (e SLAStatus) String() string {
	return string(e)
}

func (e *SLAStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SLAStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SlaStatus", str)
	}
	return nil
}

func (e SLAStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SlackChannelType string

const (
	SlackChannelTypeDirectMessage            SlackChannelType = "DirectMessage"
	SlackChannelTypeMultiPersonDirectMessage SlackChannelType = "MultiPersonDirectMessage"
	SlackChannelTypePrivate                  SlackChannelType = "Private"
	SlackChannelTypePublic                   SlackChannelType = "Public"
)

var AllSlackChannelType = []SlackChannelType{
	SlackChannelTypeDirectMessage,
	SlackChannelTypeMultiPersonDirectMessage,
	SlackChannelTypePrivate,
	SlackChannelTypePublic,
}

func (e SlackChannelType) IsValid() bool {
	switch e {
	case SlackChannelTypeDirectMessage, SlackChannelTypeMultiPersonDirectMessage, SlackChannelTypePrivate, SlackChannelTypePublic:
		return true
	}
	return false
}

func (e SlackChannelType) String() string {
	return string(e)
}

func (e *SlackChannelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SlackChannelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SlackChannelType", str)
	}
	return nil
}

func (e SlackChannelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// How trashed models should be loaded.
type TrashOptionType string

const (
	TrashOptionTypeIncludeTrash TrashOptionType = "includeTrash"
	TrashOptionTypeExcludeTrash TrashOptionType = "excludeTrash"
	TrashOptionTypeTrashOnly    TrashOptionType = "trashOnly"
)

var AllTrashOptionType = []TrashOptionType{
	TrashOptionTypeIncludeTrash,
	TrashOptionTypeExcludeTrash,
	TrashOptionTypeTrashOnly,
}

func (e TrashOptionType) IsValid() bool {
	switch e {
	case TrashOptionTypeIncludeTrash, TrashOptionTypeExcludeTrash, TrashOptionTypeTrashOnly:
		return true
	}
	return false
}

func (e TrashOptionType) String() string {
	return string(e)
}

func (e *TrashOptionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrashOptionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrashOptionType", str)
	}
	return nil
}

func (e TrashOptionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which action should be taken after an issue is added to triage.
type TriageResponsibilityAction string

const (
	TriageResponsibilityActionAssign TriageResponsibilityAction = "assign"
	TriageResponsibilityActionNotify TriageResponsibilityAction = "notify"
)

var AllTriageResponsibilityAction = []TriageResponsibilityAction{
	TriageResponsibilityActionAssign,
	TriageResponsibilityActionNotify,
}

func (e TriageResponsibilityAction) IsValid() bool {
	switch e {
	case TriageResponsibilityActionAssign, TriageResponsibilityActionNotify:
		return true
	}
	return false
}

func (e TriageResponsibilityAction) String() string {
	return string(e)
}

func (e *TriageResponsibilityAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TriageResponsibilityAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TriageResponsibilityAction", str)
	}
	return nil
}

func (e TriageResponsibilityAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserContextViewType string

const (
	UserContextViewTypeAssigned UserContextViewType = "assigned"
)

var AllUserContextViewType = []UserContextViewType{
	UserContextViewTypeAssigned,
}

func (e UserContextViewType) IsValid() bool {
	switch e {
	case UserContextViewTypeAssigned:
		return true
	}
	return false
}

func (e UserContextViewType) String() string {
	return string(e)
}

func (e *UserContextViewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserContextViewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserContextViewType", str)
	}
	return nil
}

func (e UserContextViewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of flags that the user can have.
type UserFlagType string

const (
	UserFlagTypeUpdatedSlackThreadSyncIntegration        UserFlagType = "updatedSlackThreadSyncIntegration"
	UserFlagTypeCompletedOnboarding                      UserFlagType = "completedOnboarding"
	UserFlagTypeDesktopInstalled                         UserFlagType = "desktopInstalled"
	UserFlagTypeTeamsPageIntroductionDismissed           UserFlagType = "teamsPageIntroductionDismissed"
	UserFlagTypeJoinTeamIntroductionDismissed            UserFlagType = "joinTeamIntroductionDismissed"
	UserFlagTypeDesktopDownloadToastDismissed            UserFlagType = "desktopDownloadToastDismissed"
	UserFlagTypeEmptyBacklogDismissed                    UserFlagType = "emptyBacklogDismissed"
	UserFlagTypeEmptyCustomViewsDismissed                UserFlagType = "emptyCustomViewsDismissed"
	UserFlagTypeEmptyActiveIssuesDismissed               UserFlagType = "emptyActiveIssuesDismissed"
	UserFlagTypeEmptyMyIssuesDismissed                   UserFlagType = "emptyMyIssuesDismissed"
	UserFlagTypeTriageWelcomeDismissed                   UserFlagType = "triageWelcomeDismissed"
	UserFlagTypeCycleWelcomeDismissed                    UserFlagType = "cycleWelcomeDismissed"
	UserFlagTypeProjectWelcomeDismissed                  UserFlagType = "projectWelcomeDismissed"
	UserFlagTypeProjectBacklogWelcomeDismissed           UserFlagType = "projectBacklogWelcomeDismissed"
	UserFlagTypeProjectUpdatesWelcomeDismissed           UserFlagType = "projectUpdatesWelcomeDismissed"
	UserFlagTypeAnalyticsWelcomeDismissed                UserFlagType = "analyticsWelcomeDismissed"
	UserFlagTypeInsightsWelcomeDismissed                 UserFlagType = "insightsWelcomeDismissed"
	UserFlagTypeInsightsHelpDismissed                    UserFlagType = "insightsHelpDismissed"
	UserFlagTypeFigmaPromptDismissed                     UserFlagType = "figmaPromptDismissed"
	UserFlagTypeIssueMovePromptCompleted                 UserFlagType = "issueMovePromptCompleted"
	UserFlagTypeMigrateThemePreference                   UserFlagType = "migrateThemePreference"
	UserFlagTypeListSelectionTip                         UserFlagType = "listSelectionTip"
	UserFlagTypeEmptyParagraphSlashCommandTip            UserFlagType = "emptyParagraphSlashCommandTip"
	UserFlagTypeEditorSlashCommandUsed                   UserFlagType = "editorSlashCommandUsed"
	UserFlagTypeCanPlaySnake                             UserFlagType = "canPlaySnake"
	UserFlagTypeCanPlayTetris                            UserFlagType = "canPlayTetris"
	UserFlagTypeImportBannerDismissed                    UserFlagType = "importBannerDismissed"
	UserFlagTypeTryInvitePeopleDismissed                 UserFlagType = "tryInvitePeopleDismissed"
	UserFlagTypeTryRoadmapsDismissed                     UserFlagType = "tryRoadmapsDismissed"
	UserFlagTypeTryCyclesDismissed                       UserFlagType = "tryCyclesDismissed"
	UserFlagTypeTryTriageDismissed                       UserFlagType = "tryTriageDismissed"
	UserFlagTypeTryGithubDismissed                       UserFlagType = "tryGithubDismissed"
	UserFlagTypeRewindBannerDismissed                    UserFlagType = "rewindBannerDismissed"
	UserFlagTypeHelpIslandFeatureInsightsDismissed       UserFlagType = "helpIslandFeatureInsightsDismissed"
	UserFlagTypeDueDateShortcutMigration                 UserFlagType = "dueDateShortcutMigration"
	UserFlagTypeSlackCommentReactionTipShown             UserFlagType = "slackCommentReactionTipShown"
	UserFlagTypeIssueLabelSuggestionUsed                 UserFlagType = "issueLabelSuggestionUsed"
	UserFlagTypeThreadedCommentsNudgeIsSeen              UserFlagType = "threadedCommentsNudgeIsSeen"
	UserFlagTypeDesktopTabsOnboardingDismissed           UserFlagType = "desktopTabsOnboardingDismissed"
	UserFlagTypeMilestoneOnboardingIsSeenAndDismissed    UserFlagType = "milestoneOnboardingIsSeenAndDismissed"
	UserFlagTypeProjectBoardOnboardingIsSeenAndDismissed UserFlagType = "projectBoardOnboardingIsSeenAndDismissed"
	UserFlagTypeFigmaPluginBannerDismissed               UserFlagType = "figmaPluginBannerDismissed"
	UserFlagTypeInitiativesBannerDismissed               UserFlagType = "initiativesBannerDismissed"
	UserFlagTypeAll                                      UserFlagType = "all"
)

var AllUserFlagType = []UserFlagType{
	UserFlagTypeUpdatedSlackThreadSyncIntegration,
	UserFlagTypeCompletedOnboarding,
	UserFlagTypeDesktopInstalled,
	UserFlagTypeTeamsPageIntroductionDismissed,
	UserFlagTypeJoinTeamIntroductionDismissed,
	UserFlagTypeDesktopDownloadToastDismissed,
	UserFlagTypeEmptyBacklogDismissed,
	UserFlagTypeEmptyCustomViewsDismissed,
	UserFlagTypeEmptyActiveIssuesDismissed,
	UserFlagTypeEmptyMyIssuesDismissed,
	UserFlagTypeTriageWelcomeDismissed,
	UserFlagTypeCycleWelcomeDismissed,
	UserFlagTypeProjectWelcomeDismissed,
	UserFlagTypeProjectBacklogWelcomeDismissed,
	UserFlagTypeProjectUpdatesWelcomeDismissed,
	UserFlagTypeAnalyticsWelcomeDismissed,
	UserFlagTypeInsightsWelcomeDismissed,
	UserFlagTypeInsightsHelpDismissed,
	UserFlagTypeFigmaPromptDismissed,
	UserFlagTypeIssueMovePromptCompleted,
	UserFlagTypeMigrateThemePreference,
	UserFlagTypeListSelectionTip,
	UserFlagTypeEmptyParagraphSlashCommandTip,
	UserFlagTypeEditorSlashCommandUsed,
	UserFlagTypeCanPlaySnake,
	UserFlagTypeCanPlayTetris,
	UserFlagTypeImportBannerDismissed,
	UserFlagTypeTryInvitePeopleDismissed,
	UserFlagTypeTryRoadmapsDismissed,
	UserFlagTypeTryCyclesDismissed,
	UserFlagTypeTryTriageDismissed,
	UserFlagTypeTryGithubDismissed,
	UserFlagTypeRewindBannerDismissed,
	UserFlagTypeHelpIslandFeatureInsightsDismissed,
	UserFlagTypeDueDateShortcutMigration,
	UserFlagTypeSlackCommentReactionTipShown,
	UserFlagTypeIssueLabelSuggestionUsed,
	UserFlagTypeThreadedCommentsNudgeIsSeen,
	UserFlagTypeDesktopTabsOnboardingDismissed,
	UserFlagTypeMilestoneOnboardingIsSeenAndDismissed,
	UserFlagTypeProjectBoardOnboardingIsSeenAndDismissed,
	UserFlagTypeFigmaPluginBannerDismissed,
	UserFlagTypeInitiativesBannerDismissed,
	UserFlagTypeAll,
}

func (e UserFlagType) IsValid() bool {
	switch e {
	case UserFlagTypeUpdatedSlackThreadSyncIntegration, UserFlagTypeCompletedOnboarding, UserFlagTypeDesktopInstalled, UserFlagTypeTeamsPageIntroductionDismissed, UserFlagTypeJoinTeamIntroductionDismissed, UserFlagTypeDesktopDownloadToastDismissed, UserFlagTypeEmptyBacklogDismissed, UserFlagTypeEmptyCustomViewsDismissed, UserFlagTypeEmptyActiveIssuesDismissed, UserFlagTypeEmptyMyIssuesDismissed, UserFlagTypeTriageWelcomeDismissed, UserFlagTypeCycleWelcomeDismissed, UserFlagTypeProjectWelcomeDismissed, UserFlagTypeProjectBacklogWelcomeDismissed, UserFlagTypeProjectUpdatesWelcomeDismissed, UserFlagTypeAnalyticsWelcomeDismissed, UserFlagTypeInsightsWelcomeDismissed, UserFlagTypeInsightsHelpDismissed, UserFlagTypeFigmaPromptDismissed, UserFlagTypeIssueMovePromptCompleted, UserFlagTypeMigrateThemePreference, UserFlagTypeListSelectionTip, UserFlagTypeEmptyParagraphSlashCommandTip, UserFlagTypeEditorSlashCommandUsed, UserFlagTypeCanPlaySnake, UserFlagTypeCanPlayTetris, UserFlagTypeImportBannerDismissed, UserFlagTypeTryInvitePeopleDismissed, UserFlagTypeTryRoadmapsDismissed, UserFlagTypeTryCyclesDismissed, UserFlagTypeTryTriageDismissed, UserFlagTypeTryGithubDismissed, UserFlagTypeRewindBannerDismissed, UserFlagTypeHelpIslandFeatureInsightsDismissed, UserFlagTypeDueDateShortcutMigration, UserFlagTypeSlackCommentReactionTipShown, UserFlagTypeIssueLabelSuggestionUsed, UserFlagTypeThreadedCommentsNudgeIsSeen, UserFlagTypeDesktopTabsOnboardingDismissed, UserFlagTypeMilestoneOnboardingIsSeenAndDismissed, UserFlagTypeProjectBoardOnboardingIsSeenAndDismissed, UserFlagTypeFigmaPluginBannerDismissed, UserFlagTypeInitiativesBannerDismissed, UserFlagTypeAll:
		return true
	}
	return false
}

func (e UserFlagType) String() string {
	return string(e)
}

func (e *UserFlagType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserFlagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserFlagType", str)
	}
	return nil
}

func (e UserFlagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Operations that can be applied to UserFlagType.
type UserFlagUpdateOperation string

const (
	UserFlagUpdateOperationIncr  UserFlagUpdateOperation = "incr"
	UserFlagUpdateOperationDecr  UserFlagUpdateOperation = "decr"
	UserFlagUpdateOperationClear UserFlagUpdateOperation = "clear"
	UserFlagUpdateOperationLock  UserFlagUpdateOperation = "lock"
)

var AllUserFlagUpdateOperation = []UserFlagUpdateOperation{
	UserFlagUpdateOperationIncr,
	UserFlagUpdateOperationDecr,
	UserFlagUpdateOperationClear,
	UserFlagUpdateOperationLock,
}

func (e UserFlagUpdateOperation) IsValid() bool {
	switch e {
	case UserFlagUpdateOperationIncr, UserFlagUpdateOperationDecr, UserFlagUpdateOperationClear, UserFlagUpdateOperationLock:
		return true
	}
	return false
}

func (e UserFlagUpdateOperation) String() string {
	return string(e)
}

func (e *UserFlagUpdateOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserFlagUpdateOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserFlagUpdateOperation", str)
	}
	return nil
}

func (e UserFlagUpdateOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different permission roles available to users on an organization.
type UserRoleType string

const (
	UserRoleTypeAdmin UserRoleType = "admin"
	UserRoleTypeGuest UserRoleType = "guest"
	UserRoleTypeUser  UserRoleType = "user"
)

var AllUserRoleType = []UserRoleType{
	UserRoleTypeAdmin,
	UserRoleTypeGuest,
	UserRoleTypeUser,
}

func (e UserRoleType) IsValid() bool {
	switch e {
	case UserRoleTypeAdmin, UserRoleTypeGuest, UserRoleTypeUser:
		return true
	}
	return false
}

func (e UserRoleType) String() string {
	return string(e)
}

func (e *UserRoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRoleType", str)
	}
	return nil
}

func (e UserRoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of view preferences (either user or organization level preferences).
type ViewPreferencesType string

const (
	ViewPreferencesTypeOrganization ViewPreferencesType = "organization"
	ViewPreferencesTypeUser         ViewPreferencesType = "user"
)

var AllViewPreferencesType = []ViewPreferencesType{
	ViewPreferencesTypeOrganization,
	ViewPreferencesTypeUser,
}

func (e ViewPreferencesType) IsValid() bool {
	switch e {
	case ViewPreferencesTypeOrganization, ViewPreferencesTypeUser:
		return true
	}
	return false
}

func (e ViewPreferencesType) String() string {
	return string(e)
}

func (e *ViewPreferencesType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ViewPreferencesType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ViewPreferencesType", str)
	}
	return nil
}

func (e ViewPreferencesType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The client view this custom view is targeting.
type ViewType string

const (
	ViewTypeInbox                    ViewType = "inbox"
	ViewTypeMyIssues                 ViewType = "myIssues"
	ViewTypeMyIssuesCreatedByMe      ViewType = "myIssuesCreatedByMe"
	ViewTypeMyIssuesSubscribedTo     ViewType = "myIssuesSubscribedTo"
	ViewTypeMyIssuesActivity         ViewType = "myIssuesActivity"
	ViewTypeUserProfile              ViewType = "userProfile"
	ViewTypeUserProfileCreatedByUser ViewType = "userProfileCreatedByUser"
	ViewTypeBoard                    ViewType = "board"
	ViewTypeCompletedCycle           ViewType = "completedCycle"
	ViewTypeCycle                    ViewType = "cycle"
	ViewTypeProject                  ViewType = "project"
	ViewTypeProjectDocuments         ViewType = "projectDocuments"
	ViewTypeLabel                    ViewType = "label"
	ViewTypeTriage                   ViewType = "triage"
	ViewTypeActiveIssues             ViewType = "activeIssues"
	ViewTypeBacklog                  ViewType = "backlog"
	ViewTypeAllIssues                ViewType = "allIssues"
	ViewTypeCustomView               ViewType = "customView"
	ViewTypeCustomViews              ViewType = "customViews"
	ViewTypeCustomRoadmap            ViewType = "customRoadmap"
	ViewTypeRoadmap                  ViewType = "roadmap"
	ViewTypeRoadmaps                 ViewType = "roadmaps"
	ViewTypeRoadmapAll               ViewType = "roadmapAll"
	ViewTypeRoadmapClosed            ViewType = "roadmapClosed"
	ViewTypeRoadmapBacklog           ViewType = "roadmapBacklog"
	ViewTypeInitiative               ViewType = "initiative"
	ViewTypeInitiativeOverview       ViewType = "initiativeOverview"
	ViewTypeInitiatives              ViewType = "initiatives"
	ViewTypeInitiativesPlanned       ViewType = "initiativesPlanned"
	ViewTypeInitiativesCompleted     ViewType = "initiativesCompleted"
	ViewTypeProjects                 ViewType = "projects"
	ViewTypeProjectsAll              ViewType = "projectsAll"
	ViewTypeProjectsBacklog          ViewType = "projectsBacklog"
	ViewTypeProjectsClosed           ViewType = "projectsClosed"
	ViewTypeSearch                   ViewType = "search"
	ViewTypeSplitSearch              ViewType = "splitSearch"
	ViewTypeTeams                    ViewType = "teams"
	ViewTypeArchive                  ViewType = "archive"
	ViewTypeQuickView                ViewType = "quickView"
	ViewTypeIssueIdentifiers         ViewType = "issueIdentifiers"
	ViewTypeCustomers                ViewType = "customers"
)

var AllViewType = []ViewType{
	ViewTypeInbox,
	ViewTypeMyIssues,
	ViewTypeMyIssuesCreatedByMe,
	ViewTypeMyIssuesSubscribedTo,
	ViewTypeMyIssuesActivity,
	ViewTypeUserProfile,
	ViewTypeUserProfileCreatedByUser,
	ViewTypeBoard,
	ViewTypeCompletedCycle,
	ViewTypeCycle,
	ViewTypeProject,
	ViewTypeProjectDocuments,
	ViewTypeLabel,
	ViewTypeTriage,
	ViewTypeActiveIssues,
	ViewTypeBacklog,
	ViewTypeAllIssues,
	ViewTypeCustomView,
	ViewTypeCustomViews,
	ViewTypeCustomRoadmap,
	ViewTypeRoadmap,
	ViewTypeRoadmaps,
	ViewTypeRoadmapAll,
	ViewTypeRoadmapClosed,
	ViewTypeRoadmapBacklog,
	ViewTypeInitiative,
	ViewTypeInitiativeOverview,
	ViewTypeInitiatives,
	ViewTypeInitiativesPlanned,
	ViewTypeInitiativesCompleted,
	ViewTypeProjects,
	ViewTypeProjectsAll,
	ViewTypeProjectsBacklog,
	ViewTypeProjectsClosed,
	ViewTypeSearch,
	ViewTypeSplitSearch,
	ViewTypeTeams,
	ViewTypeArchive,
	ViewTypeQuickView,
	ViewTypeIssueIdentifiers,
	ViewTypeCustomers,
}

func (e ViewType) IsValid() bool {
	switch e {
	case ViewTypeInbox, ViewTypeMyIssues, ViewTypeMyIssuesCreatedByMe, ViewTypeMyIssuesSubscribedTo, ViewTypeMyIssuesActivity, ViewTypeUserProfile, ViewTypeUserProfileCreatedByUser, ViewTypeBoard, ViewTypeCompletedCycle, ViewTypeCycle, ViewTypeProject, ViewTypeProjectDocuments, ViewTypeLabel, ViewTypeTriage, ViewTypeActiveIssues, ViewTypeBacklog, ViewTypeAllIssues, ViewTypeCustomView, ViewTypeCustomViews, ViewTypeCustomRoadmap, ViewTypeRoadmap, ViewTypeRoadmaps, ViewTypeRoadmapAll, ViewTypeRoadmapClosed, ViewTypeRoadmapBacklog, ViewTypeInitiative, ViewTypeInitiativeOverview, ViewTypeInitiatives, ViewTypeInitiativesPlanned, ViewTypeInitiativesCompleted, ViewTypeProjects, ViewTypeProjectsAll, ViewTypeProjectsBacklog, ViewTypeProjectsClosed, ViewTypeSearch, ViewTypeSplitSearch, ViewTypeTeams, ViewTypeArchive, ViewTypeQuickView, ViewTypeIssueIdentifiers, ViewTypeCustomers:
		return true
	}
	return false
}

func (e ViewType) String() string {
	return string(e)
}

func (e *ViewType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ViewType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ViewType", str)
	}
	return nil
}

func (e ViewType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowTrigger string

const (
	WorkflowTriggerEntityCreated          WorkflowTrigger = "entityCreated"
	WorkflowTriggerEntityUpdated          WorkflowTrigger = "entityUpdated"
	WorkflowTriggerEntityCreatedOrUpdated WorkflowTrigger = "entityCreatedOrUpdated"
	WorkflowTriggerEntityRemoved          WorkflowTrigger = "entityRemoved"
	WorkflowTriggerEntityUnarchived       WorkflowTrigger = "entityUnarchived"
)

var AllWorkflowTrigger = []WorkflowTrigger{
	WorkflowTriggerEntityCreated,
	WorkflowTriggerEntityUpdated,
	WorkflowTriggerEntityCreatedOrUpdated,
	WorkflowTriggerEntityRemoved,
	WorkflowTriggerEntityUnarchived,
}

func (e WorkflowTrigger) IsValid() bool {
	switch e {
	case WorkflowTriggerEntityCreated, WorkflowTriggerEntityUpdated, WorkflowTriggerEntityCreatedOrUpdated, WorkflowTriggerEntityRemoved, WorkflowTriggerEntityUnarchived:
		return true
	}
	return false
}

func (e WorkflowTrigger) String() string {
	return string(e)
}

func (e *WorkflowTrigger) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowTrigger(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowTrigger", str)
	}
	return nil
}

func (e WorkflowTrigger) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowTriggerType string

const (
	WorkflowTriggerTypeIssue   WorkflowTriggerType = "issue"
	WorkflowTriggerTypeProject WorkflowTriggerType = "project"
)

var AllWorkflowTriggerType = []WorkflowTriggerType{
	WorkflowTriggerTypeIssue,
	WorkflowTriggerTypeProject,
}

func (e WorkflowTriggerType) IsValid() bool {
	switch e {
	case WorkflowTriggerTypeIssue, WorkflowTriggerTypeProject:
		return true
	}
	return false
}

func (e WorkflowTriggerType) String() string {
	return string(e)
}

func (e *WorkflowTriggerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowTriggerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowTriggerType", str)
	}
	return nil
}

func (e WorkflowTriggerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowType string

const (
	WorkflowTypeSLA              WorkflowType = "sla"
	WorkflowTypeCustom           WorkflowType = "custom"
	WorkflowTypeViewSubscription WorkflowType = "viewSubscription"
)

var AllWorkflowType = []WorkflowType{
	WorkflowTypeSLA,
	WorkflowTypeCustom,
	WorkflowTypeViewSubscription,
}

func (e WorkflowType) IsValid() bool {
	switch e {
	case WorkflowTypeSLA, WorkflowTypeCustom, WorkflowTypeViewSubscription:
		return true
	}
	return false
}

func (e WorkflowType) String() string {
	return string(e)
}

func (e *WorkflowType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowType", str)
	}
	return nil
}

func (e WorkflowType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
